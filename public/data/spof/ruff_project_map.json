{
  "IDE & Editor Integration": {
    "description": "Provides real-time linting, formatting, and type-checking directly within popular code editors (like VS Code and Neovim) via the Language Server Protocol (LSP). This enables instant feedback and auto-fixing during development.",
    "functions": {
      "Integration Documentation & Guides": {
        "files": [
          {
            "path": "docs/editors/features.md",
            "description": "This file provides a detailed overview of the features offered by the Ruff Language Server, including diagnostic highlighting, dynamic configuration, formatting, code actions, hover functionality, and Jupyter Notebook support.",
            "spof": false
          },
          {
            "path": "docs/editors/index.md",
            "description": "This file provides an overview of Ruff's editor integrations, detailing how to set up Ruff with various editors and IDEs, primarily through its built-in Language Server Protocol (LSP) implementation.",
            "spof": true
          },
          {
            "path": "docs/editors/migration.md",
            "description": "This document guides users through migrating from the `ruff-lsp` (Python-based) language server to the native (Rust-based) Ruff language server, detailing changes in settings and configurations.",
            "spof": true
          },
          {
            "path": "docs/editors/settings.md",
            "description": "This document details the various configuration options and settings available for customizing the Ruff Language Server's behavior in different editors, including how to integrate existing configuration files or use inline JSON settings.",
            "spof": false
          },
          {
            "path": "docs/editors/setup.md",
            "description": "This document provides setup instructions for integrating the Ruff linter and formatter with various code editors such as VS Code, Neovim, Vim, Helix, and Kate. It covers configuration steps, including managing Ruff's language server, and handling conflicts with other language servers.",
            "spof": false
          },
          {
            "path": "crates/ruff_server/README.md",
            "description": "This README describes the Ruff Language Server, explaining its role in powering Ruff's editor integrations by providing real-time diagnostics and formatted code. It also includes information on documentation and contributing.",
            "spof": false
          },
          {
            "path": "crates/ruff_server/docs/MIGRATION.md",
            "description": "This file serves as a redirect, indicating that the `ruff-lsp` migration guide has been moved to an external documentation site.",
            "spof": false
          },
          {
            "path": "crates/ruff_server/docs/setup/HELIX.md",
            "description": "This file served as a setup guide for Ruff server with Helix, but now primarily acts as a redirect to the updated documentation on the official Ruff website.",
            "spof": false
          },
          {
            "path": "crates/ruff_server/docs/setup/NEOVIM.md",
            "description": "This file was formerly a Neovim setup guide for `ruff server`. It now serves as a redirect to the updated documentation on the official Ruff website.",
            "spof": false
          },
          {
            "path": "crates/ruff_server/docs/setup/VIM.md",
            "description": "This file is a redirect notice, informing users that the Vim setup guide for `ruff server` has been moved to a new URL within the official documentation.",
            "spof": false
          },
          {
            "path": "crates/ruff_server/docs/setup/KATE.md",
            "description": "This file is a redirect or placeholder for the Kate setup guide for ruff server, indicating that the content has been moved to the official documentation site.",
            "spof": false
          }
        ],
        "contributors": [
          {
            "name": "Dhruv Manilawala",
            "percent": 48
          },
          {
            "name": "Justin Su",
            "percent": 10
          },
          {
            "name": "Peter Tripp",
            "percent": 8
          }
        ]
      },
      "LSP Framework & Server Operations": {
        "files": [
          {
            "path": "crates/ruff/src/commands/server.rs",
            "description": "This file implements the `ruff server` command, responsible for starting and running the Ruff language server.",
            "spof": false
          },
          {
            "path": "crates/ruff_server/CONTRIBUTING.md",
            "description": "This document provides a guide for contributing to the Ruff Language Server, detailing its architecture, specifically its lock-free data model and task processing, and how to test changes made to the server.",
            "spof": true
          },
          {
            "path": "crates/ruff_server/src/resolve.rs",
            "description": "This file contains logic to determine whether a given document path should be excluded from linting or formatting based on project-wide and tool-specific exclusion/inclusion rules and language identification.",
            "spof": true
          },
          {
            "path": "crates/ruff_server/src/lib.rs",
            "description": "This file is the main entry point and core logic for the Ruff Language Server, responsible for setting up and running the LSP server, handling connections, and managing sessions.",
            "spof": true
          },
          {
            "path": "crates/ruff_server/src/workspace.rs",
            "description": "This file defines structures and logic for managing multiple LSP workspaces within the Ruff server, including their creation from client-provided folders or defaulting to the current directory, and associating them with specific client options.",
            "spof": false
          },
          {
            "path": "crates/ruff_server/src/edit.rs",
            "description": "This file defines core types and utilities for text manipulation, document identification, and LSP-related edits within the Ruff Language Server. It handles position encodings, document keys for various file types (including notebooks), and manages workspace edits for LSP communication.",
            "spof": false
          },
          {
            "path": "crates/ruff_server/src/session.rs",
            "description": "This file defines the core `Session` and `DocumentSnapshot` structs, managing the global state, document indexing, client settings, capabilities, and the lifecycle of text and notebook documents for the Language Server Protocol (LSP) server.",
            "spof": false
          },
          {
            "path": "crates/ruff_server/src/server.rs",
            "description": "This file defines the main Language Server Protocol (LSP) server for Ruff, handling its initialization, capabilities negotiation, and the primary event loop for processing LSP requests and managing client interactions.",
            "spof": false
          },
          {
            "path": "crates/ruff_server/src/server/connection.rs",
            "description": "This file defines the `ConnectionInitializer` responsible for establishing and managing the Language Server Protocol (LSP) connection, including the crucial initialization handshake with the client.",
            "spof": true
          },
          {
            "path": "crates/ruff_server/src/server/schedule.rs",
            "description": "This file manages and schedules tasks within the `ruff_server`, handling synchronous operations directly and dispatching background tasks to dedicated thread pools, including one for formatting and another for general worker tasks.",
            "spof": false
          },
          {
            "path": "crates/ruff_server/src/server/main_loop.rs",
            "description": "This file defines the main event loop for the Language Server Protocol (LSP) server, handling incoming client messages, managing requests and responses, and initializing server capabilities like file watchers.",
            "spof": true
          },
          {
            "path": "crates/ruff_server/src/server/api.rs",
            "description": "This file implements the core API for the Ruff Language Server, acting as the central dispatcher for incoming Language Server Protocol (LSP) requests and notifications, routing them to appropriate synchronous or background task handlers.",
            "spof": true
          },
          {
            "path": "crates/ruff_server/src/server/api/traits.rs",
            "description": "Defines traits for handling Language Server Protocol (LSP) requests and notifications, abstracting different execution models (synchronous or background) and access patterns (session-level or document-specific snapshots).",
            "spof": false
          },
          {
            "path": "crates/ruff_server/src/server/api/notifications.rs",
            "description": "This file aggregates and re-exports various Language Server Protocol (LSP) notification handlers within the ruff server. It serves as a central point for managing different types of 'did change', 'did open', 'did close', and 'cancel' notifications.",
            "spof": false
          },
          {
            "path": "crates/ruff_server/src/server/api/notifications/did_change_watched_files.rs",
            "description": "This file implements the LSP `DidChangeWatchedFiles` notification handler, which reloads session settings and refreshes or republishes diagnostics for relevant documents when watched files change.",
            "spof": false
          },
          {
            "path": "crates/ruff_server/src/server/api/notifications/did_change.rs",
            "description": "This file implements the handler for `textDocument/didChange` LSP notifications. It updates the server's internal representation of a document when its content changes and conditionally publishes new diagnostics.",
            "spof": false
          },
          {
            "path": "crates/ruff_server/src/server/api/notifications/did_close.rs",
            "description": "This file handles the Language Server Protocol (LSP) 'textDocument/didClose' notification, clearing diagnostics and closing the document within the server session when a client closes a text document.",
            "spof": false
          },
          {
            "path": "crates/ruff_server/src/server/api/notifications/did_close_notebook.rs",
            "description": "Handles the Language Server Protocol (LSP) `didCloseNotebookDocument` notification, instructing the server to close a notebook document in its session based on the provided URI.",
            "spof": false
          },
          {
            "path": "crates/ruff_server/src/server/api/notifications/cancel.rs",
            "description": "This file defines the handler for the Language Server Protocol (LSP) 'cancel' notification. It processes requests from the client to cancel pending operations identified by a specific request ID.",
            "spof": true
          },
          {
            "path": "crates/ruff_server/src/server/api/notifications/did_change_workspace.rs",
            "description": "This file implements the handler for Language Server Protocol (LSP) 'didChangeWorkspaceFolders' notifications. It processes additions and removals of workspace folders, updating the server session accordingly.",
            "spof": false
          },
          {
            "path": "crates/ruff_server/src/server/api/notifications/did_change_configuration.rs",
            "description": "This file defines a Language Server Protocol (LSP) handler for the `didChangeConfiguration` notification, allowing the server to react to client-side configuration changes.",
            "spof": false
          },
          {
            "path": "crates/ruff_server/src/server/api/notifications/did_open.rs",
            "description": "This file handles the Language Server Protocol (LSP) `textDocument/didOpen` notification, registering the newly opened document with the server session. It also triggers the publishing of diagnostics for the document if the client does not support pull diagnostics.",
            "spof": false
          },
          {
            "path": "crates/ruff_server/src/server/api/notifications/did_change_notebook.rs",
            "description": "This file implements the Language Server Protocol (LSP) handler for the `notebookDocument/didChange` notification. It updates the server's internal state of a notebook document upon changes and subsequently publishes updated diagnostics.",
            "spof": false
          },
          {
            "path": "crates/ruff_server/src/server/api/notifications/did_open_notebook.rs",
            "description": "This file handles the Language Server Protocol (LSP) `didOpenNotebookDocument` notification, which is triggered when a notebook document is opened by the client. It parses the notebook's content, registers it with the server's session, and publishes initial diagnostics for it.",
            "spof": false
          },
          {
            "path": "crates/ruff_server/src/server/api/requests/execute_command.rs",
            "description": "Handles Language Server Protocol (LSP) `workspace/executeCommand` requests, dispatching them to apply code fixes, format documents, organize imports, or provide debug information for the Ruff server.",
            "spof": false
          },
          {
            "path": "crates/ruff_server/src/server/api/requests/shutdown.rs",
            "description": "This file defines the handler for the Language Server Protocol (LSP) 'shutdown' request. It marks the server session as awaiting shutdown, preparing for graceful termination upon receiving a 'exit' notification.",
            "spof": true
          },
          {
            "path": "crates/ruff_server/src/server/schedule/task.rs",
            "description": "This file defines the `Task` enum, which represents operations to be executed by a language server, specifying whether they run on the main thread or a background thread, and their priority (`BackgroundSchedule`). It provides methods for creating synchronous and background tasks for different server operations.",
            "spof": true
          },
          {
            "path": "crates/ruff_server/src/session/client.rs",
            "description": "This file defines the `Client` struct, which manages communication between the Ruff language server and an LSP client, handling requests, notifications, and responses.",
            "spof": true
          },
          {
            "path": "crates/ruff_server/src/session/request_queue.rs",
            "description": "This file defines data structures and logic for managing the lifecycle of incoming (client-to-server) and outgoing (server-to-client) requests within an LSP server, including tracking pending requests and handling request cancellation.",
            "spof": true
          },
          {
            "path": "crates/ruff_server/src/session/settings.rs",
            "description": "This file defines data structures and logic for resolving and managing client-specific settings received by the Ruff language server, encompassing linting, formatting, and editor configurations.",
            "spof": true
          },
          {
            "path": "crates/ruff_server/src/session/options.rs",
            "description": "This file defines data structures for parsing and managing configuration options received from a client, such as an LSP client, including global, client-specific, linting, and formatting settings for the Ruff linter.",
            "spof": true
          },
          {
            "path": "crates/ruff_server/src/session/index.rs",
            "description": "This file defines the `Index` struct, which acts as a central registry within the `ruff_server` session for tracking all open text and notebook documents, managing their lifecycle, and associating them with their respective workspace and Ruff settings.",
            "spof": false
          },
          {
            "path": "crates/ruff_server/src/session/capabilities.rs",
            "description": "This file defines and resolves the client capabilities for the Ruff Language Server Protocol (LSP) implementation. It extracts and stores specific feature supports from the LSP client capabilities, such as code action resolution and workspace edits.",
            "spof": true
          },
          {
            "path": "crates/ruff_server/src/session/index/ruff_settings.rs",
            "description": "Manages the loading, resolution, and indexing of Ruff linter and formatter settings for a workspace, combining project configuration files, editor settings, and fallback defaults. It provides a mechanism to retrieve the correct Ruff settings for any given file path within the workspace.",
            "spof": false
          },
          {
            "path": "crates/ruff_server/src/edit/text_document.rs",
            "description": "This file defines the `TextDocument` struct, which manages the content, version, and line index of an individual source code document within an LSP server, enabling it to track and apply user-made changes.",
            "spof": true
          },
          {
            "path": "crates/ruff_server/src/edit/notebook.rs",
            "description": "This file defines the data structures and logic for representing and managing notebook documents (like Jupyter notebooks) and their cells within the Ruff Language Server Protocol (LSP) server. It handles creation, updates, and conversion of notebook content for linting.",
            "spof": false
          },
          {
            "path": "crates/ruff_server/src/edit/range.rs",
            "description": "This file defines structures and traits for converting between LSP-style ranges, internal text ranges, and notebook-aware ranges within the Ruff server, handling position encoding and notebook cell mapping.",
            "spof": true
          },
          {
            "path": "crates/ruff_server/tests/document.rs",
            "description": "This file contains a test for the `TextDocument` functionality within the Ruff LSP server, specifically verifying its ability to correctly apply multiple text content changes, including deletions and insertions, to a document.",
            "spof": true
          },
          {
            "path": "crates/ruff_server/tests/notebook.rs",
            "description": "This file contains integration tests for the `ruff_server`'s Language Server Protocol (LSP) capabilities related to Jupyter notebooks, including opening notebooks and processing content changes to notebook cells.",
            "spof": false
          },
          {
            "path": "crates/ruff_server/tests/snapshots",
            "description": "This directory is designated to store snapshot test data for the `ruff_server` crate. Snapshot tests capture expected output or state, enabling regression testing by comparing current results against these stored references. Its current emptiness suggests either no snapshot tests are present yet, or snapshots are generated dynamically and not committed.",
            "spof": false
          },
          {
            "path": "crates/ruff_server/assets",
            "description": "This directory, named `assets`, is designated to hold static resources or auxiliary files for the `ruff_server` component. Although currently empty, it typically serves as a location for items such as configuration templates, default files, or other non-code dependencies that the server might require at runtime.",
            "spof": false
          },
          {
            "path": "crates/ruff_server/resources/test/fixtures/pandas_html.py",
            "description": "This file is a test fixture for Ruff's Language Server Protocol (LSP) functions, designed to test editing and fixing capabilities. It contains functionality for parsing HTML tables, adopted from the `pandas.io.html` module.",
            "spof": true
          },
          {
            "path": "crates/ruff_server/resources/test/fixtures/settings",
            "description": "This directory is designated for holding test fixtures related to settings within the `ruff_server` crate. It serves as a placeholder for various configuration files or setting profiles used during testing. Currently, it contains no specific fixtures.",
            "spof": false
          },
          {
            "path": "crates/ty_ide/src/markup.rs",
            "description": "This file defines an enum for different markup kinds (PlainText, Markdown) and provides structs and display implementations for rendering common elements like fenced code blocks and horizontal lines according to the specified markup style.",
            "spof": true
          },
          {
            "path": "crates/ty_project/src/watch/watcher.rs",
            "description": "This file implements a debouncing file system watcher that monitors directory changes, merges events, and notifies a handler, ensuring all changes are eventually processed.",
            "spof": true
          },
          {
            "path": "crates/ty_project/src/watch/project_watcher.rs",
            "description": "This file defines `ProjectWatcher`, which manages file system watchers for a Ruff project. It dynamically updates the set of watched paths based on the project's root, module search paths, included files, and configuration, ensuring that relevant file system events are observed.",
            "spof": true
          },
          {
            "path": "crates/ty_server/src/capabilities.rs",
            "description": "This file defines and resolves the capabilities of an LSP client, allowing the language server to adapt its behavior based on the client's supported features. It uses bitflags to efficiently store and check various client capabilities and defines server-supported commands.",
            "spof": false
          },
          {
            "path": "crates/ty_server/src/session.rs",
            "description": "Manages the global state, data models, configuration resolution, and lifecycle of the Language Server Protocol (LSP) session for the `ruff` type server.",
            "spof": false
          },
          {
            "path": "crates/ty_server/src/db.rs",
            "description": "This file defines a Salsa database trait (`Db`) that provides methods to retrieve LSP documents and notebook documents corresponding to files, typically those open in the editor, by querying the Language Server Protocol (LSP) system.",
            "spof": true
          },
          {
            "path": "crates/ty_server/src/lib.rs",
            "description": "This file implements the main entry point and core logic for the 'ty' Language Server Protocol (LSP) server, handling connections, worker threads, and orchestrating language services for the 'ruff' project.",
            "spof": false
          },
          {
            "path": "crates/ty_server/src/document.rs",
            "description": "Provides types and utilities for managing text documents, handling different text encodings, and converting between internal system paths and Language Server Protocol (LSP) document identifiers.",
            "spof": true
          },
          {
            "path": "crates/ty_server/src/system.rs",
            "description": "This file defines the `LSPSystem` which implements the `System` trait, allowing file system operations to be served from either an in-memory LSP document index or a native file system, prioritizing the index for managed documents.",
            "spof": true
          },
          {
            "path": "crates/ty_server/src/server.rs",
            "description": "This file defines the core `Server` struct for the `ty` Language Server Protocol (LSP) implementation. It handles LSP connection management, server initialization, capability negotiation, and sets up the main event loop and panic handling.",
            "spof": false
          },
          {
            "path": "crates/ty_server/src/server/schedule.rs",
            "description": "This file defines the scheduling mechanism for the `ty_server`, including spawning the main event loop thread and managing thread pools for dispatching synchronous and background tasks based on their priority and type.",
            "spof": true
          },
          {
            "path": "crates/ty_server/src/server/main_loop.rs",
            "description": "This file implements the main event loop for the Language Server Protocol (LSP) server, handling incoming client messages, internal server actions, and dispatching tasks to a scheduler for processing.",
            "spof": false
          },
          {
            "path": "crates/ty_server/src/server/api.rs",
            "description": "This file serves as the primary entry point for processing Language Server Protocol (LSP) requests and notifications, dispatching them to specific handlers within the `ruff` type server. It routes incoming LSP messages based on their method to execute corresponding synchronous or background tasks.",
            "spof": false
          },
          {
            "path": "crates/ty_server/src/server/lazy_work_done_progress.rs",
            "description": "This file implements `LazyWorkDoneProgress`, a mechanism for reporting work-done progress in a Language Server Protocol (LSP) server. It dynamically handles whether the progress is initiated by the client or the server, sending appropriate progress notifications throughout an operation's lifecycle.",
            "spof": true
          },
          {
            "path": "crates/ty_server/src/server/api/traits.rs",
            "description": "This module defines trait abstractions for handling incoming Language Server Protocol (LSP) requests and notifications from clients. It provides a type-safe way to implement LSP handlers with different execution models (synchronous or asynchronous) and automatic retry capabilities.",
            "spof": false
          },
          {
            "path": "crates/ty_server/src/server/api/notifications.rs",
            "description": "This file serves as an aggregation point for various notification handlers within a Language Server Protocol (LSP) server, particularly for document and notebook lifecycle events, workspace folder changes, and cancellation requests.",
            "spof": false
          },
          {
            "path": "crates/ty_server/src/server/api/requests.rs",
            "description": "This file aggregates and re-exports various Language Server Protocol (LSP) request handlers and related types implemented within the `ty_server` crate. It serves as a central point for making these API handlers accessible.",
            "spof": false
          },
          {
            "path": "crates/ty_server/src/server/api/notifications/cancel.rs",
            "description": "Handles Language Server Protocol (LSP) 'cancel' notifications, allowing a client to cancel a pending request within the server's session.",
            "spof": true
          },
          {
            "path": "crates/ty_server/src/server/api/notifications/did_change.rs",
            "description": "This file implements the handler for the `textDocument/didChange` LSP notification. It updates the server's internal representation of a text document based on client-sent content changes and then triggers diagnostic publishing for that document.",
            "spof": true
          },
          {
            "path": "crates/ty_server/src/server/api/notifications/did_open_notebook.rs",
            "description": "This file implements the handler for the `didOpenNotebookDocument` LSP notification, processing an opened notebook document and its cells by registering them within the language server session and then publishing diagnostics.",
            "spof": true
          },
          {
            "path": "crates/ty_server/src/server/api/notifications/did_close_notebook.rs",
            "description": "Handles the `didCloseNotebookDocument` LSP notification, closing a notebook document within the language server's session.",
            "spof": true
          },
          {
            "path": "crates/ty_server/src/server/api/notifications/did_open.rs",
            "description": "Handles the Language Server Protocol's `textDocument/didOpen` notification, registering the opened document with the server session and publishing initial diagnostics.",
            "spof": false
          },
          {
            "path": "crates/ty_server/src/server/api/notifications/did_change_watched_files.rs",
            "description": "This file implements the LSP `didChangeWatchedFiles` notification, processing file system changes reported by the client, updating the server's internal project state, and triggering subsequent diagnostics and client refreshes.",
            "spof": true
          },
          {
            "path": "crates/ty_server/src/server/api/notifications/did_change_notebook.rs",
            "description": "This file implements the Language Server Protocol (LSP) `textDocument/didChangeNotebookDocument` notification handler. It updates the server's internal representation of a notebook document based on client changes and publishes diagnostics for it.",
            "spof": true
          },
          {
            "path": "crates/ty_server/src/server/api/notifications/did_close.rs",
            "description": "This file implements the handler for the LSP 'textDocument/didClose' notification, signaling that a document has been closed by the client. It updates the server's internal state for the document and clears any associated diagnostics.",
            "spof": false
          },
          {
            "path": "crates/ty_server/src/server/api/notifications/did_change_workspace_folders.rs",
            "description": "This file handles Language Server Protocol (LSP) notifications for changes to workspace folders, specifically adding and removing folders and updating the server's session state accordingly.",
            "spof": true
          },
          {
            "path": "crates/ty_server/src/server/api/requests/workspace_symbols.rs",
            "description": "This file implements the request handler for the LSP `workspace/symbol` request, allowing clients to search for symbols across all projects in the workspace. It retrieves workspace symbols, converts them to LSP format, and returns the results.",
            "spof": false
          },
          {
            "path": "crates/ty_server/src/server/api/requests/execute_command.rs",
            "description": "This file implements the LSP `executeCommand` request, specifically for a 'debug' command that provides detailed diagnostic information, including server capabilities, settings, workspace details, and memory usage, about the current session.",
            "spof": true
          },
          {
            "path": "crates/ty_server/src/server/api/requests/shutdown.rs",
            "description": "This file defines the `ShutdownHandler` responsible for processing the Language Server Protocol (LSP) 'shutdown' request. It handles cleanup tasks such as responding to pending diagnostic requests, setting a shutdown flag, and triggering cancellation for all active projects before the server exits.",
            "spof": true
          },
          {
            "path": "crates/ty_server/src/server/api/requests/diagnostic.rs",
            "description": "This file implements a Language Server Protocol (LSP) request handler for document diagnostics. It computes and returns diagnostic reports for a given document, supporting both full and incremental updates.",
            "spof": false
          },
          {
            "path": "crates/ty_server/src/server/api/requests/workspace_diagnostic.rs",
            "description": "Handles Language Server Protocol (LSP) workspace diagnostic requests, providing efficient and incremental reporting of diagnostics across the entire workspace using techniques like partial results, result IDs, and long polling.",
            "spof": true
          },
          {
            "path": "crates/ty_server/src/server/api/requests/document_symbols.rs",
            "description": "This file implements the Language Server Protocol (LSP) `DocumentSymbolRequest`, retrieving a document's symbols and converting them into a hierarchical or flat LSP response based on client capabilities.",
            "spof": false
          },
          {
            "path": "crates/ty_server/src/server/schedule/task.rs",
            "description": "This file defines the `Task` enum and related structures for scheduling and executing operations within a server, distinguishing between synchronous tasks that modify the session and asynchronous background tasks that run on different priority threads.",
            "spof": true
          },
          {
            "path": "crates/ty_server/src/session/options.rs",
            "description": "This file defines the data structures for managing initialization and runtime configuration options for the Ruff language server, including global settings and workspace-specific settings received from a Language Server Protocol (LSP) client.",
            "spof": false
          },
          {
            "path": "crates/ty_server/src/session/request_queue.rs",
            "description": "Manages the lifecycle of requests and responses between an LSP client and server, including tracking pending requests, handling cancellations, and associating response handlers.",
            "spof": true
          },
          {
            "path": "crates/ty_server/src/session/index.rs",
            "description": "This file defines the `Index` struct, which is responsible for storing, tracking, and managing all open text and notebook documents within a language server session.",
            "spof": true
          },
          {
            "path": "crates/ty_server/src/session/client.rs",
            "description": "This file defines the `Client` struct, which manages communication with the Language Server Protocol (LSP) client. It provides methods for sending requests, notifications, responses, and handling cancellations.",
            "spof": true
          },
          {
            "path": "crates/ty_server/src/session/settings.rs",
            "description": "This file defines data structures for global and workspace-specific client settings used by a language server, configuring features like diagnostics, experimental options, inlay hints, and completions.",
            "spof": false
          },
          {
            "path": "crates/ty_server/src/document/text_document.rs",
            "description": "This file defines the `TextDocument` struct, which manages the content and state of a single text document within a Language Server Protocol (LSP) server. It includes functionality to apply incremental content changes received from an LSP client.",
            "spof": true
          },
          {
            "path": "crates/ty_server/src/document/range.rs",
            "description": "This file defines utility structs and traits for converting between Language Server Protocol (LSP) range/position types and internal text range/size types, particularly handling complex mappings in notebook files.",
            "spof": true
          },
          {
            "path": "crates/ty_server/src/document/notebook.rs",
            "description": "This file defines the `NotebookDocument` and `NotebookCell` structures for representing Jupyter notebooks within the Language Server Protocol (LSP) server, managing their metadata and providing conversion to Ruff's internal notebook format.",
            "spof": true
          },
          {
            "path": "crates/ty_server/tests/e2e/commands.rs",
            "description": "This file contains end-to-end tests for executing LSP commands against a `TestServer`, specifically demonstrating how to send and assert responses for debug commands.",
            "spof": true
          },
          {
            "path": "crates/ty_server/tests/e2e/initialize.rs",
            "description": "This file contains end-to-end tests for the `ty_server`'s Language Server Protocol (LSP) initialization logic. It verifies server behavior regarding workspace folders, diagnostic registration capabilities, and disabling language services based on client options.",
            "spof": false
          },
          {
            "path": "crates/ty_server/tests/e2e/main.rs",
            "description": "This module provides a mock server infrastructure for testing LSP (Language Server Protocol) functionality of the 'ty' language server. It allows for configuring, building, and interacting with a test server to send requests and await responses for LSP-related tests.",
            "spof": false
          },
          {
            "path": "crates/ty_server/tests/e2e/notebook.rs",
            "description": "This file contains end-to-end tests for the Language Server Protocol (LSP) server's functionality related to Jupyter notebooks. It tests features like diagnostics, semantic tokens, cell manipulation, and auto-import within a notebook environment.",
            "spof": true
          },
          {
            "path": "crates/ty_server/tests/e2e/workspace_folders.rs",
            "description": "This file contains end-to-end tests for the Rust Language Server Protocol (LSP) implementation, specifically focusing on how the server handles multiple workspace folders. It tests initialization, adding, and removing workspace folders, and verifies the diagnostic reports in these scenarios.",
            "spof": true
          },
          {
            "path": "crates/ty_server/tests/e2e/code_actions.rs",
            "description": "This file contains end-to-end tests for the `ty_server`'s code action functionality, simulating LSP client-server interactions to verify code action suggestions for various diagnostics.",
            "spof": false
          },
          {
            "path": "crates/ty_server/tests/e2e/configuration.rs",
            "description": "This file contains end-to-end tests for the `ty_server`'s configuration loading and overriding mechanisms. It verifies how the server processes valid and invalid configuration files, as well as programmatic configuration overrides, to influence diagnostic reporting.",
            "spof": true
          },
          {
            "path": "crates/ty_server/tests/e2e/publish_diagnostics.rs",
            "description": "This file contains end-to-end tests for the `ty_server`'s ability to publish Language Server Protocol (LSP) diagnostics, covering scenarios like file open, change, watched file changes, and various client configurations.",
            "spof": true
          },
          {
            "path": "crates/ty_server/tests/e2e/pull_diagnostics.rs",
            "description": "This file contains end-to-end tests for the Language Server Protocol (LSP) server's pull diagnostics feature. It verifies how the server generates and manages diagnostics for documents and workspaces under various conditions, including caching and configuration changes.",
            "spof": true
          },
          {
            "path": "crates/ty_server/tests/e2e/snapshots",
            "description": "This directory stores reference snapshot files for end-to-end tests of the `ty_server` crate within the `ruff` project. These snapshots are used to assert the expected output or behavior of the server against actual test runs, helping to detect regressions. Given it's empty, it likely serves as a placeholder or is populated dynamically during test execution.",
            "spof": false
          }
        ],
        "contributors": [
          {
            "name": "Micha Reiser",
            "percent": 59
          },
          {
            "name": "Dhruv Manilawala",
            "percent": 18
          },
          {
            "name": "Andrew Gallant",
            "percent": 13
          }
        ]
      },
      "Real-time Linting & Formatting": {
        "files": [
          {
            "path": "crates/ruff_annotate_snippets/tests/fixtures/color",
            "description": "This directory is designated for storing test fixtures related to color processing or rendering within the `ruff_annotate_snippets` crate. Although currently empty, it is intended to house example data or configurations for testing color-related functionalities.",
            "spof": false
          },
          {
            "path": "crates/ruff_annotate_snippets/src/renderer/styled_buffer.rs",
            "description": "This file defines a `StyledBuffer` struct that stores characters along with their display styles and provides methods to manipulate and render this styled text into a formatted string, typically for terminal output.",
            "spof": true
          },
          {
            "path": "crates/ruff_server/src/format.rs",
            "description": "This file provides functionality for formatting Python code within the Ruff LSP server, supporting both full document and range formatting using either an internal Ruff formatter or an external 'uv' command-line tool.",
            "spof": true
          },
          {
            "path": "crates/ruff_server/src/fix.rs",
            "description": "This file provides functionality to apply all linter fixes to a given document or notebook, generating a set of LSP-compatible text edits that represent the changes made by the fixer.",
            "spof": false
          },
          {
            "path": "crates/ruff_server/src/lint.rs",
            "description": "This file provides the core logic for integrating Ruff's linting capabilities into an Language Server Protocol (LSP) server, converting Ruff diagnostics and fixes into LSP-compatible formats.",
            "spof": false
          },
          {
            "path": "crates/ruff_server/src/server/api/diagnostics.rs",
            "description": "This file handles the generation, publishing, and clearing of linting diagnostics for documents within the Ruff Language Server Protocol (LSP) server, based on client settings.",
            "spof": false
          },
          {
            "path": "crates/ruff_server/src/server/api/requests.rs",
            "description": "This file serves as a central module for defining and exporting various Language Server Protocol (LSP) request handlers for the Ruff server, such as code actions, diagnostics, formatting, and hover requests.",
            "spof": false
          },
          {
            "path": "crates/ruff_server/src/server/api/requests/diagnostic.rs",
            "description": "This file handles Language Server Protocol (LSP) requests for document diagnostics. It generates and returns diagnostic reports (e.g., linting errors, warnings) for a given document snapshot using the `generate_diagnostics` function.",
            "spof": true
          },
          {
            "path": "crates/ruff_server/src/server/api/requests/format.rs",
            "description": "This file implements the server-side logic for handling document formatting requests in the Ruff LSP server. It provides functions to format entire documents or individual notebook cells, generating text edits based on the formatting results.",
            "spof": false
          },
          {
            "path": "crates/ruff_server/src/server/api/requests/format_range.rs",
            "description": "This file handles Language Server Protocol (LSP) range formatting requests, applying Ruff's formatting logic to a specified text range within a document. It translates LSP ranges to internal text ranges, formats the code, and returns the necessary text edits.",
            "spof": false
          },
          {
            "path": "crates/ruff_server/src/server/api/requests/hover.rs",
            "description": "This file implements the Language Server Protocol (LSP) hover request handler for the Ruff Language Server, providing detailed information about Ruff rules when hovering over rule codes within `noqa` comments.",
            "spof": false
          },
          {
            "path": "crates/ruff_server/src/server/api/requests/code_action.rs",
            "description": "This file implements the Language Server Protocol (LSP) `textDocument/codeAction` request handler for the Ruff server. It generates and provides various code actions, such as quick fixes, 'fix all' actions, and 'organize imports', to the client.",
            "spof": true
          },
          {
            "path": "crates/ruff_server/src/server/api/requests/code_action_resolve.rs",
            "description": "This file handles the Language Server Protocol's `codeAction/resolve` request, which generates and returns the workspace edits for specific code actions like 'fix all' or 'organize imports'.",
            "spof": false
          },
          {
            "path": "crates/ruff_server/src/edit/replacement.rs",
            "description": "This file defines a `Replacement` struct and associated logic to identify the minimal contiguous text ranges in a 'source' string and a 'modified' string that, when the source range is replaced by the modified range, transform the source into the modified string. It effectively calculates the differing segment between two strings after finding common prefixes and suffixes.",
            "spof": true
          },
          {
            "path": "crates/ruff_db/src/diagnostic/render/full.rs",
            "description": "This file provides the `FullRenderer` responsible for formatting and displaying Ruff diagnostics, including detailed code snippets and associated code fix diffs. It handles styling, notebook cell rendering, and applicability notes for fixes.",
            "spof": true
          },
          {
            "path": "crates/ty_ide/src/importer.rs",
            "description": "This file provides an abstraction for managing and inserting Python import statements into a single source file, primarily used for tasks like auto-completion in the `ty` semantic model. It analyzes existing imports and generates new ones, handling potential conflicts and formatting.",
            "spof": true
          },
          {
            "path": "crates/ty_ide/src/code_action.rs",
            "description": "This file implements code actions (quick fixes) for diagnostics in Python code, providing suggestions for resolving undefined references and options to suppress specific lint warnings.",
            "spof": false
          },
          {
            "path": "crates/ty_server/src/server/api/diagnostics.rs",
            "description": "This file manages and publishes diagnostic information (e.g., linting errors, warnings) from the Rust analysis engine to an LSP client, converting internal diagnostic formats to LSP-compatible messages and handling both text and notebook documents.",
            "spof": false
          },
          {
            "path": "crates/ty_server/src/server/api/requests/code_action.rs",
            "description": "This file implements the Language Server Protocol (LSP) `textDocument/codeAction` request, generating code actions and quick fixes based on diagnostics and specific code ranges within a document.",
            "spof": false
          }
        ],
        "contributors": [
          {
            "name": "Andrew Gallant",
            "percent": 26
          },
          {
            "name": "Micha Reiser",
            "percent": 22
          },
          {
            "name": "Brent Westbrook",
            "percent": 17
          }
        ]
      },
      "Semantic Code Intelligence": {
        "files": [
          {
            "path": "crates/ty_python_semantic/resources/mdtest/ide_support/all_members.md",
            "description": "This file contains a test suite for the `ide_support::all_members` routine, which lists all members available on a given type. It's used to verify the functionality of autocomplete suggestions in an IDE.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/src/types/ide_support.rs",
            "description": "This file provides utility functions for resolving definitions of Python names and attributes within a semantic model, primarily to support IDE features like 'go to definition' and semantic tokens.",
            "spof": false
          },
          {
            "path": "crates/ty_completion_eval/truth/README.md",
            "description": "This README.md file describes the purpose of the directory, which contains truth data for ty's completion evaluation, and provides instructions on how to add new truth data.",
            "spof": true
          },
          {
            "path": "crates/ty_completion_eval/truth/auto-import-skips-current-module/main.py",
            "description": "This file is a test case to ensure that auto-import functionality does not suggest importing an object that already exists within the current module. It highlights a previously fixed bug where `Kadabra` would be suggested for import from `main` even when defined locally.",
            "spof": true
          },
          {
            "path": "crates/ty_completion_eval/truth/import-keyword-completion/main.py",
            "description": "This file appears to be a test case for import keyword completion, demonstrating an incomplete import statement from the 'collections' module.",
            "spof": true
          },
          {
            "path": "crates/ty_completion_eval/truth/pass-keyword-completion/main.py",
            "description": "This file is a test case for type completion evaluation in the `ruff` project, demonstrating keyword completion for `pass` within a `match` statement's case block.",
            "spof": true
          },
          {
            "path": "crates/ty_completion_eval/truth/class-arg-completion/main.py",
            "description": "This file appears to be a test case for type completion evaluation within a language server, specifically demonstrating class argument completion for `metaclass` and `NotImplementedError`.",
            "spof": true
          },
          {
            "path": "crates/ty_completion_eval/truth/numpy-array/main.py",
            "description": "Tests autocompletion for 'numpy.array', highlighting discrepancies in symbol discovery between direct module access and imported aliases, particularly concerning auto-import suggestions.",
            "spof": true
          },
          {
            "path": "crates/ty_completion_eval/truth/local-over-auto-import/main.py",
            "description": "This file tests completion suggestions, specifically ensuring that local variables are prioritized over potential auto-imports or keywords with similar names.",
            "spof": true
          },
          {
            "path": "crates/ty_completion_eval/truth/auto-import-includes-modules/main.py",
            "description": "This file serves as a test case or example for auto-completion or auto-import functionality, demonstrating how partial module names are expanded to their full paths (e.g., 'multiprocess' to 'multiprocessing').",
            "spof": true
          },
          {
            "path": "crates/ty_completion_eval/truth/scope-prioritize-closer/main.py",
            "description": "This file defines a global variable and a local variable within a function. It serves as a test case for analyzing how identifier completion prioritizes closer, local scopes.",
            "spof": true
          },
          {
            "path": "crates/ty_completion_eval/truth/raise-uses-base-exception/main.py",
            "description": "This file contains examples of `raise` statements and `except` blocks using `NotImplementedError`, likely serving as a test case for type completion or inference in an IDE/linter.",
            "spof": true
          },
          {
            "path": "crates/ty_completion_eval/truth/fstring-completions/main.py",
            "description": "This file serves as a test case for f-string autocompletion. It verifies that a local variable is correctly suggested within an f-string expression.",
            "spof": true
          },
          {
            "path": "crates/ty_completion_eval/truth/exact-over-fuzzy/main.py",
            "description": "This file is likely a test case for `ruff`'s type completion evaluation, specifically demonstrating exact-over-fuzzy matching for variable names.",
            "spof": true
          },
          {
            "path": "crates/ty_completion_eval/truth/scope-existing-over-new-import/main.py",
            "description": "This file is a test case for type completion, specifically evaluating how an existing import ('Iterator') is prioritized over a newly typed, incomplete symbol ('Iter'). It demonstrates a scenario where the type completion system should suggest the already imported type.",
            "spof": true
          },
          {
            "path": "crates/ty_completion_eval/truth/internal-typeshed-hidden/main.py",
            "description": "This file serves as a test case for evaluating type completion ranking, specifically demonstrating a scenario where an internal module's symbol might be incorrectly prioritized over a standard `typing` module symbol. It aims to capture deficiencies in completion suggestion ranking.",
            "spof": true
          },
          {
            "path": "crates/ty_ide/src/docstring.rs",
            "description": "This file provides utilities for parsing, extracting information from, and rendering Python docstrings for language server features, supporting Google-style, NumPy-style, and reST/Sphinx-style formats.",
            "spof": true
          },
          {
            "path": "crates/ty_ide/src/doc_highlights.rs",
            "description": "This file provides functionality to find all document highlights for a given symbol within the current file, such as occurrences of variables, parameters, and class names. It leverages semantic model analysis to identify definitions and references.",
            "spof": true
          },
          {
            "path": "crates/ty_ide/src/references.rs",
            "description": "This module implements semantic search for symbol references, document highlights, and rename operations, locating all occurrences of a named symbol across a project or within a single file.",
            "spof": true
          },
          {
            "path": "crates/ty_ide/src/workspace_symbols.rs",
            "description": "This file provides functionality to search for symbols across all files in a workspace, filtering them by a given query string. It defines the `workspace_symbols` function and the `WorkspaceSymbolInfo` struct to represent found symbols and their file locations.",
            "spof": false
          },
          {
            "path": "crates/ty_ide/src/stub_mapping.rs",
            "description": "This file defines a `StubMapper` that facilitates mapping Python definitions from stub files (`.pyi`) to their actual implementations in source files (`.py`). This is crucial for IDE features like \"Go To Definition\" and retrieving documentation from source files.",
            "spof": false
          },
          {
            "path": "crates/ty_ide/src/find_references.rs",
            "description": "This file implements the \"find all references\" feature for a symbol in a Python project, locating all usages across relevant files. It leverages semantic analysis to identify the symbol's definition and then finds its references.",
            "spof": true
          },
          {
            "path": "crates/ty_ide/src/goto_definition.rs",
            "description": "Implements the 'go to definition' functionality for Python symbols within the Ruff IDE. It locates the actual implementation of a symbol, prioritizing `.py` source files over `.pyi` stub files.",
            "spof": false
          },
          {
            "path": "crates/ty_ide/src/signature_help.rs",
            "description": "This module implements the 'signature help' feature for a language server, providing information about function call signatures, parameters, and documentation to assist users with arguments.",
            "spof": false
          },
          {
            "path": "crates/ty_ide/src/hover.rs",
            "description": "This file implements the logic for providing hover information (type signatures, inferred types, and docstrings) for Python code elements at a specific cursor position, typically for an IDE or language server.",
            "spof": false
          },
          {
            "path": "crates/ty_ide/src/goto_type_definition.rs",
            "description": "This file implements the 'Go To Type Definition' functionality for a Python IDE, allowing navigation from a symbol's usage to its inferred type definition. It handles various scenarios like classes, functions, imports, and typing module elements.",
            "spof": false
          },
          {
            "path": "crates/ty_ide/src/rename.rs",
            "description": "This file implements the core logic for renaming symbols in Python source code, including determining if a symbol can be renamed and identifying all its occurrences across single or multiple files within a project.",
            "spof": false
          },
          {
            "path": "crates/ty_ide/src/symbols.rs",
            "description": "This file implements the core logic and data structures for identifying, organizing, and querying symbols within a Python file, supporting IDE features such as document symbol providers, workspace symbol providers, and auto-import completion.",
            "spof": true
          },
          {
            "path": "crates/ty_ide/src/all_symbols.rs",
            "description": "This file contains logic to collect and process all accessible symbols within a project and its dependencies, filtering them by a query and merging re-exported symbols for display.",
            "spof": true
          },
          {
            "path": "crates/ty_ide/src/document_symbols.rs",
            "description": "This file provides the core functionality for extracting and listing document symbols (e.g., functions, classes, variables) from a given file. It also includes extensive tests to verify the accurate extraction of these symbols for IDE features.",
            "spof": true
          },
          {
            "path": "crates/ty_ide/src/selection_range.rs",
            "description": "This file provides the `selection_range` function, which determines a list of nested semantic text ranges in a Python file that progressively expand around a given cursor position. It's designed to support IDE features like \"expand selection\" by identifying meaningful AST nodes.",
            "spof": false
          },
          {
            "path": "crates/ty_ide/src/completion.rs",
            "description": "This file implements the core logic for providing code completion suggestions within the Ruff type-checking IDE, handling various contexts like imports, object attributes, and scoped symbols.",
            "spof": false
          },
          {
            "path": "crates/ty_ide/src/goto_declaration.rs",
            "description": "This file implements the 'go to declaration' functionality for Python code, locating the definition or assignment site of a symbol. It supports various symbol types including functions, variables, classes, parameters, and imports.",
            "spof": false
          },
          {
            "path": "crates/ty_ide/src/goto.rs",
            "description": "This file defines the various types of targets for \"go to\" navigation features (like go-to-definition, go-to-declaration) in a Python codebase, and provides mechanisms for resolving their definitions and retrieving docstrings.",
            "spof": false
          },
          {
            "path": "crates/ty_ide/src/inlay_hints.rs",
            "description": "This file defines and implements the logic for generating various inlay hints (e.g., variable types, call argument names) for Python code within the Ruff IDE type analysis crate. It includes data structures for hints, visitor logic for AST traversal, and configuration settings.",
            "spof": false
          },
          {
            "path": "crates/ty_ide/src/semantic_tokens.rs",
            "description": "This module walks the AST of a Python file to collect semantic tokens, including their types and modifiers, for use by editors to provide advanced color coding and semantic highlighting. It defines token types and modifiers, and implements a visitor pattern to extract this information.",
            "spof": false
          },
          {
            "path": "crates/ty_ide/src/lib.rs",
            "description": "This file serves as the main library for IDE-related features within the `ruff` type analysis system, providing core functionalities like code actions, completions, symbol lookup, navigation (go-to definition/declaration), and semantic tokens. It defines common data structures and traits for representing code locations, references, and navigation targets for language server capabilities.",
            "spof": false
          },
          {
            "path": "crates/ty_server/src/server/api/symbols.rs",
            "description": "This file provides utility functions for converting internal symbol information (from `ty_ide`) into Language Server Protocol (LSP) `SymbolKind` and `SymbolInformation` formats. It facilitates handling symbol-related requests in a language server.",
            "spof": false
          },
          {
            "path": "crates/ty_server/src/server/api/semantic_tokens.rs",
            "description": "This file contains the core logic for converting internal semantic token information into LSP-compliant `SemanticToken` structures, handling position encoding, multiline token support, and delta encoding for efficient transmission.",
            "spof": true
          },
          {
            "path": "crates/ty_server/src/server/api/requests/rename.rs",
            "description": "This file implements the LSP `rename` request for the `ty_server`, providing functionality to rename symbols within the workspace. It retrieves rename results from `ty_ide` and formats them into a `WorkspaceEdit`.",
            "spof": true
          },
          {
            "path": "crates/ty_server/src/server/api/requests/semantic_tokens.rs",
            "description": "Handles Language Server Protocol (LSP) semantic token requests, generating semantic tokens for a given document or notebook cell.",
            "spof": false
          },
          {
            "path": "crates/ty_server/src/server/api/requests/inlay_hints.rs",
            "description": "This file implements the LSP `InlayHintRequest` handler, which retrieves and formats inlay hints for a given document range. It processes the request, fetches hints from the type server, and converts them into the `lsp_types::InlayHint` format for the client.",
            "spof": false
          },
          {
            "path": "crates/ty_server/src/server/api/requests/doc_highlights.rs",
            "description": "This file implements the Language Server Protocol (LSP) document highlight request handler for the `ty_server`. It identifies and returns all occurrences of a symbol at a given position within a document, categorizing them as reads, writes, or other references.",
            "spof": false
          },
          {
            "path": "crates/ty_server/src/server/api/requests/completion.rs",
            "description": "This file implements the Language Server Protocol (LSP) completion request handler, generating and formatting code completion suggestions based on the project's type information.",
            "spof": false
          },
          {
            "path": "crates/ty_server/src/server/api/requests/selection_range.rs",
            "description": "This file implements the Language Server Protocol's `textDocument/selectionRange` request, computing selection ranges for given positions within a document. It translates LSP requests into internal type-server operations and converts results back into LSP-compatible selection ranges.",
            "spof": false
          },
          {
            "path": "crates/ty_server/src/server/api/requests/hover.rs",
            "description": "This file implements the Language Server Protocol (LSP) hover request handler, retrieving and formatting hover information for a given code position in a document. It queries the project database for hover details and converts them into an LSP-compatible `Hover` response.",
            "spof": true
          },
          {
            "path": "crates/ty_server/src/server/api/requests/semantic_tokens_range.rs",
            "description": "This file implements a request handler for the Language Server Protocol's `textDocument/semanticTokens/range` request, providing semantic tokens for a specific range within a document. It generates and returns semantic tokens based on the provided range and document snapshot.",
            "spof": false
          },
          {
            "path": "crates/ty_server/src/server/api/requests/references.rs",
            "description": "This file defines the `ReferencesRequestHandler` which processes Language Server Protocol (LSP) requests to find all references to a symbol within the workspace. It utilizes the `ty_ide` crate to locate references and converts them into LSP `Location` objects.",
            "spof": true
          },
          {
            "path": "crates/ty_server/src/server/api/requests/goto_declaration.rs",
            "description": "Implements the Language Server Protocol (LSP) 'go to declaration' request, finding the declaration of a symbol at a specific position in a document and returning it as a location or link.",
            "spof": false
          },
          {
            "path": "crates/ty_server/src/server/api/requests/goto_definition.rs",
            "description": "This file implements the Language Server Protocol (LSP) 'go to definition' request, finding the definition of a symbol at a given position within a document and returning the corresponding location(s).",
            "spof": false
          },
          {
            "path": "crates/ty_server/src/server/api/requests/goto_type_definition.rs",
            "description": "This file implements the Language Server Protocol (LSP) 'Go to Type Definition' request, which allows clients to find the type definition of a symbol within a document. It retrieves the type definition and formats the response according to client capabilities.",
            "spof": false
          },
          {
            "path": "crates/ty_server/src/server/api/requests/signature_help.rs",
            "description": "This file implements the Language Server Protocol (LSP) handler for signature help requests. It retrieves signature information for a given position in a document and converts it into LSP-compatible `SignatureHelp` format, considering client capabilities and position encoding.",
            "spof": false
          },
          {
            "path": "crates/ty_server/src/server/api/requests/prepare_rename.rs",
            "description": "This file implements the Language Server Protocol (LSP) 'prepare rename' request, which determines if a rename operation is valid at a given text position and, if so, returns the text range to be renamed.",
            "spof": false
          },
          {
            "path": "crates/ty_server/src/document/location.rs",
            "description": "This file defines a trait `ToLink` for converting internal code navigation and reference targets into Language Server Protocol (LSP) `Location` and `LocationLink` objects, facilitating IDE features like 'Go to Definition' or 'Find References'.",
            "spof": true
          },
          {
            "path": "crates/ty_server/tests/e2e/rename.rs",
            "description": "This file contains end-to-end tests for the rename functionality of the type server (ty_server), covering both standard Python files and Python code within notebooks.",
            "spof": true
          },
          {
            "path": "crates/ty_server/tests/e2e/signature_help.rs",
            "description": "This file contains an end-to-end test for the type server's signature help LSP feature. It specifically verifies that signature help works correctly when the cursor is positioned on a function name.",
            "spof": true
          },
          {
            "path": "crates/ty_server/tests/e2e/inlay_hints.rs",
            "description": "This file contains end-to-end tests for the language server's inlay hints feature. It verifies default behavior and specific settings for disabling variable type inlay hints.",
            "spof": false
          },
          {
            "path": "crates/ty_server/tests/e2e/completions.rs",
            "description": "This file provides end-to-end tests for the `ty_server`'s completion feature, verifying auto-import functionality (default, disabled, qualification display) and correct function parameter suggestions.",
            "spof": true
          },
          {
            "path": "crates/ty_server/tests/e2e/semantic_tokens.rs",
            "description": "This file contains end-to-end tests for the type server's semantic token generation. It verifies the server's behavior regarding multiline token support for clients and ensures semantic tokens are correctly updated after document changes.",
            "spof": true
          }
        ],
        "contributors": [
          {
            "name": "Aria Desires",
            "percent": 25
          },
          {
            "name": "Andrew Gallant",
            "percent": 22
          },
          {
            "name": "Micha Reiser",
            "percent": 16
          }
        ]
      }
    },
    "stats": {
      "totalFiles": 183,
      "spofCount": 88
    },
    "busFactor": 3,
    "authorCount": 17
  },
  "Python Code Analysis Engine": {
    "description": "The foundational engine that parses Python source code into a structured representation (Abstract Syntax Tree) and builds a semantic model. This core component enables all other analysis features like linting, formatting, and type checking.",
    "functions": {
      "Core Analysis Framework": {
        "files": [
          {
            "path": "docs/installation.md",
            "description": "This file provides comprehensive instructions on how to install the Ruff linter and formatter using various package managers, standalone installers, and Docker.",
            "spof": false
          },
          {
            "path": "crates/ty/src/python_version.rs",
            "description": "This file defines a Rust enum `PythonVersion` to represent supported Python versions, providing methods for string conversion, display formatting, and conversion to the `ruff_python_ast::PythonVersion` type.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_ast_integration_tests/README.md",
            "description": "This file is a README for the `ruff_python_ast_integration_tests` crate. It explains that this crate contains integration tests for `ruff_python_ast` to avoid circular dependencies during development.",
            "spof": true
          },
          {
            "path": "crates/ruff/src/lib.rs",
            "description": "This `lib.rs` file serves as the main entry point for the `ruff` application, handling command-line argument parsing and dispatching various commands such as `check`, `format`, `server`, and `analyze`. It orchestrates the overall execution flow for linting, formatting, and analysis tasks.",
            "spof": false
          },
          {
            "path": "crates/ruff/tests/direxist_guard.rs",
            "description": "This file contains a test to verify Ruff's behavior and error handling when executed from a directory that has been deleted, ensuring it reports the working directory as non-existent.",
            "spof": false
          },
          {
            "path": "crates/ruff/tests/cli/main.rs",
            "description": "This file provides a test fixture (`CliTest`) for Ruff's command-line interface (CLI) tests, handling temporary directory creation, file management, and pre-configuring `ruff` commands for consistent and isolated testing.",
            "spof": true
          },
          {
            "path": "crates/ruff/tests/cli/snapshots",
            "description": "This directory stores snapshot files for CLI tests within the `ruff` crate. These snapshots are used to compare the actual output of CLI commands against expected output, ensuring consistent behavior and detecting regressions.",
            "spof": false
          },
          {
            "path": "crates/ruff_dev/src/main.rs",
            "description": "This file serves as the main entry point for an internal CLI tool for Ruff developers. It provides various utilities for code generation, documentation, and analysis of Ruff's internal components like ASTs, CSTs, and tokens.",
            "spof": false
          },
          {
            "path": "crates/ruff_annotate_snippets/examples/multislice.rs",
            "description": "This file is an example demonstrating the `ruff_annotate_snippets` library, specifically showing how to create and render an error message with multiple code snippets (slices) from different origins.",
            "spof": true
          },
          {
            "path": "crates/ruff_annotate_snippets/src/snippet.rs",
            "description": "This file defines the core data structures (`Message`, `Snippet`, `Annotation`, `Level`) used for representing and building diagnostic messages and code snippets with annotations for the `ruff_annotate_snippets` library.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/mdtest.py",
            "description": "This Python script serves as a runner for Markdown-based tests within the `ty` project, enabling compilation, execution, and live-reloading of tests based on file changes in Rust, Python, and Markdown source code.",
            "spof": true
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/regression/14334_diagnostics_in_wrong_file.md",
            "description": "This file is a regression test for issue #14334, verifying that diagnostics for an error in one Python file (`base.py`) are not incorrectly reported in another file (`a.py`) that imports it.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/src/diagnostic.rs",
            "description": "This file provides utilities for creating, managing, and enhancing diagnostic messages within the `ty_python_semantic` crate, including functions for suggesting corrections, explaining inferred Python versions, and ensuring diagnostic consistency.",
            "spof": true
          },
          {
            "path": "crates/ty_python_semantic/src/program.rs",
            "description": "This file defines the `Program` struct, which stores and manages global program settings like the Python version, platform, and module search paths within a Salsa database for a semantic analysis or type checking tool.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/src/db.rs",
            "description": "This file defines the `Db` trait, which provides an interface for accessing semantic information about a Python program, and includes a test-specific implementation (`TestDb`) for use in unit tests.",
            "spof": true
          },
          {
            "path": "crates/ruff_db/src/cancellation.rs",
            "description": "This file provides mechanisms for cooperative cancellation of operations, defining a `CancellationTokenSource` to initiate cancellation and `CancellationToken` to check for cancellation requests.",
            "spof": true
          },
          {
            "path": "crates/ruff_db/src/testing.rs",
            "description": "Provides test helpers for working with Salsa databases, including functions to assert whether specific queries were executed and utilities for setting up logging during tests.",
            "spof": true
          },
          {
            "path": "crates/ruff_db/src/file_revision.rs",
            "description": "This file defines the `FileRevision` struct, a `u128` wrapper used to represent a file's revision for change detection, convertible from file modification times or other numerical values.",
            "spof": false
          },
          {
            "path": "crates/ruff_db/src/panic.rs",
            "description": "This file implements a custom panic handling mechanism that captures detailed information (including location, standard backtraces, and Salsa-specific backtraces) when a closure panics. It extends `std::panic::catch_unwind` to provide richer error reporting for panics within the application.",
            "spof": false
          },
          {
            "path": "crates/ruff_db/src/files.rs",
            "description": "This file defines the `Files` struct and associated functions responsible for managing and tracking file system paths (system, vendored, virtual) as `salsa` ingredients within the Ruff database, including their status, metadata, and roots.",
            "spof": true
          },
          {
            "path": "crates/ruff_db/src/lib.rs",
            "description": "This file defines the core `Db` trait, which serves as the central database interface for Ruff, providing access to file systems, system resources, and parsed source code. It also includes a test-specific, in-memory implementation (`TestDb`) for robust testing.",
            "spof": true
          },
          {
            "path": "crates/ruff_db/src/diagnostic/stylesheet.rs",
            "description": "This file defines the `DiagnosticStylesheet` struct and associated formatting utilities, which manage the styling (colors, bolding, hyperlinks) of diagnostic messages for display in a terminal.",
            "spof": false
          },
          {
            "path": "crates/ruff_db/src/diagnostic/mod.rs",
            "description": "This module defines the core `Diagnostic` structure and its associated methods for creating, managing, and preparing code analysis issues for display to the user. It integrates rendering logic and various levels of detail for reporting problems.",
            "spof": false
          },
          {
            "path": "crates/ruff_db/src/files/path.rs",
            "description": "This file defines the `FilePath` enum, an abstraction for file paths that can originate from the host file system (real or virtual) or from Ruff's vendored files. It provides methods for path manipulation, conversion, and comparison, enabling uniform handling of diverse file sources within the Ruff application.",
            "spof": true
          },
          {
            "path": "crates/ruff_db/src/files/file_root.rs",
            "description": "This file defines and manages \"file roots\" within a Salsa-based incremental compilation system. It tracks significant directories to determine file durability and manage invalidation when their contents change.",
            "spof": true
          },
          {
            "path": "crates/ruff_graph/src/db.rs",
            "description": "Defines the `ModuleDb` Salsa database, which manages file system access, Python version, and module search paths for Ruff's graph-related analysis tasks, integrating with `ruff_db` and module resolution utilities.",
            "spof": true
          },
          {
            "path": "crates/ruff_options_metadata/src/lib.rs",
            "description": "This file defines traits and types for representing, extracting, and navigating metadata about configuration options (fields and sets of fields) in a structured manner. It enables querying and collecting detailed information about options, such as documentation, type, and default values.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_ast/src/python_version.rs",
            "description": "This file defines a `PythonVersion` struct to represent Python major and minor versions, providing utilities for parsing, formatting, comparing, and querying version-specific features.",
            "spof": false
          },
          {
            "path": "crates/ruff_macros/src/combine.rs",
            "description": "This file implements a `proc_macro` that derives the `ty_combine::Combine` trait for structs, automatically generating code to combine two struct instances by applying `combine_with` to each of their fields.",
            "spof": true
          },
          {
            "path": "crates/ruff_macros/src/rust_doc.rs",
            "description": "This file implements a procedural macro that automatically derives the `ruff_db::RustDoc` trait for a type, extracting its documentation comments into a static string accessible via the `rust_doc()` method.",
            "spof": true
          },
          {
            "path": "crates/ruff_macros/src/newtype_index.rs",
            "description": "This file contains a procedural macro that generates a newtype index struct backed by `NonZeroU32`, providing safe conversions to/from `usize` and `u32`, arithmetic operations, and trait implementations for debugging and indexing.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_stdlib/src/keyword.rs",
            "description": "This file provides a Rust function to check if a given string is a Python keyword, mirroring the behavior of Python's `keyword.py` module. It lists all standard Python keywords for comparison.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_stdlib/src/logging.rs",
            "description": "Defines a Rust enum `LoggingLevel` representing various Python logging levels and provides a utility function to parse these levels from string attributes.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_stdlib/src/str.rs",
            "description": "This file provides utility functions for checking string casing properties, including whether a string is lowercase or uppercase, and specialized functions to determine if a string is \"cased\" as lowercase or uppercase, similar to Python's string methods.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_stdlib/src/lib.rs",
            "description": "This file serves as the main library entry point, organizing modules related to Python's standard library components and utilities. It aggregates definitions for builtins, keywords, identifiers, and other standard modules.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_stdlib/src/open_mode.rs",
            "description": "This file defines a `bitflags` enum `OpenMode` to represent file opening modes, similar to Python's `open()` function. It provides functionality to parse, validate, and reduce these modes from character or string inputs.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_stdlib/src/builtins.rs",
            "description": "This file defines and manages lists of Python built-in names and 'magic' globals, including those specific to different Python versions and IPython environments. It provides functions to retrieve these lists and check if a given name is a Python builtin.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_stdlib/src/sys/mod.rs",
            "description": "This file serves as the public interface for the `sys` module within `ruff_python_stdlib`, exporting functions to identify Python built-in and known standard library modules.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_stdlib/src/sys/builtin_modules.rs",
            "description": "This file contains a generated Rust function that determines whether a given Python module is a 'builtin' module for a specific Python minor version, which are modules compiled directly into the interpreter.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_stdlib/src/sys/known_stdlib.rs",
            "description": "This generated Rust file provides a function `is_known_standard_library` that checks if a given module name is part of the Python standard library, considering different Python minor versions. It is used by Ruff to identify standard library modules.",
            "spof": true
          },
          {
            "path": "crates/ty_project/src/glob.rs",
            "description": "This file implements a path filtering mechanism using include and exclude glob patterns, where exclude patterns take precedence. It provides functionality to check if directories or files are included or excluded based on these patterns.",
            "spof": true
          },
          {
            "path": "crates/ty_project/src/watch.rs",
            "description": "Defines data structures and enumerations for classifying and representing file system change events, such as creations, modifications, and deletions of files and directories, for both physical and virtual paths.",
            "spof": true
          },
          {
            "path": "crates/ty_project/src/files.rs",
            "description": "This file defines the data structures and logic for managing the indexed files of a project within a `salsa`-based incremental compilation system. It provides mechanisms for lazy indexing, caching, and efficiently updating the file set while ensuring `salsa` tracks changes.",
            "spof": false
          },
          {
            "path": "crates/ty_project/src/metadata.rs",
            "description": "This file defines the `ProjectMetadata` struct, responsible for discovering, loading, and managing project-specific configuration and metadata from files like `pyproject.toml` and `ty.toml`.",
            "spof": false
          },
          {
            "path": "crates/ty_project/src/walk.rs",
            "description": "This file defines structures and logic for walking a project's directory, filtering files and directories based on inclusion and exclusion rules, and collecting the relevant source files for analysis. It determines which files are part of the project and should be processed.",
            "spof": true
          },
          {
            "path": "crates/ty_project/src/db.rs",
            "description": "This file defines the `ProjectDatabase` struct, which acts as the central Salsa database for the `ty_project` crate, managing project state, file system interactions, and coordinating semantic analysis and diagnostic checking for a Python project.",
            "spof": false
          },
          {
            "path": "crates/ty_project/src/lib.rs",
            "description": "This file defines the core `Project` data structure for a Salsa-based code analysis tool, managing project-level configuration, file sets, and settings for linting and formatting. It also includes mechanisms for progress reporting and project reloading.",
            "spof": false
          },
          {
            "path": "crates/ty_project/src/glob/portable.rs",
            "description": "This file defines the `PortableGlobPattern` struct, which implements parsing, validation, and manipulation of cross-language glob patterns based on PEP 639, aligning with the `uv` tool's glob syntax.",
            "spof": true
          },
          {
            "path": "crates/ty_project/src/glob/include.rs",
            "description": "This file defines an `IncludeFilter` struct and its builder, which is used to filter file paths based on a set of inclusion glob patterns, optimized for performance using Deterministic Finite Automata (DFA).",
            "spof": true
          },
          {
            "path": "crates/ty_project/src/metadata/configuration_file.rs",
            "description": "This file defines the `ConfigurationFile` struct, which represents a `ty.toml` configuration file. It includes methods for loading `ty.toml` files from specific paths or user-level configuration directories, along with error handling for file operations and parsing.",
            "spof": true
          },
          {
            "path": "crates/ty_project/src/db/changes.rs",
            "description": "This file implements the logic for applying file system changes (e.g., creations, modifications, deletions) to the project database. It updates file states and determines if the project structure or custom standard library has changed, triggering necessary reloads.",
            "spof": false
          },
          {
            "path": "crates/ty_server/src/server/schedule/thread/pool.rs",
            "description": "This file defines a custom thread pool (`Pool`) for Rust, inspired by `rust-analyzer`, that allows scheduling tasks with specific thread priorities and handles panics by aborting the process.",
            "spof": true
          }
        ],
        "contributors": [
          {
            "name": "Micha Reiser",
            "percent": 51
          },
          {
            "name": "Brent Westbrook",
            "percent": 10
          },
          {
            "name": "Andrew Gallant",
            "percent": 8
          }
        ]
      },
      "Source Code and AST Representation": {
        "files": [
          {
            "path": "crates/ruff_python_trivia_integration_tests/README.md",
            "description": "This file provides integration tests for the `ruff_python_trivia` crate, separated to avoid circular dependencies with `ruff_python_parser`.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_trivia_integration_tests/tests/block_comments.rs",
            "description": "This file contains unit tests for the `block_comments` functionality within the `ruff_python_trivia` crate. It verifies the correct identification of contiguous Python comments that form a block comment under various conditions.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_trivia_integration_tests/tests/whitespace.rs",
            "description": "This file contains integration tests for the `has_trailing_content` function, verifying its ability to detect whether there is any significant content after a given AST node in various Python code snippets.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_trivia_integration_tests/tests/snapshots",
            "description": "This directory is designated to store snapshot test files for the `ruff_python_trivia_integration_tests` crate. These snapshots are used to compare current test outputs against expected baselines, ensuring consistency and detecting regressions in Python trivia handling.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_trivia_integration_tests/src",
            "description": "This directory contains integration tests specifically designed for the `ruff_python_trivia` crate. Its purpose is to verify the correct functioning and interaction of the trivia parsing components within the Ruff project.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_ast_integration_tests/tests/parenthesize.rs",
            "description": "This file contains unit tests for the `parenthesized_range` function, verifying its ability to correctly identify and extract the text range of parenthesized Python AST nodes in various scenarios.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_ast_integration_tests/tests/comparable.rs",
            "description": "Tests the `ComparableExpr` utility for Python abstract syntax tree (AST) expressions, ensuring that different but semantically equivalent literal representations (e.g., concatenated strings) are considered comparable.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_ast_integration_tests/tests/identifier.rs",
            "description": "This file contains a test for the `ruff_python_ast::identifier::else_` function, verifying its ability to correctly extract the text range of an `else` keyword in a Python `for...else` statement.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_ast_integration_tests/tests/visitor.rs",
            "description": "This file contains integration tests for the AST visitor implementation in ruff_python_ast, verifying its traversal behavior across various Python language constructs using snapshot testing.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_ast_integration_tests/tests/stmt_if.rs",
            "description": "This file contains integration tests for the `elif_else_range` utility, ensuring it correctly extracts the text range of `elif` and `else` clauses within Python `if` statements.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_ast_integration_tests/tests/source_order.rs",
            "description": "This file contains unit tests for the `SourceOrderVisitor` in the `ruff_python_ast` crate, verifying that it traverses Python abstract syntax tree (AST) nodes in the correct source order for various code constructs using snapshot testing.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_ast_integration_tests/tests/snapshots",
            "description": "This directory is designated to store snapshot test files for the `ruff_python_ast_integration_tests` crate. It holds expected outputs or 'golden master' files used to verify the correct behavior and output of the Python Abstract Syntax Tree (AST) integration tests. The purpose is to ensure stability and catch unintended changes in the AST processing logic.",
            "spof": false
          },
          {
            "path": "crates/ruff_annotate_snippets/tests/fixtures/deserialize.rs",
            "description": "Defines deserializable data structures (`*Def` suffixed structs) that serve as an intermediate representation for test fixtures of `ruff_annotate_snippets`. It provides conversion logic to transform these deserialized fixtures into the actual types used by the annotation renderer.",
            "spof": true
          },
          {
            "path": "crates/ty_python_semantic/src/node_key.rs",
            "description": "This file defines `NodeKey`, a compact wrapper around `NodeIndex`, designed to be used as a hash map key for Abstract Syntax Tree (AST) nodes, enabling efficient lookup and storage.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/src/rank.rs",
            "description": "This file defines a `RankBitBox` data structure, a boxed bit slice that supports constant-time 'rank' operations. It is used to efficiently map indices from a larger conceptual vector to a smaller, filtered vector.",
            "spof": true
          },
          {
            "path": "crates/ty_python_semantic/src/ast_node_ref.rs",
            "description": "Defines `AstNodeRef`, a stable reference to an Abstract Syntax Tree (AST) node within a module, designed to maintain node identity for incremental compilation using Salsa. It allows retrieving the actual AST node via a `ParsedModuleRef`.",
            "spof": true
          },
          {
            "path": "crates/ty_python_semantic/src/list.rs",
            "description": "This file implements a custom, arena-allocated, sorted association list data structure for storing key-value pairs. It provides `ListBuilder` for construction and `ListStorage` for read-only access, optimizing for efficient cloning and combination while ensuring sorted, unique keys.",
            "spof": true
          },
          {
            "path": "crates/ruff_db/src/source.rs",
            "description": "This file manages the reading and representation of source code, including Python text files and Jupyter notebooks, within an incremental compilation system (Salsa). It provides a unified `SourceText` abstraction and calculates line indices.",
            "spof": true
          },
          {
            "path": "crates/ruff_notebook/src/index.rs",
            "description": "This file defines the `NotebookIndex` struct and its methods, which are used to translate line and column positions from a concatenated Jupyter notebook source code back to their original cell and line numbers within the notebook.",
            "spof": true
          },
          {
            "path": "crates/ruff_notebook/src/lib.rs",
            "description": "This file serves as the main library entry point for utilities related to reading and writing Jupyter notebooks. It re-exports modules for handling notebook cells, indexing, the notebook structure itself, and its schema.",
            "spof": true
          },
          {
            "path": "crates/ruff_notebook/src/schema.rs",
            "description": "Defines the Rust data structures (schema) for representing Jupyter notebooks, generated from the Jupyter nbformat specification with custom serialization and deserialization logic.",
            "spof": true
          },
          {
            "path": "crates/ruff_notebook/src/cell.rs",
            "description": "This file defines data structures and methods for representing and analyzing individual cells within a Jupyter notebook, including handling source code, metadata, and detecting special magic commands.",
            "spof": false
          },
          {
            "path": "crates/ruff_notebook/src/notebook.rs",
            "description": "This file implements the core `Notebook` data structure and its associated logic for parsing, manipulating, and serializing Jupyter notebooks. It handles reading notebook files, extracting and concatenating cell source code, managing cell offsets, and writing modified notebooks back.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/src/locator.rs",
            "description": "This file defines the `Locator` struct, which efficiently provides access, slicing, and line-based operations on source code by wrapping a string slice and lazily initializing a line index.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/source_kind.rs",
            "description": "Defines an enum `SourceKind` to represent and manage different types of source content (Python code, Jupyter notebooks, Markdown) within the ruff linter. It provides utilities for reading, writing, updating, and diffing these diverse source types.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/src/comments/shebang.rs",
            "description": "Defines a `ShebangDirective` struct for parsing and extracting shebang lines (e.g., `#!/usr/bin/env python3`) from source code, providing a structured way to handle these interpreter directives.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/cst/helpers.rs",
            "description": "This file provides helper functions for manipulating `libcst_native` elements, including whitespace handling and negating Python expressions while respecting operator precedence.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_ast/src/find_node.rs",
            "description": "This file provides functionality to find the smallest Abstract Syntax Tree (AST) node that fully encloses a given text range and offers utilities to navigate its ancestral hierarchy.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_ast/src/relocate.rs",
            "description": "This file provides functionality to recursively relocate the text range of an Abstract Syntax Tree (AST) expression or keyword to a new, specified range, effectively updating its source code position metadata.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_ast/src/parenthesize.rs",
            "description": "This file provides utility functions to identify and extract the text ranges of optional parentheses surrounding a given Python expression within the abstract syntax tree.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_ast/src/docstrings.rs",
            "description": "This file provides utility functions for parsing and cleaning up text specifically within Python docstrings, including extracting leading words and whitespace, and normalizing indentation.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_ast/src/types.rs",
            "description": "This file defines the `Node` enum, which acts as a common type for representing Abstract Syntax Tree (AST) nodes, specifically for Python statements and expressions, within the `ruff_python_ast` crate.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_ast/src/stmt_if.rs",
            "description": "This file provides utilities for analyzing and extracting information from `if` and `elif` branches within Python `if` statements in the Abstract Syntax Tree (AST), including their kinds, test expressions, bodies, and text ranges.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_ast/src/int.rs",
            "description": "Defines a custom `Int` type to represent Python integer literals, accommodating both small integers (fitting into `u64`) and arbitrarily large integers, with methods for parsing, conversion, and comparison.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_ast/src/helpers.rs",
            "description": "This file provides helper functions for analyzing and traversing Python abstract syntax tree (AST) nodes, including identifying compound statements and expressions with side-effects.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_ast/src/comparable.rs",
            "description": "This file defines a comparable abstract syntax tree (AST) hierarchy for Python code, enabling structural equality comparisons and hashing of AST nodes by ignoring non-structural details like formatting or context. It provides types like `ComparableExpr`, `ComparableStmt`, and various `Comparable` enums for AST operations and elements, alongside conversions from the standard `ast` types.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_ast/src/node_index.rs",
            "description": "This file defines `NodeIndex` and `AtomicNodeIndex` for uniquely identifying AST nodes, including a specialized `u32` encoding scheme to support nesting and sub-ASTs like string annotations. It provides methods for managing and accessing these indices, especially for post-parsing assignment.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_ast/src/str_prefix.rs",
            "description": "This file defines enumerations for various prefixes that can be applied to different types of Python string literals (e.g., regular, f-string, bytestring, t-string), providing methods to access their string representation and properties.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_ast/src/visitor.rs",
            "description": "This file defines the `Visitor` trait and associated `walk` functions for traversing Python Abstract Syntax Tree (AST) nodes in evaluation order within the Ruff linter. It allows for inspecting AST structures without modification.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_ast/src/identifier.rs",
            "description": "This module provides utilities to extract the `TextRange` of identifiers and specific keywords (like `except`, `else`) from Python Abstract Syntax Tree (AST) nodes and source code. It includes a trait for common AST node types and a tokenizer for robust identifier extraction.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_ast/src/whitespace.rs",
            "description": "This file provides utilities for analyzing whitespace, indentation, and comments within Python source code, including extracting leading indentation, identifying trailing empty lines, and locating trailing comments.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_ast/src/expression.rs",
            "description": "This file defines utility enums and implementations for working with references to various literal and string-like expressions in the Python Abstract Syntax Tree (AST), facilitating AST traversal and analysis. It provides ways to categorize and extract information from these expression types without owning them.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_ast/src/statement_visitor.rs",
            "description": "This file defines a trait and associated `walk` functions for visiting only statement nodes within a Python Abstract Syntax Tree (AST). It allows for specialized traversal of statement bodies, conditional clauses, and match cases.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_ast/src/nodes.rs",
            "description": "This file defines the core data structures (nodes) for representing a Python Abstract Syntax Tree (AST) within the `ruff_python_ast` crate, along with various utility methods for interacting with these AST nodes.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_ast/src/script.rs",
            "description": "This file defines a `ScriptTag` struct and parsing logic to extract PEP 723 metadata blocks from Python scripts. It identifies and separates the script's content into a prelude, the metadata block, and the remaining Python code.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_ast/src/node.rs",
            "description": "This file implements the `visit_source_order` method for various Python Abstract Syntax Tree (AST) nodes, enabling source-order traversal of the AST using a visitor pattern.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_ast/src/name.rs",
            "description": "This file defines data structures like `Name`, `QualifiedName`, and `UnqualifiedName` to represent and efficiently manage various forms of Python identifiers and dotted names for Abstract Syntax Tree (AST) processing.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_ast/src/lib.rs",
            "description": "This file defines enums for classifying source file types (Python, TOML, Markdown) and serves as the main entry point for Ruff's Python Abstract Syntax Tree (AST) library, exposing modules for AST representation and processing.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_ast/src/traversal.rs",
            "description": "This file provides utilities for navigating a Python AST, specifically to find the enclosing statement suite for a given statement and access its siblings within that suite.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_ast/src/visitor/source_order.rs",
            "description": "This file defines a `SourceOrderVisitor` trait and associated functions for traversing the Python Abstract Syntax Tree (AST) in the order the nodes appear in the source code.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_ast/src/visitor/transformer.rs",
            "description": "This file defines a `Transformer` trait and associated `walk` functions, providing a framework for recursively traversing and modifying a Python Abstract Syntax Tree (AST) in place.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_ast/src/token/parentheses.rs",
            "description": "This file provides utilities to identify and retrieve the text ranges of parentheses surrounding a given expression within a Rust abstract syntax tree (AST), including an iterator for multiple levels of parenthesization.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_index/src/indexer.rs",
            "description": "This file defines an `Indexer` struct responsible for parsing Python source code tokens to build an index of elements not typically present in the abstract syntax tree, such as comments, multi-line strings, and line continuations. It enables efficient lookup and analysis of these elements.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_index/src/multiline_ranges.rs",
            "description": "This file defines data structures and methods to identify, store, and query the text ranges of multiline (triple-quoted) strings within a Python file. It provides functionality to efficiently check if a given range is contained within or intersects with any of these multiline string ranges.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_index/src/lib.rs",
            "description": "This file is the main library entry point for `ruff_python_index`, defining and re-exporting the `Indexer` component. It organizes modules responsible for indexing Python code, particularly concerning interpolated strings and multiline ranges.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_semantic/src/nodes.rs",
            "description": "This file defines data structures for representing and managing Abstract Syntax Tree (AST) nodes with unique IDs, parent references, and branch information. It also provides a unified `NodeRef` enum to abstract over statement and expression nodes for semantic analysis purposes.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_trivia/src/pragmas.rs",
            "description": "This file provides a utility function to determine if a given comment string is a recognized pragma comment, such as `# noqa`, `# type: ignore`, or `# isort: off`.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_trivia/src/comments.rs",
            "description": "This file defines enums and logic to identify different kinds of formatting suppression comments (e.g., `fmt: off`, `yapf: disable`) and to determine the line position of comments (own line vs. end-of-line) within Python source code.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_trivia/src/whitespace.rs",
            "description": "This file defines utilities for identifying and manipulating Python-specific whitespace within source code, including functions for detecting indentation, checking for leading/trailing content, and custom string trimming methods.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_trivia/src/lib.rs",
            "description": "This file serves as the main library entry point for `ruff_python_trivia`, re-exporting various modules that handle non-semantic elements (trivia) of Python source code, such as comments, whitespace, and tokenization.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_trivia/src/comment_ranges.rs",
            "description": "This file defines the `CommentRanges` struct, which stores and provides methods to query and categorize comment ranges within source code, including identifying block comments and checking for comment presence within specific text ranges.",
            "spof": false
          },
          {
            "path": "crates/ruff_text_size/src/serde_impls.rs",
            "description": "This file implements Serde serialization and deserialization for the `TextSize` and `TextRange` types. It defines how these custom text-related data structures are converted to and from a serializable format.",
            "spof": false
          },
          {
            "path": "crates/ruff_text_size/src/lib.rs",
            "description": "This library defines newtypes for text sizes and ranges to provide type-safe and storage-optimized representations, primarily for applications where text ranges are pervasive.",
            "spof": true
          },
          {
            "path": "crates/ruff_text_size/src/schemars_impls.rs",
            "description": "This module implements the `JsonSchema` trait for `TextSize` and `TextRange`, enabling schema generation for these types. This is used to provide meta-information for serialization/deserialization, such as for autocomplete in configuration files and TypeScript type generation.",
            "spof": false
          },
          {
            "path": "crates/ruff_text_size/src/traits.rs",
            "description": "This file defines core traits like `TextLen`, `Ranged`, and `TextSlice` for working with text sizes, ranges, and slicing within the `ruff_text_size` crate, providing a foundational API for text manipulation.",
            "spof": false
          },
          {
            "path": "crates/ruff_text_size/src/size.rs",
            "description": "Defines the `TextSize` struct, a type-safe representation for UTF-8 text lengths or offsets, providing methods for creation, conversion, and arithmetic operations.",
            "spof": false
          },
          {
            "path": "crates/ruff_text_size/tests/main.rs",
            "description": "This file contains unit tests for the `TextSize` and `TextRange` types from the `ruff_text_size` crate, verifying their mathematical operations, range manipulations, and containment logic.",
            "spof": true
          },
          {
            "path": "crates/ruff_text_size/tests/serde.rs",
            "description": "This file contains unit tests for the Serde serialization and deserialization of `TextSize` and `TextRange` types, including checks for valid serialization and invalid range deserialization errors.",
            "spof": false
          },
          {
            "path": "crates/ruff_text_size/tests/indexing.rs",
            "description": "Tests the indexing capabilities of `ruff_text_size::TextRange` when used with string types. It verifies how `TextRange` can be applied to slice string literals and `String` objects.",
            "spof": true
          },
          {
            "path": "crates/ruff_text_size/tests/constructors.rs",
            "description": "This file contains unit tests for the `TextSize::of` constructor, demonstrating its usage with different data types like `char`, `&str`, and `&String`, and also includes a custom `BadRope` struct to test `TextSize` in a collection context.",
            "spof": true
          },
          {
            "path": "crates/ruff_source_file/src/line_index.rs",
            "description": "This file defines a `LineIndex` struct that provides efficient conversions between byte offsets and line/column numbers within a source file, handling various text encodings and newline conventions.",
            "spof": true
          },
          {
            "path": "crates/ruff_source_file/src/newlines.rs",
            "description": "This file provides utilities for iterating over lines in a string, correctly handling universal newline characters (LF, CRLF, and CR). It defines iterators and a `Line` struct to represent individual lines with their text content, byte offsets, and identified line endings.",
            "spof": false
          },
          {
            "path": "crates/ruff_source_file/src/line_ranges.rs",
            "description": "This file defines the `LineRanges` trait, which extends string functionality to provide methods for robust line-based text manipulation. It enables precise calculation of line starts, ends, and ranges within a string, handling various newline conventions.",
            "spof": true
          },
          {
            "path": "crates/ruff_source_file/src/lib.rs",
            "description": "This file defines core data structures (`SourceCode`, `SourceFile`) and utilities for representing, accessing, and querying source code text. It handles mapping text offsets to line and column numbers, managing line indices, and providing efficient access to file content and metadata.",
            "spof": true
          }
        ],
        "contributors": [
          {
            "name": "Douglas Creager",
            "percent": 26
          },
          {
            "name": "Micha Reiser",
            "percent": 21
          },
          {
            "name": "Dylan",
            "percent": 9
          }
        ]
      },
      "Python Parser and Lexer": {
        "files": [
          {
            "path": "crates/ruff_python_trivia_integration_tests/tests/simple_tokenizer.rs",
            "description": "This file contains integration tests for the `ruff_python_trivia` crate, specifically for its `SimpleTokenizer` and `BackwardsTokenizer`. It verifies the correct tokenization of various Python syntax elements, including comments, operators, strings, and whitespace, in both forward and reverse directions.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_ast_integration_tests/tests/parentheses.rs",
            "description": "Tests for the `parentheses_iterator` and `parenthesized_range` functions within the `ruff_python_ast::tokens` module. These tests verify the correct identification and extraction of parenthesized ranges in various Python code scenarios.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_ast_integration_tests/tests/match_pattern.rs",
            "description": "This file contains an integration test for the `ruff_python_ast` crate, specifically verifying that the AST correctly identifies various wildcard patterns within Python `match` statements.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_ast_integration_tests/src",
            "description": "This directory contains the source code for the integration tests of the `ruff_python_ast` crate. Its primary role is to verify the correct functionality and interactions within the Python AST parsing and manipulation components of the Ruff project. These tests ensure the robustness and accuracy of the AST processing logic.",
            "spof": false
          },
          {
            "path": "crates/ruff_dev/src/print_tokens.rs",
            "description": "This file provides a command-line utility to parse a given Python file and print its token stream to standard output. It uses Ruff's internal parsing utilities to display the lexical tokens of the Python source.",
            "spof": true
          },
          {
            "path": "crates/ruff_dev/src/print_ast.rs",
            "description": "This file contains a Rust program that parses a given Python file and prints its Abstract Syntax Tree (AST) to the console.",
            "spof": true
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/python_version.md",
            "description": "This file demonstrates how different Python versions can be configured and how version-specific features are recognized or not recognized based on the specified Python version.",
            "spof": true
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/invalid_syntax.md",
            "description": "This file contains test cases demonstrating how the `ty` tool handles various Python syntax errors without panicking. It includes examples of keywords used as identifiers and invalid type annotations.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/diagnostics/version_related_syntax_errors.md",
            "description": "This file documents and tests how version-related Python syntax errors, such as the `match` statement in Python 3.10, are diagnosed in different Python environments.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/exception/invalid_syntax.md",
            "description": "This file provides a markdown-formatted test case demonstrating how the static analyzer handles invalid Python syntax within an exception block, specifically an incorrect 'except as e' clause, and its type inference implications.",
            "spof": true
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/02_expr_bool_op_multiline2.py",
            "description": "This file contains a multi-line boolean expression designed as a test case for parsing or semantic analysis, likely within a static analysis tool like Ruff.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/02_expr_bool_op_multiline.py",
            "description": "This file contains examples of multiline boolean operations using 'or', demonstrating different syntax for line continuation (parentheses and backslash).",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/03_dict_literal_large.py",
            "description": "This file defines a large dictionary literal named `DATA`. It likely serves as a test case or benchmark for handling large dictionary definitions in Python.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/04_assign_unpack.py",
            "description": "This file demonstrates unpacking assignments in Python, showing how to assign multiple variables simultaneously from an iterable like a tuple or list.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/02_expr_rel_multiple.py",
            "description": "This file contains examples of chained relational expressions in Python, likely for testing or demonstrating parsing of such constructs.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/03_tuple.py",
            "description": "This file contains examples of Python tuple syntax, including a single-element tuple and a multi-element tuple, likely for testing or demonstrating type analysis or parsing.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/04_aug_assign.py",
            "description": "This file demonstrates various augmented assignment operators in Python, such as `+=`, `-=`, `*=`, and others.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/04_assign_unpack_tuple.py",
            "description": "This file demonstrates various forms of tuple unpacking assignments in Python. It shows how multiple variables can be assigned values from a sequence of expressions.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/03_slice.py",
            "description": "This file provides a corpus of Python slicing syntax examples. It demonstrates various forms of slice notation for testing or analysis purposes within the `ruff` project's semantic analysis component.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/05_funcall_kw_many.py",
            "description": "This file contains a Python function call with numerous keyword arguments. It likely serves as a test case or example for parsing and analyzing complex function argument lists.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/03_slice_ext.py",
            "description": "This file demonstrates extended slicing syntax in Python, likely serving as a test case for static analysis or type checking tools to ensure correct parsing and interpretation of multi-dimensional slices.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/03_dict_unpack_huge.py",
            "description": "This file contains a large dictionary literal constructed by unpacking many small dictionaries, likely serving as a benchmark or test case for analyzing dictionary unpacking performance or parsing limits.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/08_del_multi.py",
            "description": "This file demonstrates the use of the `del` statement to delete multiple variables simultaneously, using both tuple and list syntax for grouping.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/04_aug_assign_attr_multiline.py",
            "description": "Tests or demonstrates multiline augmented assignment to an object attribute, likely for a Python linter or static analysis tool.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/07_ifexpr_multiline.py",
            "description": "This file contains a Python code snippet demonstrating a multi-line if-expression within a tuple. It likely serves as a test case for a linter or formatter's parsing capabilities.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/04_assign_unpack_ex.py",
            "description": "This file demonstrates various forms of extended iterable unpacking assignments in Python, including single and multiple starred assignments. It likely serves as a test case or corpus example for static analysis tools.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/12_if_elif.py",
            "description": "This file demonstrates a basic if-elif conditional statement, likely for testing or educational purposes related to Python syntax analysis.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/06_funcall_starargs_ex.py",
            "description": "This file contains various examples of function calls demonstrating the use of star-arguments (`*args`) in different positions and combinations within the argument list.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/05_funcall_in_multiline_tuple.py",
            "description": "This file contains a multiline tuple assignment where one of the tuple elements is a function call. It likely serves as a test case for parsing or formatting Python code.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/07_ifexpr_multiline2.py",
            "description": "This file contains a Python example demonstrating a multi-line `if-else` expression assigned to a variable. It likely serves as a test case for parsing or semantic analysis of complex conditional assignments.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/06_funcall_varargs_kwargs.py",
            "description": "This file demonstrates a Python function call using variadic positional arguments (*args) and variadic keyword arguments (**kwargs).",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/15_while.py",
            "description": "This file contains a minimal Python `while` loop, likely serving as a test case or example for parsing and analyzing basic control flow structures.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/16_for_break.py",
            "description": "This file contains a simple Python 'for' loop that immediately breaks, likely serving as a test case for 'break' statement behavior.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/16_for_continue.py",
            "description": "Demonstrates a basic 'for' loop with an unconditional 'continue' statement, likely for testing parsing or control flow analysis.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/06_funcall_varargs_kwargs_mixed.py",
            "description": "This file demonstrates various Python function call signatures, specifically focusing on the mixed usage of positional arguments, keyword arguments, varargs (*args), and kwargs (**kwargs).",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/16_for.py",
            "description": "This file contains a simple Python `for` loop, likely serving as a test case or example for semantic analysis within the `ruff` project.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/20_lambda.py",
            "description": "This file contains examples of lambda expressions in Python, likely for testing or corpus analysis purposes.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/16_for_else.py",
            "description": "This file provides an example or test case for Python's 'for...else' loop construct. It demonstrates the basic syntax of a 'for' loop followed by an 'else' block.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/07_ifexpr.py",
            "description": "This file contains an example of an `if` expression (ternary operator) in Python. It likely serves as a test case for parsing or analyzing this language construct.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/10_if_with_named_expr.py",
            "description": "Demonstrates the use of a named expression (walrus operator) within an 'if' statement condition. It assigns a new value to 'x' and evaluates it simultaneously.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/54_list_comp_lambda.py",
            "description": "This file defines a lambda function that contains a list comprehension, likely used for testing or demonstration of Python syntax involving both constructs.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/53_set_comp.py",
            "description": "This file contains an example of a Python set comprehension, likely for testing or demonstration purposes.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/02_expr_attr_multiline.py",
            "description": "This file contains a Python code snippet demonstrating a multiline function call followed by an attribute access. It likely serves as a test case for type checking or static analysis tools to ensure correct parsing and interpretation of such expressions.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/58_async_for_dict_comp.py",
            "description": "This file contains an asynchronous function demonstrating the use of 'async for' within a dictionary comprehension to populate a dictionary from an asynchronous generator.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/58_async_for.py",
            "description": "This file contains an `async def` function demonstrating an `async for` loop, likely serving as a test case for async iterator analysis.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/60_try_except.py",
            "description": "This file contains a simple 'try-except' block, likely serving as a test case or example for parsing and analyzing basic exception handling in Python.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/41_from_import.py",
            "description": "This file demonstrates various Python 'from ... import' statements, including specific names and 'import *', likely for testing or examples of import syntax.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/57_await.py",
            "description": "This file contains a simple asynchronous Python function demonstrating the use of the 'await' keyword, likely serving as a test case for semantic analysis or parsing of async/await syntax.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/50_yield.py",
            "description": "This file demonstrates various usages of the 'yield' keyword within a Python generator function, including bare yield, yielding a value, and yielding a value that is subsequently assigned.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/58_async_for_else.py",
            "description": "This asynchronous Python file demonstrates the use of an `async for` loop with an `else` block.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/59_async_with.py",
            "description": "This file demonstrates the usage of an 'async with' statement within an asynchronous function. It serves as a test case for parsing or analyzing async context managers.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/63_raise_x_from_y.py",
            "description": "This file demonstrates a basic Python `raise ... from ...` statement for exception chaining.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/58_async_for_list_comp.py",
            "description": "This file defines an asynchronous function `foo` that demonstrates the use of both asynchronous and synchronous list comprehensions.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/67_with.py",
            "description": "Demonstrates a basic Python `with` statement, showing its syntax and structure.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/53_dict_comp.py",
            "description": "This file provides simple examples of dictionary comprehensions in Python. It demonstrates both a single-loop dictionary comprehension and a nested-loop dictionary comprehension.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/69_for_try_except_continue2.py",
            "description": "This Python file demonstrates a 'for' loop with a 'try-except' block. It iterates through a sequence, attempting an operation, and continues to the next iteration if a specific exception occurs.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/62_try_except_double_nested_inside_if_else.py",
            "description": "This file is a test case demonstrating a double-nested `try-except` block structure placed inside an `if-else` statement.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/60_try_except2.py",
            "description": "This file demonstrates a Python `try-except` statement with multiple `except` blocks, catching different exception types. It is likely used for testing or parsing complex exception handling structures.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/74_class_kwargs.py",
            "description": "This file demonstrates invalid Python syntax where keyword arguments are passed directly to a class definition in the class header.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/78_class_dec_member.py",
            "description": "This file contains a simple Python class `C` decorated with `@foo.bar`, likely serving as a test case for analyzing class definitions with decorators.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/85_match_as.py",
            "description": "This file contains a test case demonstrating the use of the `match` statement with an `as` pattern in a `case` clause.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/80_func_kwonlyargs3.py",
            "description": "Tests Python function definition with keyword-only arguments, including one with a default value and one without, along with `**kwargs`.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/78_class_body_cond.py",
            "description": "Tests or demonstrates conditional statements within a class body in Python.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/85_match.py",
            "description": "This file contains a simple Python 'match' statement with a single 'case' for the value 0. It likely serves as a test case or example to demonstrate basic pattern matching functionality.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/85_match_sequence_wildcard.py",
            "description": "This file demonstrates Python's `match` statement with sequence patterns, specifically showcasing the use of wildcard (`*`) unpacking within list patterns.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/85_match_singleton.py",
            "description": "This file contains a Python `match` statement example specifically testing a `case False` pattern.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/85_match_or.py",
            "description": "This file demonstrates a Python `match` statement using the `|` (OR) operator to match multiple integer values within a single case.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/85_match_class.py",
            "description": "This file contains a test case demonstrating a Python 'match' statement using a class pattern (specifically `bool`) to bind a variable `z`.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/91_line_numbers3.py",
            "description": "Tests multi-line statement parsing and line number handling using backslash continuation characters.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/85_match_mapping.py",
            "description": "This file contains a Python `match` statement demonstrating a mapping pattern `{0: 0}`. It likely serves as a test case for the `match` statement's handling of dictionary-like patterns.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/85_match_guard.py",
            "description": "This file contains a Python `match` statement demonstrating case guards with boolean conditions, likely serving as a test case or example for `match` statement behavior.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/94_strformat_spec.py",
            "description": "This file contains a Python function demonstrating f-string formatting with a string format specifier (e.g., `:0`) for a variable.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/94_strformat_conversion.py",
            "description": "This file demonstrates f-string formatting, specifically using the '!r' conversion flag and a dynamically calculated field width.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/85_match_default.py",
            "description": "This file demonstrates a Python `match` statement, specifically showcasing the use of a default case with the `_ as y` pattern.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/80_func_kwonlyargs2.py",
            "description": "This file defines a Python function `foo` that includes positional, `*args`, keyword-only, and `**kwargs` parameters. It likely serves as a test case for parsing and analyzing function definitions with various argument types, particularly keyword-only arguments, within the `ruff` project's semantic analysis corpus.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/85_match_sequence.py",
            "description": "This file contains a Python `match` statement demonstrating pattern matching with sequence literals, specifically an empty list and a list with two elements.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/91_line_numbers2.py",
            "description": "This file contains a simple Python list assignment, likely serving as a test case within a corpus for semantic analysis, possibly to evaluate line number tracking or basic parsing capabilities.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/90_docstring_func.py",
            "description": "This file defines a simple Python function `foo` with a docstring. It likely serves as a test case for analyzing or extracting docstrings from function definitions.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/91_line_numbers_dict_comp.py",
            "description": "This file contains an incomplete and syntactically invalid dictionary comprehension, likely used as a test case for error handling or parsing in a linter or semantic analysis tool.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/91_line_numbers4.py",
            "description": "Tests multi-line assignments with logical operators, likely for line number parsing or error reporting within a linter or semantic analysis tool.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/94_strformat.py",
            "description": "This file contains a Python function that demonstrates the use of f-strings for dynamic string formatting, specifically including method calls and string joining within the f-string.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/91_line_numbers1.py",
            "description": "This file is a test case demonstrating a discrepancy in line number reporting for module code objects between CPython 3.5 and the `ruff` tool, specifically when a list's first element is on a new line after assignment.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/85_match_guard_with_named_expr.py",
            "description": "This file contains a test case demonstrating the use of a match statement with a named expression (walrus operator) within a match guard clause. It's likely used to verify the behavior or parsing of such constructs in Python.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/85_match_in_func_with_star.py",
            "description": "Tests or demonstrates a Python match statement with a star pattern (list unpacking) inside a function definition. This file is likely part of a linter's test corpus for `ruff`.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/94_strformat_complex.py",
            "description": "This file contains a complex f-string, likely serving as a test case for a Python semantic analysis or type checking tool to evaluate its handling of string formatting.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/85_match_mapping_subpattern.py",
            "description": "This file contains a Python `match` statement demonstrating a mapping subpattern with an 'as' clause inside a union pattern, likely serving as a test case for a semantic analysis tool.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/70_class.py",
            "description": "This corpus file contains a minimal Python class definition (`class C: pass`). It serves as a test case for the `ty_python_semantic` crate, likely for parsing or semantic analysis of class structures.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/91_line_numbers2_comp.py",
            "description": "This file contains a basic Python list comprehension. It likely serves as a test case for analyzing line numbers or semantic parsing of comprehensions within the `ruff` type-checking or semantic analysis module.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/98_ann_assign_annotation_wrong_future.py",
            "description": "This file is a test case demonstrating how type annotations on assignments interact with unusual `__future__` imports, specifically `barry_as_FLUFL`.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/src/suppression/parser.rs",
            "description": "This file implements a parser for Python suppression comments (e.g., `# type: ignore`), extracting the suppression kind and any specified error codes. It defines the `SuppressionParser` responsible for tokenizing and interpreting these comments.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/README.md",
            "description": "This README file provides an overview of the Ruff Python Parser, detailing its parsing techniques, Python version support, and contribution guidelines.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/CONTRIBUTING.md",
            "description": "This file provides guidelines for contributing to the Ruff Python parser, detailing how to write and run inline tests, use the Python-based fuzzer, and execute lexer and parser benchmarks.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_parser/src/lexer.rs",
            "description": "This module implements the lexer for Python source code, responsible for scanning and translating source text into a stream of tokens.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_parser/src/token.rs",
            "description": "This file defines the `TokenValue` enum, which represents the various types of data values associated with lexical tokens identified during the parsing of Python source code. It encapsulates different literal types such as names, integers, floats, strings, and IPython escape commands.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_parser/src/token_set.rs",
            "description": "This file defines a `TokenSet` bit-set data structure for efficiently storing and querying collections of `TokenKind` enum variants using bit manipulation.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_parser/src/typing.rs",
            "description": "This module is responsible for parsing Python type annotations from string literals, distinguishing between simple and complex forms based on their structure.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_parser/src/string.rs",
            "description": "This file is responsible for parsing different types of Python string literals, including plain strings, byte strings, and interpolated strings (f-strings and t-strings), handling escape sequences and concatenation.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_parser/src/error.rs",
            "description": "This file defines the error types and structures used by the Python parser, including `ParseError` for general parsing failures and enums for categorizing specific syntax and lexical issues.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_parser/src/lib.rs",
            "description": "This Rust file is the main entry point for the `ruff_python_parser` crate, providing functionalities to parse Python source code into an Abstract Syntax Tree (AST). It includes functions for lexical analysis and parsing, supporting various parsing modes like modules, expressions, and string annotations.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/src/token_source.rs",
            "description": "This file defines `TokenSource`, an adapter that provides a stream of non-trivia tokens to a parser, wrapping a lexer. It stores all lexed tokens (including trivia) and supports advanced features like re-lexing for specific syntax constructs.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_parser/src/parser/options.rs",
            "description": "This file defines the `ParseOptions` struct, which encapsulates settings for parsing Python source code, including the parsing mode (e.g., module, expression) and the target Python version for syntax validation.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/src/parser/recovery.rs",
            "description": "This file contains a utility function for error recovery during parsing, specifically converting Python pattern AST nodes into expression AST nodes. This allows the parser to represent invalid pattern usages as expressions, preserving their structure for further analysis.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_parser/src/parser/tests.rs",
            "description": "This file contains unit tests for the Rust Python parser, specifically verifying its ability to parse various Python syntax constructs, handle different parsing modes (e.g., expression, module, IPython), and identify invalid syntax.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_parser/src/parser/mod.rs",
            "description": "This file defines the core `Parser` struct and its methods for the Ruff Python parser, responsible for converting Python source code into an Abstract Syntax Tree (AST) while handling various parsing modes and error recovery.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_parser/src/parser/progress.rs",
            "description": "This file defines utilities (`TokenId`, `ParserProgress`) for tracking and asserting that a parser is continually making progress through the input, preventing infinite loops or stalls.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/src/parser/helpers.rs",
            "description": "This file provides helper functions for the Python parser, including utilities to set expression contexts, convert token kinds to comparison operators, and validate decorator expressions.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_parser/src/parser/expression.rs",
            "description": "This file contains the core logic for parsing various types of Python expressions, including binary, conditional, and named expressions, utilizing token sets and operator precedence rules.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_parser/src/parser/statement.rs",
            "description": "This file implements the parsing logic for Python statements within the Ruff Python parser. It defines token sets for different statement types and contains methods to identify, parse, and handle errors related to simple and compound statements.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_parser/src/parser/pattern.rs",
            "description": "This file implements the parsing logic for Python's structural pattern matching (match statement patterns) within the Ruff Python parser. It defines functions and token sets for recognizing and converting various pattern types into an abstract syntax tree representation.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_parser/src/parser/snapshots",
            "description": "This directory is intended to store test snapshots for the `ruff_python_parser`. It is used during development and testing to capture and validate the expected output or behavior of the parser components, ensuring consistency and preventing regressions.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_parser/src/lexer/indentation.rs",
            "description": "This file defines data structures and logic for managing indentation levels in a Python parser, including calculating column positions for spaces and tabs, and maintaining an indentation stack.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/src/lexer/interpolated_string.rs",
            "description": "This file defines structures to track the state of interpolated strings (f-strings and t-strings) during lexing, handling nesting, format specifications, and managing a stack of these contexts.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_parser/src/lexer/cursor.rs",
            "description": "This file defines the `Cursor` struct, a utility for lexing that allows efficient iteration, peeking, and consumption of characters within a source code string, tracking position and token lengths.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_parser/src/snapshots",
            "description": "This directory is intended to store snapshot test data for the `ruff_python_parser` crate. Snapshot tests capture expected output or state, and subsequent test runs compare against these stored snapshots to detect regressions. While currently empty, its purpose is to hold golden master files for testing the parser's output.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_parser/tests/fixtures.rs",
            "description": "This file contains Rust test fixtures and utilities for validating the `ruff_python_parser`. It defines tests for both valid and invalid Python syntax, asserting correct AST generation and error reporting through snapshot testing.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_parser/tests/snapshots",
            "description": "This directory stores snapshot test data for the `ruff_python_parser` component. These snapshots capture expected outputs or internal states, allowing tests to quickly detect unintended changes or regressions in the parser's behavior. It ensures the parser's output remains consistent across development cycles.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_parser/resources/invalid/re_lex_logical_token.py",
            "description": "This file contains various invalid Python code snippets designed to test the `ruff_python_parser` lexer and parser's ability to handle unclosed delimiters, non-logical newlines, and other syntax errors before a function definition.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/invalid/re_lex_logical_token_windows_eol.py",
            "description": "This file contains intentionally invalid Python syntax, likely used as a test case for `ruff_python_parser` to check its lexical analysis and error recovery, specifically involving logical tokens and Windows EOLs.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/invalid/re_lex_logical_token_mac_eol.py",
            "description": "This file contains intentionally invalid Python syntax, likely used as a test case for a lexer or parser to ensure correct error handling, specifically demonstrating an unexpected keyword within an expression.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/invalid/expressions/lambda_default_parameters.py",
            "description": "This file contains an invalid Python lambda expression where a non-default parameter follows a default parameter, serving as a test case for parsing errors.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/invalid/expressions/emoji_identifiers.py",
            "description": "This file contains test cases for invalid Python expressions that use emoji characters as identifiers, demonstrating syntax errors for such constructs.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/invalid/expressions/unary.py",
            "description": "This file contains an invalid Python expression using a unary operator with a walrus operator, serving as a test case for the parser's error handling.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/invalid/expressions/lambda_duplicate_parameters.py",
            "description": "This file contains a collection of invalid Python lambda expressions with duplicate parameter names or conflicting parameter declarations, used for testing a parser or linter's ability to identify such errors.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/invalid/expressions/arguments/missing_argument.py",
            "description": "This file contains an invalid Python expression demonstrating a missing argument in a function call. It is likely used as a test case for error handling in a Python parser.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/invalid/expressions/arguments/double_starred.py",
            "description": "Tests invalid syntax for double-starred arguments (** unpacking) within function calls, including combinations with `yield`, `*`, and assignment expressions (`:=`).",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/invalid/expressions/arguments/unclosed_2.py",
            "description": "This file contains an invalid Python expression with an unclosed argument list, serving as a test case for parser error handling.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/invalid/expressions/arguments/duplicate_keyword_arguments.py",
            "description": "This file contains a test case for Python code with duplicate keyword arguments in a function call, intended to demonstrate invalid syntax or parser error handling.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/invalid/expressions/arguments/invalid_expression.py",
            "description": "This file contains test cases for various invalid Python expressions used as arguments within function calls. It likely serves to test a parser's error handling for malformed argument syntax.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/invalid/expressions/arguments/unclosed_1.py",
            "description": "This file is a test case for an invalid Python expression, specifically an unclosed argument list in a function call. It's used to test error handling for syntax errors.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/invalid/expressions/arguments/invalid_order.py",
            "description": "This file contains a collection of Python code snippets demonstrating various invalid orderings of arguments within function calls, used for testing a parser's error handling.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/invalid/expressions/arguments/unclosed_0.py",
            "description": "This file is a test case for an invalid Python syntax, specifically an unclosed function call argument list, used to verify error handling in the parser.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/invalid/expressions/arguments/invalid_keyword_expression.py",
            "description": "This file contains intentionally invalid Python syntax, specifically demonstrating incorrect usage of `yield`, `yield from`, and unpacking (`*`) within keyword argument expressions. It is likely used for testing a Python parser's error handling for these specific cases.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/invalid/expressions/arguments/starred.py",
            "description": "This file contains various examples of invalid starred expressions used as arguments within function calls, likely for testing a Python parser's error handling.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/invalid/expressions/arguments/missing_expression.py",
            "description": "This file contains intentionally invalid Python code snippets demonstrating syntax errors related to missing expressions in function arguments. It likely serves as a test case for a parser or linter to ensure it correctly identifies and handles these errors.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/invalid/expressions/await/no_expression_0.py",
            "description": "This file contains an invalid Python code snippet demonstrating an `await` statement without an immediately following expression, used for testing parsing errors.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/invalid/expressions/await/no_expression_1.py",
            "description": "This file is a test case demonstrating an invalid `await` expression, specifically when `await` is not followed by an expression, leading to a syntax error.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/invalid/expressions/await/recover.py",
            "description": "Tests the parser's error recovery capabilities for various syntactically invalid `await` expressions. It includes nested awaits, starred expressions, and other invalid combinations with `await`.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/invalid/expressions/bool_op/missing_rhs.py",
            "description": "This file contains an invalid Python expression demonstrating a missing right-hand side for a boolean 'and' operator, likely used as a test case for syntax error detection.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/invalid/expressions/bool_op/starred_expression.py",
            "description": "This file contains invalid Python syntax, specifically demonstrating incorrect usage of starred expressions within boolean operations. It serves as a negative test case for the `ruff_python_parser` to ensure it correctly identifies and rejects such malformed expressions.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/invalid/expressions/bool_op/invalid_rhs_expression.py",
            "description": "This file contains intentionally invalid Python code, demonstrating improper right-hand side expressions for boolean operations (e.g., using `lambda` or `yield`) for parser testing purposes.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/invalid/expressions/bool_op/named_expression.py",
            "description": "This file contains invalid Python syntax, specifically named expressions (`:=`) used directly as operands within boolean operations (`and`, `or`). It serves as a test case for the parser to ensure these constructs are correctly identified as errors.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/invalid/expressions/bin_op/starred_expression.py",
            "description": "This file contains invalid Python syntax demonstrating binary operations with starred expressions, intended for testing a parser's error handling capabilities.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/invalid/expressions/bin_op/invalid_rhs_expression.py",
            "description": "This file contains test cases demonstrating invalid right-hand side expressions within binary operations, specifically for parser error handling.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/invalid/expressions/bin_op/named_expression.py",
            "description": "This file contains invalid Python syntax, specifically demonstrating incorrect usage of the assignment expression (walrus operator) with binary operators, likely for testing parsing error handling.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/invalid/expressions/bin_op/missing_rhs_1.py",
            "description": "This file is a test case for the Ruff Python parser, demonstrating an invalid binary operation where the right-hand side of a multiplication is missing.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/invalid/expressions/bin_op/missing_rhs_0.py",
            "description": "This file contains an invalid Python expression where a binary operator is missing its right-hand side operand, serving as a test case for parsing errors.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/invalid/expressions/bin_op/missing_lhs.py",
            "description": "This file serves as an invalid test case for `ruff_python_parser`, demonstrating a binary operation with a missing left-hand side operand.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/invalid/expressions/bin_op/multiple_ops.py",
            "description": "This file serves as a test case for a Python parser, demonstrating invalid syntax related to binary operations like `++` and `--` within expressions.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/invalid/expressions/dict/comprehension.py",
            "description": "This file contains examples of invalid dictionary comprehensions, serving as test cases for a Python parser or linter to identify syntax errors in dictionary comprehension targets, iterators, and 'if' clauses.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/invalid/expressions/dict/missing_closing_brace_2.py",
            "description": "This file is a test case for the Python parser, specifically designed to check its handling of an invalid dictionary definition with a missing closing brace.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/invalid/expressions/dict/named_expression_0.py",
            "description": "Tests an invalid syntax where an unparenthesized named expression is used as a dictionary key, which is not allowed in Python.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/invalid/expressions/dict/double_star.py",
            "description": "This file contains intentionally invalid Python code snippets demonstrating various unsupported double-star expressions within dictionary literals. It serves as a test case for `ruff_python_parser` to ensure correct handling of operator precedence for these syntax errors.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/invalid/expressions/dict/missing_closing_brace_1.py",
            "description": "This file is a test case for a Python parser, specifically designed to test the parser's error handling when encountering a dictionary literal with a missing closing brace.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/invalid/expressions/dict/recover.py",
            "description": "This file contains test cases for dictionary expressions with intentional syntax errors, designed to verify the parser's error recovery mechanisms.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/invalid/expressions/dict/double_star_comprehension.py",
            "description": "This file contains an invalid Python dictionary comprehension syntax, specifically a double-star unpacking in the key position, used as a test case for the `ruff_python_parser` to identify parsing errors.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/invalid/expressions/dict/named_expression_1.py",
            "description": "This file is a test case demonstrating an invalid syntax where unparenthesized named expressions are used directly as dictionary values, which is not allowed in Python.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/invalid/expressions/dict/missing_closing_brace_0.py",
            "description": "This file is a test resource for the `ruff_python_parser`, demonstrating an invalid dictionary expression with a missing closing brace. It is used to verify the parser's error handling for such syntax errors.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/invalid/expressions/attribute/no_member.py",
            "description": "This file contains examples of invalid Python syntax where an attribute access dot operator is used without a subsequent member name, serving as a test case for parser error handling.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/invalid/expressions/attribute/invalid_member.py",
            "description": "This file contains examples of invalid attribute member access expressions (e.g., `x.1`, `x.[0]`) used to test the `ruff_python_parser`'s error handling and validation of Python syntax.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/invalid/expressions/attribute/multiple_dots.py",
            "description": "This file contains invalid Python attribute expressions featuring multiple dots, serving as test cases for the `ruff_python_parser` to ensure proper error handling for syntax errors.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/invalid/expressions/compare/invalid_order.py",
            "description": "This file contains examples of invalid Python syntax related to comparison operators and the use of 'not' in expressions. It serves as a test case for identifying parsing errors in such scenarios.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/invalid/expressions/compare/invalid_rhs_expression.py",
            "description": "This file contains intentionally invalid Python expressions, specifically demonstrating incorrect usage of `lambda` and `yield` within comparison operations, likely for testing parsing error handling.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/invalid/expressions/compare/missing_rhs_0.py",
            "description": "This file contains an invalid Python expression missing the right-hand side of a comparison operator, used to test the parser's error handling.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/invalid/expressions/compare/starred_expression.py",
            "description": "This file contains test cases demonstrating invalid usage of starred expressions within comparison operations in Python.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/invalid/expressions/compare/missing_rhs_2.py",
            "description": "This file tests the parser's error handling for an invalid comparison expression where the right-hand side operand is missing after 'is not'.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/invalid/expressions/compare/missing_lhs.py",
            "description": "This file contains an invalid Python expression demonstrating a comparison operation with a missing left-hand side operand. It serves as a test case for the parser's error handling.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/invalid/expressions/compare/missing_rhs_1.py",
            "description": "Tests the parser's error handling for an invalid comparison expression where the 'not' operator is missing its right-hand side operand.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/invalid/expressions/compare/multiple_equals.py",
            "description": "This file demonstrates invalid Python syntax using JavaScript-style strict equality and inequality operators for comparison, serving as a test case for parsing errors.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/invalid/expressions/compare/named_expression.py",
            "description": "This file contains examples of invalid named expressions (assignment expressions using `:=`) within comparison operations, serving as test cases for a linter or parser to detect incorrect syntax.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/invalid/expressions/if/missing_orelse_expr_1.py",
            "description": "This file contains an invalid Python `if` expression with a missing `orelse` part, serving as a test case for parser error handling within the ruff_python_parser.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/invalid/expressions/if/missing_test_expr_1.py",
            "description": "This file tests the parser's error handling for an 'if' expression with a missing test condition, followed by a valid expression.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/invalid/expressions/if/missing_orelse_expr_0.py",
            "description": "This file serves as a test case for an invalid Python if expression, demonstrating a missing expression after the 'else' keyword. It's used to verify error handling in a parser or linter.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/invalid/expressions/if/missing_test_expr_0.py",
            "description": "This file serves as a test case for an invalid Python syntax, specifically demonstrating a missing test expression after an 'if' keyword. It's used to verify how a parser handles incomplete 'if' expressions.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/invalid/expressions/if/recover.py",
            "description": "This file contains intentionally invalid Python 'if' expressions, serving as test cases for a parser's error recovery or validation logic. It demonstrates various incorrect uses of '*', 'lambda', and 'yield' within conditional and alternative expression parts.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/invalid/expressions/list/missing_closing_bracket_0.py",
            "description": "This file is a test case for an invalid Python list expression, specifically demonstrating a missing closing bracket with no elements.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/invalid/expressions/list/recover.py",
            "description": "This file contains a collection of syntactically invalid Python list expressions used to test the parser's error recovery mechanisms.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/invalid/expressions/list/missing_closing_bracket_1.py",
            "description": "This file provides a test case for a Python syntax error where a list literal is opened but its closing bracket is missing, specifically when elements are on subsequent lines.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/invalid/expressions/list/missing_closing_bracket_2.py",
            "description": "This file contains an invalid Python list expression with a missing closing bracket, specifically designed as a test case for parsing errors where list elements are split across multiple lines.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/invalid/expressions/list/comprehension.py",
            "description": "This file contains examples of syntactically invalid Python list comprehensions. It is used as a test resource for a parser to ensure it correctly identifies and flags these malformed expressions.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/invalid/expressions/list/missing_closing_bracket_3.py",
            "description": "This file tests the parser's error handling for an incomplete list expression missing its closing bracket, followed by a new statement.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/invalid/expressions/list/star_expression_precedence.py",
            "description": "This file contains Python code examples to test the parsing precedence of star expressions within list literals for the `ruff_python_parser`. It demonstrates how various operators and constructs bind with the expression being starred in these contexts.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/invalid/expressions/named/missing_expression_0.py",
            "description": "This file is a test case for an invalid named expression where the value after the walrus operator is missing, used to verify the parser's error handling.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/invalid/expressions/named/missing_expression_2.py",
            "description": "This file tests the parser's error handling for an incomplete named expression where the value after the assignment operator is missing.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/invalid/expressions/named/missing_expression_4.py",
            "description": "This file is a test case for an invalid Python named expression (walrus operator) where the right-hand side of the assignment is missing, leading to a syntax error.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/invalid/expressions/named/missing_expression_3.py",
            "description": "This file is a test case for the parser, demonstrating an invalid named expression where the value to be assigned to the variable is missing or malformed.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/invalid/expressions/named/missing_expression_1.py",
            "description": "This file is a test case for an invalid Python syntax, specifically demonstrating an incomplete walrus operator expression where an operand is missing after `:=`.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/invalid/expressions/set/comprehension.py",
            "description": "Tests various invalid syntax cases for set comprehensions, including incorrect iterable unpacking, invalid targets, iterables, and conditional expressions, to ensure a parser correctly identifies these errors.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/invalid/expressions/set/missing_closing_curly_brace_2.py",
            "description": "This file is a test case designed to verify how the parser handles an invalid set expression with a missing closing curly brace, specifically when elements are placed on separate lines.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/invalid/expressions/set/missing_closing_curly_brace_1.py",
            "description": "This file is a test case demonstrating a Python set expression with a missing closing curly brace, specifically when elements are on a new line.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/invalid/expressions/set/recover.py",
            "description": "This file contains test cases for the Python parser's error recovery mechanism when encountering various invalid set expressions. It includes examples of syntax errors in set literals to verify the parser's ability to recover.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/invalid/expressions/set/missing_closing_curly_brace_3.py",
            "description": "This file is a test case designed to verify the parser's error handling for an incomplete set literal, specifically when a closing curly brace is missing after multiple elements and before a new statement begins.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/invalid/expressions/set/missing_closing_curly_brace_0.py",
            "description": "This file is a test case designed to verify how the Python parser (likely Ruff's) handles an invalid set expression where the closing curly brace is missing.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/invalid/expressions/set/star_expression_precedence.py",
            "description": "This file contains test cases for the `ruff_python_parser` to validate its handling of star expressions within set literals. It specifically checks the parser's understanding of operator precedence rules that lead to invalid constructs.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/invalid/expressions/parenthesized/missing_closing_paren_0.py",
            "description": "This file serves as a test case for the Ruff parser, specifically to verify its handling of invalid Python expressions where a parenthesized expression is opened but never closed, with no elements inside.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/invalid/expressions/parenthesized/missing_closing_paren_1.py",
            "description": "This file is a test case for the `ruff_python_parser` that demonstrates a syntax error: a missing closing parenthesis in a parenthesized expression.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/invalid/expressions/parenthesized/missing_closing_paren_2.py",
            "description": "Tests the parser's error handling for an incomplete parenthesized expression (tuple) missing a closing parenthesis, where elements are split across lines.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/invalid/expressions/parenthesized/parenthesized.py",
            "description": "This file contains test cases for invalid parenthesized expressions in Python, specifically demonstrating that a starred expression is not allowed within parentheses.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/invalid/expressions/parenthesized/tuple.py",
            "description": "This file contains a collection of invalid Python tuple expressions designed to test the parser's error recovery mechanisms and its handling of syntax errors within parenthesized tuple constructs.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/invalid/expressions/parenthesized/missing_closing_paren_3.py",
            "description": "This file is an invalid Python code example demonstrating a missing closing parenthesis in a parenthesized expression, specifically a tuple-like structure without a trailing comma, immediately preceding a new statement. It is used to test parser error handling.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/invalid/expressions/parenthesized/tuple_starred_expr.py",
            "description": "This file contains test cases for `ruff_python_parser`, specifically demonstrating invalid or edge-case starred expressions within tuple contexts. It aims to test the parser's handling of operator precedence and binding power when starred expressions are used.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_parser/resources/invalid/expressions/subscript/unclosed_slice_0.py",
            "description": "This file tests the parser's ability to handle an unclosed slice within a subscript expression, specifically `x[:]`, which is syntactically invalid Python.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/invalid/expressions/subscript/invalid_slice_element.py",
            "description": "This file contains various examples of invalid Python slice syntax, including named expressions, starred expressions, and empty slices. It likely serves as a test fixture for a parser to ensure it correctly identifies and rejects these syntactically incorrect slice elements.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/invalid/expressions/subscript/unclosed_slice_1.py",
            "description": "This file is a test case demonstrating an invalid Python expression: an unclosed slice in a subscript. It's used to verify error handling for syntax errors.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/invalid/expressions/unary/named_expression.py",
            "description": "This file contains intentionally invalid Python code demonstrating incorrect usage of the named expression (walrus) operator with unary operators for testing purposes.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/invalid/expressions/unary/no_expression_0.py",
            "description": "This file tests the parser's error handling for an invalid unary expression where the `not` operator is not followed by an operand. It is part of a suite of tests for invalid Python expressions.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/invalid/expressions/yield/star_expression.py",
            "description": "This file contains examples of invalid Python syntax, specifically demonstrating incorrect usage of starred expressions within 'yield' statements. It serves as a test case for a parser to ensure it correctly identifies and reports these syntax errors.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/invalid/expressions/yield/named_expression.py",
            "description": "This file contains test cases demonstrating invalid Python syntax where unparenthesized named expressions are used directly within `yield` statements, likely for a parser to detect and flag errors.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/invalid/expressions/yield_from/starred_expression.py",
            "description": "This file contains invalid Python syntax demonstrating that `yield from` does not support top-level starred expressions, unlike `yield`. It serves as a test case for a parser to identify this specific syntax error.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/invalid/expressions/yield_from/unparenthesized.py",
            "description": "This file contains examples of `yield from` statements with unparenthesized expressions, serving as test cases for a Python parser's error detection or syntax validation.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/invalid/re_lexing/line_continuation_1.py",
            "description": "This file is a test case for the Python parser, specifically demonstrating an invalid re-lexing scenario involving an incorrect line continuation with a trailing backslash.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/invalid/re_lexing/ty_1828.py",
            "description": "This file is a regression test for a parsing issue (ty/issues/1828) in `ruff_python_parser`. It contains intentionally invalid Python syntax designed to trigger a specific lexing or parsing error.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/invalid/re_lexing/triple_quoted_fstring_2.py",
            "description": "This file serves as a test case for a known lexer bug in Ruff, specifically demonstrating an issue with malformed triple-quoted f-strings where a newline incorrectly breaks the format specifier.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/invalid/re_lexing/line_continuation_windows_eol.py",
            "description": "This file is a test case demonstrating an invalid Python syntax involving a line continuation with a comment and Windows-style EOL, designed to test the parser's error handling.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/invalid/re_lexing/triple_quoted_fstring_1.py",
            "description": "This file is an invalid Python test case for `ruff_python_parser` specifically designed to test re-lexing behavior with a triple-quoted f-string containing a comment and trailing whitespace, as per GitHub issue #11929.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/invalid/re_lexing/fstring_format_spec_1.py",
            "description": "This file contains test cases for f-string lexing, specifically focusing on how escaped newlines within format specifications are handled. It aims to ensure the lexer correctly processes these scenarios without issues related to position tracking, addressing a known bug.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/invalid/re_lexing/triple_quoted_fstring_3.py",
            "description": "This file is an invalid test case for the parser's error recovery when an unclosed f-string expression `{` occurs within a triple-quoted f-string. It specifically checks the handling of nesting levels during recovery without re-lexing.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/invalid/statements/if_extra_closing_parentheses.py",
            "description": "This file contains an intentionally invalid Python `if` statement with extra closing parentheses, serving as a test case for `ruff_python_parser` to evaluate its error handling for syntax errors.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/invalid/statements/if_extra_indent.py",
            "description": "This file is a test case for a Python parser, demonstrating an 'if' statement with incorrect, extra indentation within its block. It is designed to test how the parser handles such invalid syntax, specifically an extra indent after a `pass` statement.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/invalid/statements/function_type_parameters.py",
            "description": "This file contains invalid Python function type parameter syntax, serving as a test case to evaluate the `ruff_python_parser`'s error recovery mechanisms and error reporting for malformed type parameter lists.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/invalid/statements/with/unclosed_ambiguous_lpar.py",
            "description": "This file contains an intentionally invalid 'with' statement with an unclosed parenthesis, designed to test the parser's error handling for syntax errors.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/invalid/statements/with/empty_with_items.py",
            "description": "This file is a test case for the Python parser, specifically designed to check error recovery when encountering a 'with' statement with no items. It demonstrates an invalid 'with' syntax that the parser should gracefully handle.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/invalid/statements/with/unparenthesized_with_items.py",
            "description": "This file contains test cases for invalid Python `with` statements that feature unparenthesized or otherwise syntactically incorrect `with` items. It serves to verify error handling for such malformed constructs.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/invalid/statements/with/ambiguous_lpar_with_items.py",
            "description": "This file contains test cases for the Python parser, specifically focusing on `with` statements with ambiguous or invalid syntax in their item lists. It aims to ensure the parser correctly identifies and reports syntax errors for these cases.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/invalid/statements/match/invalid_class_pattern.py",
            "description": "This file contains examples of invalid class patterns within `match` statements, specifically demonstrating incorrect keyword pattern usage in class arguments.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/invalid/statements/match/star_pattern_usage.py",
            "description": "This file contains a collection of invalid Python `match` statements demonstrating incorrect usage of the star pattern (`*`) outside of sequence patterns, intended for testing a parser's error detection.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/invalid/statements/match/as_pattern_4.py",
            "description": "This file tests a `match` statement with an unparenthesized `as` pattern used as a mapping key, ensuring the parser correctly handles it without confusing it for a mapping key pattern.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/invalid/statements/match/invalid_lhs_or_rhs_pattern.py",
            "description": "This file contains intentionally invalid Python `match` statement patterns, specifically demonstrating cases where arithmetic operations are used incorrectly within pattern matching on both the left and right-hand sides, serving as a test case for a linter or parser.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/invalid/statements/match/as_pattern_3.py",
            "description": "This file serves as an invalid test case for Python's `match` statement, specifically demonstrating an `as` pattern used incorrectly within a mapping pattern.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/invalid/statements/match/unary_add_usage.py",
            "description": "Tests how the parser handles and recovers from invalid unary addition syntax within `match` statements for improved error reporting.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/invalid/statements/match/as_pattern_1.py",
            "description": "This file tests the parser's ability to correctly identify an invalid 'as-pattern' usage within a complex literal (specifically a sum with an imaginary number) inside a match statement. It serves as an invalid test case for the `ruff_python_parser`.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/invalid/statements/match/invalid_mapping_pattern.py",
            "description": "This file contains examples of various invalid `match` statement mapping patterns, including disallowed starred expressions and incorrect usage of double-star patterns, likely for testing a Python parser's error handling.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/invalid/statements/match/as_pattern_2.py",
            "description": "This file is a test case demonstrating a `match` statement with an unparenthesized `as` pattern involving a complex expression. It verifies that the parser correctly interprets this pattern without confusing it for a complex literal.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/invalid/statements/match/as_pattern_0.py",
            "description": "This file is a parser test case for Python's match statement. It verifies that an \"as-pattern\" within a case statement is correctly parsed and not confused with a class pattern.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/valid/expressions/await.py",
            "description": "This file contains a collection of valid 'await' expressions, likely serving as test cases for the Python parser to ensure correct handling of the 'await' keyword in different contexts.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/valid/expressions/attribute.py",
            "description": "This file contains valid Python attribute access and method call expressions, likely serving as a test case for a parser to ensure correct handling of these constructs.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/valid/expressions/dictionary.py",
            "description": "This file provides a collection of valid Python dictionary expressions, showcasing various syntaxes like nesting, unpacking, lambda expressions, and named expressions. It likely serves as a test resource for a Python parser to validate dictionary parsing.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/valid/expressions/bin_op.py",
            "description": "This file contains various valid Python expressions demonstrating binary operations, covering different operators, precedence, associativity, and a non-standard `++` operator for parser testing.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/valid/expressions/bool_op.py",
            "description": "This file contains a collection of valid Python boolean expressions, demonstrating various combinations of 'and', 'or', and 'not' operators. It serves as a test resource for the `ruff_python_parser` to ensure correct parsing of boolean logic.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/valid/expressions/if.py",
            "description": "This file contains various valid examples of Python's conditional expressions (ternary operator) for parsing validation within the ruff_python_parser.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/valid/expressions/parenthesized.py",
            "description": "This file contains a collection of valid Python expressions enclosed in parentheses, serving as test cases for the parser's ability to handle various parenthesized constructs including calls, logical operations, lambdas, assignment expressions, and yield statements.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/valid/expressions/slice.py",
            "description": "This file contains various valid Python slice expressions, demonstrating different combinations of start, stop, and step values, including slices with named expressions and multiple slice elements, likely for testing or examples.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/valid/expressions/tuple.py",
            "description": "This file contains various valid Python tuple expressions, demonstrating different ways to define tuples including with/without parentheses, starred expressions, and named expressions.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/valid/expressions/call.py",
            "description": "This file contains various Python call expressions, including valid ones and those that would result in a TypeError at runtime, to test the parser's handling of the expression preceding the call parentheses.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/valid/expressions/list.py",
            "description": "This file contains a collection of valid Python list expression examples, designed as a resource for testing a Python parser's ability to handle various list literal syntaxes, including nested lists, named expressions, and star expressions.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/valid/expressions/number_literal.py",
            "description": "This file contains various valid Python number literals, including integers, floats, complex numbers, and different bases, along with examples of attribute access on these literals. It serves to test the parser's handling of diverse number literal syntaxes and related operations.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/valid/expressions/lambda.py",
            "description": "This file contains a collection of valid Python lambda expressions, showcasing various parameter combinations including positional, keyword, default, varargs, kwargs, positional-only, and keyword-only arguments. It likely serves as a test resource for a parser or linter.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/valid/expressions/arguments.py",
            "description": "This file contains a comprehensive collection of Python function call examples, showcasing various argument types, ordering, and syntax including keyword expressions, yield expressions, named expressions, starred expressions, and double-starred expressions.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/valid/expressions/string.py",
            "description": "This file contains various valid string literal definitions, including single-quoted, double-quoted, triple-quoted, concatenated, and byte strings. It likely serves as a test case for a Python parser's string handling capabilities.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/valid/expressions/yield.py",
            "description": "This file contains a collection of valid Python yield expressions, serving as test cases or examples for a parser to ensure correct handling of different yield statement forms.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_parser/resources/valid/expressions/list_comprehension.py",
            "description": "This file serves as a collection of valid Python list comprehensions, showcasing various syntax complexities including `if` clauses, `async for`, `await`, and nested expressions. It is used as a test resource for the `ruff_python_parser` to validate its parsing capabilities for list comprehensions.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/valid/expressions/subscript.py",
            "description": "This file contains various valid Python expressions demonstrating different forms of subscripting, including simple indexing, slicing, extended slicing, assignment expressions, and starred expressions within `data[...]` constructs. It likely serves as a test resource for a Python parser or linter.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/valid/expressions/named.py",
            "description": "This file serves as a test resource for the `ruff_python_parser`, demonstrating various valid syntaxes and uses of the assignment expression (walrus operator `:=`) in Python.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/valid/expressions/name.py",
            "description": "This file provides a collection of valid Python identifiers and names, including standard names, dunders, and soft keywords, used as a test resource for the `ruff_python_parser` to ensure correct parsing of name expressions.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/valid/expressions/set.py",
            "description": "This file contains various valid Python set literal expressions, including simple sets, nested sets, sets with named expressions, star expressions, and other complex expressions. It serves as a test case for validating the parser's ability to handle different set syntaxes.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/valid/expressions/dictionary_comprehension.py",
            "description": "This file contains a collection of valid Python dictionary comprehension examples, demonstrating various syntax forms including nested loops, conditional clauses, and parenthesized `yield` and `lambda` expressions within iterables or conditions. It serves as a test case for a Python parser to ensure correct handling of these constructs.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/valid/expressions/compare.py",
            "description": "This file contains a collection of valid Python comparison expressions. It serves as a test resource for `ruff_python_parser` to validate its parsing of various comparison operators and their precedence.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/valid/expressions/starred.py",
            "description": "This file contains valid Python syntax examples demonstrating the use of the starred expression (`*`), including unpacking in general expressions and its application in extended slice syntax for array indexing.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/valid/expressions/yield_from.py",
            "description": "Tests various valid forms of the `yield from` expression for a Python parser. It includes different operand types such as variables, binary operations, function calls, and collection literals.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/valid/expressions/f_string.py",
            "description": "This file provides a collection of valid f-string examples, demonstrating various syntaxes, expressions, format specifiers, conversion flags, and concatenation patterns. It likely serves as a test resource for a Python parser.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/valid/expressions/unary_op.py",
            "description": "This file contains valid Python code snippets demonstrating various unary operators (`-`, `+`, `~`, `not`) and their precedence. It is likely used as a test resource for a Python parser to ensure correct handling of unary expressions.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/valid/expressions/set_comprehension.py",
            "description": "This file contains various examples of valid Python set comprehension syntax. It demonstrates different forms of comprehensions, including nested loops and conditional clauses, and specifically tests parsing with parenthesized `yield`, `yield from`, and `lambda` expressions within comprehension clauses.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/valid/expressions/t_string.py",
            "description": "This file contains a comprehensive collection of 't-string' (template string) examples, similar to f-strings, designed to test the parser's ability to handle various valid and complex syntaxes, including formatting, conversions, and nesting.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/valid/statement/augmented_assignment.py",
            "description": "This file contains various examples of augmented assignment statements in Python, demonstrating different operators and operand types. It likely serves as a test case for a Python parser or linter.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/valid/statement/return.py",
            "description": "This file contains a collection of valid Python `return` statements, demonstrating various syntax forms and expressions that can be used with the `return` keyword.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_parser/resources/valid/statement/annotated_assignment.py",
            "description": "This file contains various valid examples of annotated assignment statements in Python. It serves as a test case for parsing different forms of type annotations during variable assignment.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/valid/statement/delete.py",
            "description": "This file contains various valid Python `del` statements, serving as a test resource for the ruff_python_parser to ensure correct parsing of delete statements with different target types and structures.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/valid/statement/from_import.py",
            "description": "This file contains various valid Python `from ... import ...` statements, serving as a test case for a parser or linter to ensure correct handling of different import syntax.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/valid/statement/import.py",
            "description": "This file contains various valid Python import statements, likely serving as test cases for a Python parser or linter to ensure correct parsing of different import syntaxes.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/valid/statement/if.py",
            "description": "This file contains a collection of valid `if`, `elif`, and `else` statement syntax examples, serving as a test resource for a Python parser.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/valid/statement/assert.py",
            "description": "This file contains a collection of valid Python `assert` statements, demonstrating various forms including single and two-argument assertions with different types of expressions. It serves as a test resource for a Python parser to validate correct parsing of `assert` statements.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/valid/statement/class.py",
            "description": "This file provides various valid Python class definitions, including basic classes, inheritance, methods, and numerous examples of generic type parameters (TypeVar, TypeVarTuple, ParamSpec) and their variations. It serves as a resource for testing a Python parser's ability to handle diverse class statement syntax.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/valid/statement/raise.py",
            "description": "This file contains various examples of valid `raise` statements in Python, including those with and without `from` clauses. It likely serves as a test case for a Python parser or linter to ensure correct handling of `raise` statement syntax.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/valid/statement/type.py",
            "description": "This file contains a collection of Python 'type' statements, demonstrating various forms of type aliases, generic type aliases, type variables, soft keyword usage, and multi-line definitions. It serves as a comprehensive test case for parsing and interpreting the 'type' keyword and statements.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/valid/statement/for.py",
            "description": "This file contains a collection of valid Python `for` loop statement examples. It serves as a test resource for a Python parser to validate the correct parsing of diverse `for` loop syntaxes.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_parser/resources/valid/statement/assignment.py",
            "description": "This file demonstrates various valid Python assignment statements, including unpacking, attribute assignment, and subscript assignment. It serves as a test case for a Python parser, ensuring that syntactically valid assignments (even those leading to runtime errors) are parsed correctly.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_parser/resources/valid/statement/with.py",
            "description": "This file provides various valid Python 'with' statement examples, specifically focusing on unparenthesized 'with' items, to test the parser's handling of different 'with' clause structures.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/valid/statement/ambiguous_lpar_with_items.py",
            "description": "This file contains test cases for the Python parser, specifically focusing on the ambiguous parsing of 'with' statements that start with a left parenthesis. It demonstrates how the parser distinguishes between parenthesized 'with' items, parenthesized context expressions, and tuple expressions.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/valid/statement/function.py",
            "description": "This file contains a comprehensive collection of valid Python function definitions, demonstrating various parameter types, including positional, keyword-only, default values, `*args`, `**kwargs`, positional-only `/`, and type parameters.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/valid/statement/simple.py",
            "description": "This file contains a collection of valid simple Python statements, intended as a test resource for the `ruff_python_parser` to ensure correct parsing of various basic language constructs.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/valid/statement/match.py",
            "description": "This file contains a comprehensive collection of valid Python `match` statement syntax examples, showcasing various pattern matching constructs, including literal, sequence, mapping, class, and AS patterns. It serves as a test suite for validating a Python parser's support for the `match` statement and its intricacies.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/valid/statement/try.py",
            "description": "This file contains a comprehensive collection of Python `try` statements, demonstrating various combinations of `except`, `finally`, and `else` clauses, including `except*` for exception groups and syntactically valid but semantically incorrect exception types. It serves as a test resource for a Python parser to validate its handling of diverse `try` block structures.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/valid/statement/while.py",
            "description": "This file serves as a collection of valid Python `while` loop syntax examples, likely used for testing a Python parser's ability to correctly interpret different `while` statement structures, including `else` clauses and assignment expressions.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/valid/other/decorator.py",
            "description": "This file contains a collection of Python examples showcasing various valid decorator syntaxes for functions and classes, including chained decorators and decorators using different expression types.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/valid/other/atom.py",
            "description": "This file serves as a test resource for the `ruff_python_parser`, verifying the correct parsing of Python's boolean and None literals (`True`, `False`, `None`).",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/ok/decorator_async_function.py",
            "description": "Tests the parsing of an asynchronous function decorated with a decorator. It likely serves as a valid syntax example for a Python parser.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/ok/class_def_arguments.py",
            "description": "This file contains valid Python class definitions, demonstrating the acceptance of classes declared with and without empty parentheses in a parser's 'ok' test suite.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/ok/async_function_definition.py",
            "description": "This file contains a minimal, valid asynchronous function definition, likely serving as a positive test case for the `ruff_python_parser` to ensure correct parsing of async function syntax.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/ok/async_with_statement.py",
            "description": "This file contains an example of a valid asynchronous 'with' statement, likely used as a test case for parsing Python syntax.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/ok/decorator_expression_identity_hack_py38.py",
            "description": "Tests parsing of decorator expressions using an identity decorator with a complex attribute access, specifically for Python 3.8 target version.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/ok/dotted_name_normalized_spaces.py",
            "description": "Tests the Python parser's ability to handle dotted names in import statements, specifically focusing on whitespace normalization between dots and name parts. It includes examples with and without extra spaces.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/ok/class_type_params_py312.py",
            "description": "This file tests the parser's ability to handle class definitions with type parameters, including TypeVarTuple and ParamSpec syntax, introduced in Python 3.12.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/ok/all_async_comprehension_py310.py",
            "description": "This file contains a Python 3.10 specific test case demonstrating nested asynchronous comprehensions. It serves as an example for parsing or type-checking such syntax.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/ok/comma_separated_regular_list_terminator.py",
            "description": "This file contains test cases for a Python parser, demonstrating various comma-separated list expressions, including those with and without trailing commas. It validates the parser's handling of list termination.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/ok/class_keyword_in_case_pattern.py",
            "description": "Tests the parser's ability to correctly handle the use of 'Class' as an identifier in a `case` pattern, ensuring it is not mistakenly treated as a keyword. This is an 'ok' test case for valid syntax.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/ok/from_import_stmt_terminator.py",
            "description": "Tests the parsing of `from ... import ...` statements, including those with same-line statements and multi-line continuations.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/ok/iter_unpack_return_py37.py",
            "description": "Tests or demonstrates tuple unpacking within a function's return statement, specifically targeting Python 3.7 syntax and behavior.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/ok/except_stmt_as_name_soft_keyword.py",
            "description": "This file tests the Python parser's ability to handle soft keywords like `match`, `case`, and `type` when used as exception names in `except` statements.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/ok/for_iter_unpack_py38.py",
            "description": "This file contains test cases demonstrating various forms of iterable unpacking within 'for' loop iterations, specifically targeting Python 3.8 syntax for the ruff_python_parser.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/ok/from_import_soft_keyword_module_name.py",
            "description": "This file tests that the parser correctly handles `from ... import ...` statements where the module names are Python soft keywords like `match`, `type`, and `case`.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/ok/fstring_format_spec_terminator.py",
            "description": "This file contains valid f-string expressions, including cases with and without format specifiers, specifically testing the parser's handling of format specifier terminators. It serves as a positive test case for `ruff_python_parser`.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/ok/async_for_statement.py",
            "description": "This file contains a simple `async for` statement, serving as a valid inline code example for testing the Python parser within the Ruff project.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/ok/import_stmt_terminator.py",
            "description": "This file serves as a test case for `ruff_python_parser`, demonstrating valid Python import statement parsing, including those terminated or separated by semicolons.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/ok/ambiguous_lpar_with_items_binary_expr.py",
            "description": "This file contains test cases to ensure the `ruff_python_parser` correctly parses various binary expressions within `with` statements, specifically checking operator precedence and parsing of ambiguous parentheses.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/ok/decorator_await_expression_py39.py",
            "description": "This file is a Python 3.9 test case for `ruff_python_parser`, demonstrating the use of `await` within a decorator expression. It checks if the parser correctly handles this specific syntax.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/ok/import_as_name_soft_keyword.py",
            "description": "This file tests the Python parser's ability to handle imports where soft keywords like 'match', 'case', and 'type' are used as aliases, ensuring they are correctly parsed in this context.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/ok/function_def_parameter_range.py",
            "description": "This file provides a valid Python function definition with typed parameters and a return type, serving as a test case for the `ruff_python_parser` to ensure correct parsing of function signature syntax.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/ok/decorator_expression_py39.py",
            "description": "This file demonstrates Python 3.9 decorator expressions, including one that uses an assignment expression (walrus operator), likely for parser testing.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/ok/iter_unpack_yield_py37.py",
            "description": "This file contains a Python generator function demonstrating iterable unpacking (`*rest`) within a `yield` statement, specifically targeting Python 3.7.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/ok/except_star_py311.py",
            "description": "This file is a test case for the Python 3.11 `except*` (exception group) syntax, confirming its valid parsing by `ruff_python_parser`.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/ok/match_stmt_valid_guard_expr.py",
            "description": "This file contains examples of Python `match` statements demonstrating various valid guard expressions within `case` clauses, including assignment, conditional, lambda, and yield expressions.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/ok/assign_stmt_starred_expr_value.py",
            "description": "This file contains test cases for the Python parser, specifically verifying its ability to correctly parse assignment statements where the assigned value includes a starred expression, both with and without explicit tuple parentheses.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/ok/match_sequence_pattern_parentheses_terminator.py",
            "description": "Tests the Python parser's handling of `match` statements with sequence patterns using both list and tuple delimiters. It confirms that both `[a, b]` and `(a, b)` are recognized as valid sequence patterns.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/ok/function_def_parenthesized_return_types.py",
            "description": "This file demonstrates valid syntax for function definitions where the return type annotation is a parenthesized tuple, used for testing a Python parser.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/ok/nonlocal_declaration_at_module_level.py",
            "description": "Tests for a `nonlocal` declaration made at the module level, which is a syntax error.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/ok/lambda_with_valid_body.py",
            "description": "This file contains a collection of valid Python lambda expressions, serving as a test resource for a Python parser to ensure correct handling of various lambda syntaxes.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/ok/multiple_assignment_in_case_pattern.py",
            "description": "Tests a `match` statement with multiple patterns in a single `case` that include variable assignment, specifically demonstrating 'multiple assignment in case pattern' for parser validation.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/ok/function_def_valid_return_expr.py",
            "description": "This file contains examples of Python function definitions with various valid return type annotations, including type unions, lambda expressions, and conditional expressions. It serves as a test case for the `ruff_python_parser` to ensure correct parsing of complex return type expressions.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/ok/iter_unpack_return_py38.py",
            "description": "Tests parsing of iterable unpacking in a return statement, specifically for Python 3.8 syntax. It ensures that unpacking `*rest` within a tuple in a return statement is correctly handled.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/ok/ambiguous_lpar_with_items_if_expr.py",
            "description": "Tests the Python parser's ability to correctly handle `with` statements where the context manager is a conditional expression containing parenthesized items that could be ambiguous in the 'true' branch.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/ok/iter_unpack_yield_py38.py",
            "description": "This file serves as a test case for parsing Python 3.8 syntax, specifically demonstrating iterable unpacking within `yield` expressions in generator functions.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/ok/match_after_py310.py",
            "description": "This file is a test case for the Ruff Python parser, verifying its ability to correctly parse 'match' statements introduced in Python 3.10.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/ok/duplicate_match_key_attr.py",
            "description": "Tests the Python parser's ability to handle match statements containing duplicate attribute keys within a single mapping pattern, expecting it to parse successfully without syntax errors.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/ok/function_type_params_py312.py",
            "description": "This file tests the parsing of Python 3.12's new function type parameter syntax, specifically demonstrating a function with a type variable in its definition.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/ok/match_as_pattern_soft_keyword.py",
            "description": "This file contains test cases for the Python parser, specifically validating its ability to correctly handle soft keywords ('case', 'match', 'type') when used as pattern names within 'match' statements.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/ok/nested_async_comprehension_py311.py",
            "description": "This file contains test cases demonstrating asynchronous comprehensions (list, dict, and set) nested within regular comprehensions, targeting Python 3.11 features.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/ok/lambda_with_no_parameters.py",
            "description": "This file contains a simple Python lambda expression that takes no parameters and returns the integer 1. It likely serves as a valid test case for a Python parser, demonstrating the parsing of parameterless lambda functions.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/ok/global_stmt.py",
            "description": "This file contains examples of valid `global` statements, likely used as a test case for the `ruff_python_parser` to ensure correct parsing of this syntax.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/ok/irrefutable_case_pattern_at_end.py",
            "description": "This file contains test cases demonstrating the behavior of Python's `match` statement, specifically when using irrefutable case patterns (`var`, `_`) at the end of a `match` block.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/ok/except_stmt_unparenthesized_tuple_no_as_py314.py",
            "description": "Tests parsing of `except` and `except*` statements with unparenthesized exception tuples and no `as` clause, specifically for Python 3.14 syntax. This file is expected to parse successfully ('ok').",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/ok/for_iter_unpack_py39.py",
            "description": "This file demonstrates valid Python 3.9 syntax for unpacking iterables using starred expressions within `for` loop iterators. It serves as a test case for the `ruff_python_parser`.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/ok/match_stmt_subject_expr.py",
            "description": "Tests various valid and invalid subject expressions within Python `match` statements, including assignment expressions (walrus operator) and `await` expressions, likely for parser validation.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/ok/from_import_no_space.py",
            "description": "This file demonstrates valid relative import statements missing spaces between 'from', '.', and 'import', which the parser should correctly handle.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/ok/import_from_star.py",
            "description": "This file contains a Python star import statement, `from module import *`, serving as a test case for the `ruff_python_parser` to ensure correct parsing of such syntax.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/ok/nonlocal_stmt.py",
            "description": "This file provides examples of valid `nonlocal` statements within a function, likely used as a test case for a Python parser or linter to ensure correct syntax handling.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/ok/nested_alternative_patterns.py",
            "description": "This file contains various `match` statements demonstrating complex and nested alternative patterns, including dictionary, list, and AST node patterns. It likely serves as a test case for validating the correct parsing of such intricate `case` constructs in a Python parser.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/ok/parenthesized_context_manager_py39.py",
            "description": "Tests the parsing of parenthesized context managers, a feature introduced in Python 3.9.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/ok/parenthesized_named_expr_py38.py",
            "description": "This file contains Python 3.8 code demonstrating parenthesized named expressions (walrus operator) within set literals and set comprehensions. It serves as a test case to ensure the parser correctly handles these language features.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/ok/parenthesized_star_index_py310.py",
            "description": "This file is a test case demonstrating the use of parenthesized star expressions within an index in Python 3.10, likely for parsing validation.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/ok/match_sequence_pattern_terminator.py",
            "description": "This file contains a Python `match` statement demonstrating various `case` patterns, including sequence patterns, `if` guards, and implicit terminators. It likely serves as a test case for a Python parser to validate correct parsing of such constructs.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/ok/match_classify_as_keyword_or_identifier.py",
            "description": "This file tests the classification of the 'match' token within a Python parser, distinguishing between its use as a keyword to initiate a match statement and its use as a regular identifier.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/ok/params_non_default_after_star.py",
            "description": "Tests valid Python syntax for function definitions where non-default parameters appear after a star or star-args argument.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/ok/param_with_annotation.py",
            "description": "This file contains example Python function definitions showcasing various parameter annotations. It serves as a test case for `ruff_python_parser` to validate the correct parsing of annotated function parameters.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/ok/match_classify_as_keyword_1.py",
            "description": "Tests the `ruff_python_parser` to ensure it correctly parses various non-keyword expressions as subjects of `match` statements, verifying proper classification of identifiers and literals.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/ok/match_classify_as_identifier_2.py",
            "description": "This file provides various Python syntax examples where the word 'match' appears in contexts other than a 'match' statement. It likely serves as a test case for a parser, ensuring that 'match' is correctly classified as an identifier or part of an expression when not used as a keyword.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/ok/match_classify_as_keyword_2.py",
            "description": "Tests the Python parser's ability to correctly handle `match` statements where the subject is a Python keyword like `match`, `case`, `type`, `None`, `True`, or `False`.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/ok/decorator_expression_dotted_ident_py38.py",
            "description": "This file is a test case for the Ruff Python parser, specifically designed to verify the correct parsing of decorators with dotted identifiers in Python 3.8 syntax. It demonstrates a function decorated using a multi-part attribute access.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/ok/different_match_pattern_bindings.py",
            "description": "Tests the Python parser's handling of `match` statements with alternative patterns, specifically focusing on cases with identical or slightly different variable bindings within a single pattern.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/ok/non_duplicate_type_parameter_names.py",
            "description": "This file contains various valid Python type parameter declarations for aliases, functions, and classes, used as a test fixture for `ruff_python_parser`. It specifically demonstrates non-duplicate type parameter names within their respective scopes.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/ok/param_with_default.py",
            "description": "This file contains test cases for the Python parser, demonstrating various complex expressions used as default values for function parameters, including lambdas, conditional expressions, await expressions, and yield expressions.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/ok/tuple_context_manager_py38.py",
            "description": "Tests the `ruff_python_parser`'s ability to correctly parse a Python 3.8 `with` statement utilizing a tuple as a context manager.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/ok/decorator_expression_eval_hack_py38.py",
            "description": "This Python 3.8 test file for `ruff_python_parser` evaluates the parsing of a function decorated with an `eval` expression, demonstrating a specific \"hacky\" decorator usage.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/ok/type_param_type_var.py",
            "description": "This file contains test cases for type alias definitions using the `type` keyword with various type parameter configurations, including default values and bounds. It appears to validate the parsing of different `TypeVar`-like syntaxes within `type` aliases.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/ok/valid_future_feature.py",
            "description": "This file contains a simple 'from __future__ import annotations' statement, likely serving as a test case for a Python parser to ensure correct handling of future imports.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/ok/nested_async_comprehension_py310.py",
            "description": "This file is a test case for `ruff_python_parser` demonstrating valid nested asynchronous comprehensions. It is specifically configured for Python 3.10.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/ok/unparenthesized_named_expr_index_py39.py",
            "description": "This file tests the parser's ability to handle named expressions (walrus operator) within an index expression, a feature supported from Python 3.9 onwards.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/ok/parenthesized_named_expr_index_py38.py",
            "description": "Tests the Python parser's ability to correctly parse a parenthesized named expression (walrus operator) used as an index, specifically for Python 3.8 syntax.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/ok/type_param_param_spec.py",
            "description": "This file contains test cases demonstrating the use of `ParamSpec` (represented by `**P`) within type parameter lists for type aliases, including default values. It likely serves as a validation resource for a Python parser.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/ok/pep750_t_string_py314.py",
            "description": "This file contains test cases for parsing PEP 750 t-strings (typing.Text strings) in Python 3.14. It demonstrates various valid t-string syntaxes, including nested quotes, escape sequences, multi-line expressions, and arbitrary nesting.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/ok/type_param_type_var_tuple.py",
            "description": "Contains valid inline examples of type parameter list syntax, specifically demonstrating `TypeVarTuple` usage with and without default values.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/ok/single_parenthesized_item_context_manager_py38.py",
            "description": "Tests the parser's ability to handle valid parenthesized, multi-line context managers in `with` statements, a feature introduced in Python 3.8.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/ok/star_index_py311.py",
            "description": "This file demonstrates various uses of star expressions (`*`) for generalized unpacking in indexing and generic type hints, a feature introduced in Python 3.11.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/ok/match_attr_pattern_soft_keyword.py",
            "description": "This file tests the Python parser's ability to correctly handle `match` statements where soft keywords like `match`, `case`, and `type` are used as identifiers within attribute patterns. It serves as a valid test case for `ruff_python_parser`.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/ok/non_nested_quote_in_format_spec_py311.py",
            "description": "Tests the `ruff_python_parser`'s ability to correctly parse an f-string containing an empty, single-quoted format specifier, specifically targeting Python 3.11 syntax.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/ok/params_seen_keyword_only_param_after_star.py",
            "description": "This file provides examples of valid Python function definitions that use keyword-only parameters after a star argument, followed by arbitrary keyword arguments (`**kwargs`). It demonstrates correct syntax for such parameter combinations.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/ok/pos_only_py38.py",
            "description": "This file tests the Python 3.8 syntax for positional-only arguments using the `/` separator, ensuring the parser correctly handles this feature.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/ok/match_classify_as_identifier_1.py",
            "description": "Tests the Ruff Python parser's ability to correctly classify 'match' as an identifier when it appears in an expression rather than as the start of a `match` statement. This file ensures that `match` is not incorrectly parsed as a keyword in this context.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/ok/type_stmt_py312.py",
            "description": "This file tests the `ruff` Python parser's ability to correctly parse a Python 3.12 type alias statement (`type x = int`), which is expected to succeed.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/ok/walrus_py38.py",
            "description": "Tests parsing of the walrus operator (assignment expression) in Python 3.8, confirming it is valid syntax for this target version.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/ok/simple_stmts_with_semicolons.py",
            "description": "This file serves as a test case for a Python parser, demonstrating multiple simple statements separated by semicolons on a single line, including return, import, and type statements.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/ok/pep701_f_string_py311.py",
            "description": "This file contains a collection of Python f-string examples, specifically designed to test the `ruff_python_parser`'s handling of PEP 701 f-string syntax in Python 3.11, including complex nesting, comments within expressions, and escape sequences.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/ok/type_param_default_py313.py",
            "description": "This file tests the parsing of Python 3.13's new syntax for type parameters with default values, applied to type aliases, functions, and classes. It serves as an 'ok' test case for the `ruff_python_parser`.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/ok/pep701_f_string_py312.py",
            "description": "This file contains various examples of valid f-string syntax, including nested quotes, escape sequences, multi-line expressions, and line continuations, specifically for testing the Python 3.12 parser compliance with PEP 701.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/ok/simple_stmts_in_block.py",
            "description": "Tests the parser's ability to handle simple statements, including `pass` and `continue`, on a single line within an `if` block, with and without semicolons. It demonstrates valid (`ok`) inline syntax for such constructs.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/ok/single_star_in_tuple.py",
            "description": "This file demonstrates valid Python syntax for using a single star unpacking operator within a tuple, particularly in `yield`, `return`, and `for` loop contexts. It serves as a test case for the `ruff_python_parser`.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/ok/param_with_star_annotation_py310.py",
            "description": "This file contains regression tests for the `ruff` parser, ensuring it correctly handles various forms of starred parameters with type annotations under Python 3.10, as specified in issue #16874.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/ok/match_as_pattern.py",
            "description": "This file serves as a test resource for the Ruff Python parser, demonstrating valid `match` statements using basic name and wildcard patterns.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/ok/valid_annotation_class.py",
            "description": "This file contains examples of valid Python class definitions where base classes are defined using various expressions, including assignment expressions, `yield`, `yield from`, and `await`. It serves as a test case for a Python parser to ensure correct handling of these constructs.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/ok/non_rebound_comprehension_variable.py",
            "description": "This file contains a Python list comprehension utilizing an assignment expression ('walrus operator') for a non-rebound variable, serving as a parser test case for `ruff` to ensure correct handling of this syntax.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/ok/param_with_star_annotation_py311.py",
            "description": "This Python 3.11 example demonstrates a function parameter with a star annotation, specifically for `*args` using `TypeVarTuple`. It serves as a test case for the parser's ability to handle this syntax.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/ok/param_with_star_annotation.py",
            "description": "This file contains Python code demonstrating the use of a star (`*`) within a type annotation for a function parameter. It serves as a test case for `ruff_python_parser` to ensure correct parsing of this syntax.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/ok/valid_annotation_py313.py",
            "description": "This file contains valid Python 3.13 syntax for type annotations, specifically demonstrating the use of assignment expressions, yield, yield from, and await within annotations. It serves as a test case for the parser.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/ok/valid_annotation_function_py313.py",
            "description": "This file contains test cases demonstrating valid function annotation syntax specific to Python 3.13, including assignment expressions (walrus operator), yield expressions, and await expressions used within type annotations.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/ok/parenthesized_kwarg_py37.py",
            "description": "This file is a test case for the `ruff_python_parser`, verifying its ability to correctly parse or identify syntax errors for parenthesized keyword arguments in a function call, specifically targeting Python 3.7.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/ok/unparenthesized_named_expr_py39.py",
            "description": "This file contains Python 3.9 code examples demonstrating unparenthesized assignment expressions (walrus operator). It serves as a test case for the `ruff_python_parser` to verify its handling of named expressions in various contexts, including those that may result in a SyntaxError for the target version.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/err/assert_empty_msg.py",
            "description": "This file contains a Python `assert` statement with a condition and an empty message, likely serving as a test case for parser error handling or specific syntax validation.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/err/case_expect_indented_block.py",
            "description": "This file is a test case demonstrating an expected parsing error where an indented block is missing after a `case` statement in a `match` expression.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/err/assign_stmt_invalid_value_expr.py",
            "description": "This file contains a series of invalid assignment statements designed to test the parser's error handling for incorrect expression syntax within assignments.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/err/ann_assign_stmt_invalid_annotation.py",
            "description": "This file contains intentionally invalid type annotations in assignment statements, likely serving as test cases for error handling in a Python parser or linter.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/err/ann_assign_stmt_type_alias_annotation.py",
            "description": "This file contains Python code examples that are expected to produce syntax or parsing errors related to type alias annotations within assignment statements, used for testing a parser's error handling.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/err/aug_assign_stmt_missing_rhs.py",
            "description": "This file contains intentionally malformed Python code demonstrating syntax errors where augmented assignment statements (`+=`) are missing their right-hand side, used for testing a parser's error handling.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/err/ann_assign_stmt_invalid_value.py",
            "description": "This file contains intentionally invalid Python syntax for annotated assignment statements, serving as a test case to ensure the parser correctly identifies and reports these errors.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/err/async_unexpected_token.py",
            "description": "This file contains invalid Python syntax demonstrating incorrect uses of the 'async' keyword, likely serving as a test case for a parser to detect unexpected 'async' tokens.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/err/assert_invalid_test_expr.py",
            "description": "This file contains intentionally invalid `assert` statements designed to test the parser's error handling for incorrect assert expressions. It serves as a regression test for syntax errors related to `assert` statements.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/err/assign_stmt_missing_rhs.py",
            "description": "This file contains intentionally malformed Python assignment statements, designed to test error handling in a parser for cases where the right-hand side of an assignment is missing or syntactically incorrect.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/err/class_def_empty_body.py",
            "description": "This file contains intentionally invalid Python code, demonstrating an error case where a class definition immediately follows another without a body, likely used for testing a parser's error handling.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/err/class_def_unclosed_type_param_list.py",
            "description": "This file contains a Python class definition with an unclosed and malformed type parameter list, serving as a test case for error handling in a parser or linter.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/err/aug_assign_stmt_invalid_value.py",
            "description": "This file contains examples of invalid augmented assignment statements in Python. It serves as a test case for a parser or linter to identify and report syntax errors involving operations like starred expressions, yield, lambda, and assignment expressions within augmented assignments.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/err/comma_separated_missing_first_element.py",
            "description": "This file is a test case for the Ruff Python parser, specifically designed to demonstrate an error where a comma-separated list (implied in function arguments) is missing its first element, leading to invalid syntax like `call(= 1)`.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/err/decorator_invalid_expression.py",
            "description": "This file contains examples of invalid decorator syntax designed to test the `ruff_python_parser`'s error handling and reporting capabilities for incorrect decorator expressions.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/err/class_def_missing_name.py",
            "description": "This file contains examples of Python class definitions with missing names, used for testing how a parser handles such syntax errors.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/err/decorator_missing_expression.py",
            "description": "This file contains test cases designed to trigger syntax errors related to malformed or incomplete Python decorators, such as missing expressions after the '@' symbol.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/err/assert_invalid_msg_expr.py",
            "description": "This file contains examples of assert statements with syntactically invalid message expressions. It is used to test the parser's error handling for incorrect assert message syntax.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/err/decorator_missing_newline.py",
            "description": "This file contains intentionally malformed Python code demonstrating decorator syntax errors, specifically missing newlines after decorators. It serves as a test case for a parser or linter to identify these specific syntax issues.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/err/assign_stmt_starred_expr_value.py",
            "description": "This file contains intentionally invalid Python syntax, specifically starred expressions used as the value in assignment statements, to test the parser's error handling.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/err/comprehension_missing_for_after_async.py",
            "description": "This file contains intentionally incorrect Python syntax, serving as a test case for a parser error. It specifically tests the scenario of a missing 'for' keyword after 'async' within a comprehension.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/err/class_type_params_py311.py",
            "description": "This file contains test cases for parsing class type parameters, specifically designed to trigger errors related to invalid syntax in Python 3.11. It includes both valid (for context) and invalid class type parameter declarations.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/err/decorator_await_expression_py38.py",
            "description": "This file is a test case for `ruff_python_parser` demonstrating an invalid syntax error in Python 3.8, specifically when an `await` expression is used directly as a decorator.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/err/comma_separated_missing_comma_between_elements.py",
            "description": "This file contains an invalid Python list literal missing a comma between elements, used to test the parser's error handling for malformed list expressions.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/err/except_stmt_missing_as_name.py",
            "description": "This file contains intentionally malformed Python syntax demonstrating an `except` statement error where a name is missing after the `as` keyword, likely used for testing a parser's error handling.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/err/except_stmt_invalid_expression.py",
            "description": "This file contains Python code with invalid exception expressions within `try...except` and `try...except*` blocks, designed to test error handling or parsing of incorrect syntax in exception statements.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/err/dotted_name_multiple_dots.py",
            "description": "This file serves as a test case for the Python parser, specifically designed to trigger and verify error handling for invalid import statements containing multiple consecutive dots in a dotted name.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/err/decorator_dict_literal_py38.py",
            "description": "This file is a test case designed to verify that the parser correctly raises a syntax error when an invalid dictionary literal is used as a decorator, specifically for Python 3.8 target environments.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/err/duplicate_type_parameter_names.py",
            "description": "This file contains intentionally erroneous Python code demonstrating various cases of duplicate type parameter names in `type alias`, `def`, and `class` definitions, used for testing a parser or linter's error detection capabilities.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/err/clause_expect_indented_block.py",
            "description": "This file contains Python code snippets designed to test error handling in a parser when an indented block is expected after a clause but is missing or improperly formatted. It specifically checks highlighting for such errors.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/err/f_string_unclosed_lbrace_in_format_spec.py",
            "description": "This file contains test cases demonstrating an unclosed left brace within an f-string's format specifier, expected to raise a parsing error.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/err/f_string_empty_expression.py",
            "description": "This file contains f-string expressions with empty or whitespace-only interpolation fields, designed to test the parser's error handling for such invalid syntax.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/err/duplicate_match_key.py",
            "description": "This file contains test cases for duplicate keys within dictionary patterns in Python match statements. It demonstrates various scenarios where duplicate keys, including different literal types and combinations, are used in `case` patterns to test parser error handling.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/err/if_stmt_elif_missing_colon.py",
            "description": "This file is a test case demonstrating a syntax error in Python where a colon is missing after an 'elif' statement.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/err/decorator_float_literal_py38.py",
            "description": "This file tests the parser's error handling for an invalid float literal used as a decorator in Python 3.8, which is syntactically incorrect. It ensures the parser correctly identifies and rejects such code.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/err/decorator_named_expression_py37.py",
            "description": "This file is a test case for `ruff_python_parser` that expects a syntax error. It demonstrates the use of a named expression (walrus operator) as a decorator argument in Python 3.7, where this syntax is not supported.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/err/comma_separated_missing_element_between_commas.py",
            "description": "This file tests how the `ruff_python_parser` handles a syntax error where an element is missing between commas in a list literal.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/err/f_string_invalid_starred_expr.py",
            "description": "This file contains examples of invalid starred expressions within f-strings, specifically demonstrating cases that would raise a syntax error because starred expressions have a minimum precedence of bitwise OR.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/err/except_stmt_missing_exception.py",
            "description": "This file demonstrates syntax errors related to `except` statements missing an exception type, specifically showcasing invalid `except as exc` and `except*` forms without a specified exception.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/err/except_star_py310.py",
            "description": "This file tests that `except*` (exception groups) raises a syntax error when parsed with Python 3.10, as indicated by the `parse_options` directive. It confirms the parser correctly identifies this syntax as invalid for the specified target version.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/err/for_stmt_missing_iter.py",
            "description": "This file is a test case for the `ruff_python_parser` that demonstrates an error where a `for` statement is missing its iterable. It is designed to trigger a syntax error during parsing.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/err/for_stmt_missing_in_keyword.py",
            "description": "This file contains intentionally malformed Python code snippets demonstrating `for` statements with a missing 'in' keyword, used for testing parser error handling.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/err/from_import_missing_rpar.py",
            "description": "This file serves as a test case for the `ruff_python_parser`, demonstrating a syntax error where a 'from ... import' statement is missing a closing parenthesis.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/err/f_string_invalid_conversion_flag_other_tok.py",
            "description": "This file contains f-string expressions with invalid conversion flags that are not single letters, serving as a test case for parser error handling.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/err/different_match_pattern_bindings.py",
            "description": "This file contains various `match` statement patterns, primarily demonstrating different binding behaviors and potential conflicts within 'or' patterns for testing a Python parser or linter. It showcases cases where different variables are bound in alternative match patterns.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/err/except_stmt_unparenthesized_tuple_no_as_py313.py",
            "description": "This file contains Python 3.13 syntax errors for `except` statements. Specifically, it tests cases where multiple exception types are provided as an unparenthesized tuple without an `as` clause, which is invalid syntax.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/err/from_import_unparenthesized_trailing_comma.py",
            "description": "This file contains intentionally incorrect Python `from ... import ...` statements with unparenthesized trailing commas, serving as a test case for parsing errors.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/err/except_stmt_missing_exception_and_as_name.py",
            "description": "This file is a test case designed to trigger a syntax error in the Python parser, specifically when an `except` statement is missing both the exception type and the `as` name. It helps verify that the parser correctly identifies and reports this malformed syntax.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/err/import_stmt_star_import.py",
            "description": "This file contains intentionally malformed import statements, specifically demonstrating syntax errors related to star imports (*), likely for testing a parser's error handling.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/err/duplicate_match_class_attr.py",
            "description": "This file contains `match` statement patterns designed to test error handling for duplicate class attributes or dictionary keys within patterns, specifically in the context of Python's structural pattern matching.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/err/from_import_empty_names.py",
            "description": "This file contains Python syntax errors related to 'from ... import' statements with empty or invalid imported names, serving as a test case for error detection.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/err/function_def_missing_identifier.py",
            "description": "This file contains malformed Python function definitions with missing identifiers, used to test error handling in the `ruff_python_parser`.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/err/except_stmt_unparenthesized_tuple_as.py",
            "description": "This file contains intentionally erroneous Python syntax to test parsing of `except` statements that use unparenthesized tuple-like exception types with an `as` clause, covering both standard `except` and `except*`.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/err/decorator_unexpected_token.py",
            "description": "This file is a test case designed to trigger and verify a parser error when a decorator is immediately followed by an 'async with' statement or an assignment, which are invalid targets for decorators.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/err/for_iter_unpack_py38.py",
            "description": "This file contains Python code demonstrating invalid unpacking syntax in 'for' loop iterations for Python 3.8, serving as a test case for expected parsing errors.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/err/function_def_invalid_return_expr.py",
            "description": "This file contains examples of invalid function return type annotations, serving as test cases for a parser or linter to detect syntax errors in Python function definitions.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/err/global_stmt_trailing_comma.py",
            "description": "This file contains invalid Python syntax, specifically `global` statements with trailing commas, which are not permitted. It likely serves as a test case for a parser to ensure it correctly identifies and rejects such syntax errors.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/err/if_stmt_invalid_elif_test_expr.py",
            "description": "This file is a test case designed to verify that the parser correctly identifies and flags invalid expressions within `elif` statements, specifically `*x` and `yield x`.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/err/f_string_unclosed_lbrace.py",
            "description": "This file contains intentionally malformed f-strings with unclosed left braces, serving as a test case for the `ruff_python_parser` to ensure it correctly identifies and handles `f_string_unclosed_lbrace` errors.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/err/from_import_missing_module.py",
            "description": "This file contains intentionally erroneous Python syntax, specifically an incomplete 'from' import statement, to test error handling in a Python parser.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/err/function_def_missing_return_type.py",
            "description": "This file is a test case demonstrating a Python function definition with a missing return type annotation, likely used to test error handling in a parser or linter.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/err/invalid_fstring_literal_element.py",
            "description": "This file contains test cases demonstrating f-strings with invalid Unicode escape sequences, likely used to test error handling for f-string literal elements.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/err/import_stmt_trailing_comma.py",
            "description": "This file contains intentionally malformed Python import statements with trailing commas, serving as a test case for error handling in a Python parser.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/err/comma_separated_missing_comma.py",
            "description": "This file is a test case for `ruff_python_parser`. It contains intentionally invalid Python syntax, featuring a walrus operator within keyword argument unpacking, to ensure the parser correctly identifies this as an error.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/err/function_def_unclosed_parameter_list.py",
            "description": "This file contains intentionally malformed Python code with unclosed function parameter lists, serving as a test case for a parser's error handling capabilities.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/err/from_import_dotted_names.py",
            "description": "This file contains `from import` statements with various dotted names, including some syntax errors, serving as a test case for parsing and error handling in a Python parser.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/err/function_def_unclosed_type_param_list.py",
            "description": "This file is a test case demonstrating an invalid Python function definition with an unclosed type parameter list, expected to cause a parsing error.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/err/if_stmt_misspelled_elif.py",
            "description": "This file contains a Python syntax error with a misspelled 'elif' keyword as 'elf'. It likely serves as a test case for error handling in a Python parser.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/err/from_import_star_with_other_names.py",
            "description": "This file contains intentionally invalid Python syntax, specifically demonstrating incorrect usage of `from ... import *` combined with named imports, for testing error handling in a parser.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/err/if_stmt_missing_colon.py",
            "description": "This file contains a Python snippet with a syntax error (missing colon in an 'if' statement) used to test the parser's error handling capabilities.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/err/invalid_byte_literal.py",
            "description": "This file contains examples of invalid byte literals used for testing error handling in the `ruff_python_parser`.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/err/import_alias_missing_asname.py",
            "description": "This file is a test case designed to trigger a syntax error when an import statement uses 'as' but omits the alias name.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/err/for_stmt_invalid_iter_expr.py",
            "description": "This file contains examples of invalid iteration expressions within `for` statements, used for testing a Python parser's error handling capabilities. It demonstrates syntax errors like unpacking, yield expressions, and assignment expressions as iterators.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/err/implicitly_concatenated_unterminated_string.py",
            "description": "This file serves as a test case for a Python parser, specifically demonstrating syntax errors caused by implicitly concatenated and unterminated string literals.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/err/invalid_string_literal.py",
            "description": "This file contains Python code snippets with invalid Unicode escape sequences within string literals. It serves as a test case for `ruff_python_parser` to verify its error handling for malformed string literals.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/err/import_stmt_parenthesized_names.py",
            "description": "This file contains syntactically invalid Python import statements using parentheses around the imported names. It serves as an error case to test the `ruff_python_parser`'s ability to identify and handle incorrect import syntax.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/err/invalid_annotation_function.py",
            "description": "This file contains Python code examples demonstrating various invalid uses of 'await', 'yield', and named expressions within function type annotations and generic type parameter definitions.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/err/global_stmt_expression.py",
            "description": "This file demonstrates a syntax error where an expression is used with a 'global' statement. It serves as a test case for invalid 'global' statement usage.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/err/match_stmt_missing_pattern.py",
            "description": "This file contains a Python code snippet demonstrating a syntax error where a 'case' statement in a 'match' block is missing its pattern. It is likely used as a negative test case for a parser or linter to ensure correct error detection.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/err/f_string_conversion_follows_exclamation.py",
            "description": "This file contains examples of f-string syntax errors where the conversion specifier after '!' is invalid (e.g., multiple characters or unknown characters), used for testing parser error handling.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/err/match_stmt_invalid_subject_expr.py",
            "description": "This file contains example `match` statements with various invalid subject expressions, used to test the parser's error handling for syntax errors.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/err/invalid_annotation_py314.py",
            "description": "Tests invalid type annotations in Python 3.14, specifically focusing on the use of assignment expressions (walrus operator), `yield`, `yield from`, and `await` within type hints.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/err/lambda_body_with_starred_expr.py",
            "description": "This file contains intentionally malformed lambda expressions with starred expressions in their bodies, serving as error test cases for a Python parser or linter.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/err/invalid_annotation_function_py314.py",
            "description": "This file contains intentionally invalid type annotations in function signatures, utilizing assignment expressions, yield, yield from, and await. It serves as a test case for a Python parser (likely Ruff's) to verify error handling for these disallowed syntax patterns in type hints, specifically targeting Python 3.14.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/err/invalid_future_feature.py",
            "description": "This file contains test cases for `__future__` imports with invalid or unrecognized feature names, likely to test error handling in a parser or linter.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/err/if_stmt_invalid_test_expr.py",
            "description": "This file contains Python code snippets demonstrating invalid test expressions within `if` statements, used to test the parser's error handling capabilities.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/err/match_classify_as_keyword.py",
            "description": "This file contains intentionally incorrect Python code to test how the `ruff_python_parser` handles a syntax error where 'yield' is used illegally after a 'match' statement. It serves as a test case for error classification.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/err/match_stmt_invalid_guard_expr.py",
            "description": "This file demonstrates Python match statements containing invalid guard expressions, such as starred expressions or yield statements, which are expected to cause syntax errors. It likely serves as a test case for a parser's error handling.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/err/clause_expect_single_statement.py",
            "description": "This file contains intentionally malformed Python code to test error handling within the `ruff_python_parser` crate. It demonstrates a syntax error where an `if` clause is followed by another compound `if` statement on the same line, violating the expectation of a single simple statement or an indented block.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/err/invalid_annotation_class.py",
            "description": "This file contains examples of invalid Python class definitions, specifically focusing on unsupported expressions like yield, await, or named expressions within type parameters of generic classes. It serves as a test case for error detection in a parser or linter.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/err/function_def_empty_body.py",
            "description": "This file serves as a test case for a parser, demonstrating an error condition where a function definition lacks a proper body.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/err/match_stmt_missing_guard_expr.py",
            "description": "This file contains a Python code snippet designed to trigger a syntax error due to a missing guard expression in a 'match' statement's 'case' clause.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/err/lambda_body_with_yield_expr.py",
            "description": "This file contains intentionally erroneous Python code demonstrating `yield` and `yield from` expressions within lambda bodies, which are syntax errors. It is likely used to test the error handling of a Python parser.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/err/function_def_unparenthesized_return_types.py",
            "description": "This file contains intentionally malformed Python code to test the `ruff_python_parser`'s ability to detect syntax errors in function return type annotations, specifically cases involving unparenthesized multiple types or trailing commas.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/err/match_stmt_expect_indented_block.py",
            "description": "This file contains a Python `match` statement designed to test error handling in a parser when an indented block is expected but not found after a case clause.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/err/import_from_star.py",
            "description": "This file contains various `from ... import *` statements within functions and classes, serving as a test case for a linter or parser to identify specific import patterns, potentially invalid ones or those that trigger warnings.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/err/ipython_help_escape_command_error_recovery_2.py",
            "description": "This test file for `ruff_python_parser` in IPython mode assesses error recovery mechanisms, specifically handling malformed input or escape commands within a `with` statement context.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/err/ipython_help_escape_command_error_recovery_1.py",
            "description": "Tests error recovery in the IPython parser when encountering malformed help escape commands or invalid syntax in IPython mode. It includes an example of a syntax error using '?' within a `with` statement and a standalone '?'.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/err/match_classify_as_keyword_or_identifier.py",
            "description": "This file contains an invalid `match` statement syntax, specifically demonstrating an error where a keyword might be misinterpreted, used as a test case for a parser's error handling.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/err/if_stmt_empty_body.py",
            "description": "This file serves as a test case for a syntax error, demonstrating an `if` statement followed by an incorrectly indented or effectively empty body, which should trigger a parsing error in `ruff_python_parser`.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/err/ipython_help_escape_command_error_recovery_3.py",
            "description": "Tests error recovery in the IPython parser mode for invalid help escape sequences, specifically within a 'with' statement and as a standalone command.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/err/match_stmt_single_starred_subject.py",
            "description": "This file contains a Python code snippet that demonstrates an invalid `match` statement where a single starred expression is used as the subject, likely serving as an error test case for a parser or linter.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/err/iter_unpack_yield_py37.py",
            "description": "This file is a test case for `ruff_python_parser` demonstrating `yield` expressions with iterable unpacking in Python 3.7, likely to test error handling or specific parsing behavior.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/err/iter_unpack_return_py37.py",
            "description": "This file is a test case demonstrating an expected parsing error for iterable unpacking in a return statement when targeting Python 3.7, as this syntax was introduced in Python 3.8.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/err/nested_async_comprehension_py310.py",
            "description": "This file contains Python 3.10 code demonstrating various nested asynchronous comprehensions within list, dict, and set comprehensions, likely for testing parsing behavior or error conditions related to such constructs.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/err/mixed_bytes_and_non_bytes_literals.py",
            "description": "This file contains Python syntax errors demonstrating invalid mixtures of byte and non-byte string literals within a single expression. It is likely used for testing a parser's error handling for such cases.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/err/node_range_with_gaps.py",
            "description": "This file contains intentionally malformed Python code used as a test case for `ruff_python_parser` to verify error handling related to node ranges with gaps.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/err/invalid_annotation_type_alias.py",
            "description": "This file contains examples of invalid type alias syntax, using `yield`, `await`, or named expressions in contexts like type variable bounds or defaults. It likely serves as a test case for a parser or linter to ensure correct error reporting for such constructs.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/err/nonlocal_declaration_at_module_level.py",
            "description": "This file contains incorrect `nonlocal` declarations at the module level, serving as a test case for a parser to ensure it correctly identifies and reports these syntax errors.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/err/param_with_invalid_star_annotation.py",
            "description": "This file contains examples of invalid usage of star annotations within type hints for `*args` parameters, likely used for testing error reporting in a Python parser or linter like Ruff.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/err/irrefutable_case_pattern.py",
            "description": "This file demonstrates `match` statements with irrefutable patterns (e.g., capture, wildcard, as, or patterns) that precede more specific patterns, likely to test error detection for unreachable cases.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/err/params_multiple_star_separator.py",
            "description": "This file contains test cases demonstrating syntax errors when multiple star ('*') separators are used in function parameter definitions.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/err/param_with_invalid_annotation.py",
            "description": "This file contains examples of Python function definitions with invalid type annotations for parameters, used to test error handling in a parser.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/err/match_stmt_no_newline_before_case.py",
            "description": "This file tests the parser's error handling for a `match` statement where a newline is missing before the `case` keyword, expecting a syntax error.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/err/implicitly_concatenated_unterminated_string_multiline.py",
            "description": "This file serves as a test case for the `ruff_python_parser` to verify its ability to detect syntax errors involving implicitly concatenated, multiline, unterminated string literals.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/err/match_expected_colon.py",
            "description": "This file is a test case for the Python parser, designed to check if it correctly flags a `match` statement missing a colon after the expression.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/err/param_with_invalid_default.py",
            "description": "This file contains test cases demonstrating various forms of syntactically invalid default parameter assignments in Python function definitions. It is used to verify that the parser correctly identifies and handles these errors.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/err/match_stmt_expected_case_block.py",
            "description": "This file demonstrates a syntax error where a 'match' statement is not followed by a 'case' block, serving as a negative test case for a Python parser's error handling.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/err/named_expr_slice_parse_error.py",
            "description": "Tests that a parse error is correctly emitted for a named expression (walrus operator) used within a slice in Python 3.8, where this syntax is invalid.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/err/param_missing_default.py",
            "description": "This file contains Python code snippets designed to test the `ruff_python_parser` for handling syntax errors where a default value is missing in a function parameter definition.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/err/param_missing_annotation.py",
            "description": "This file contains test cases demonstrating Python syntax errors where a parameter is annotated with a colon but lacks an explicit type annotation.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/err/nonlocal_stmt_expression.py",
            "description": "This file contains an invalid Python code snippet, specifically a `nonlocal` statement attempting to use an expression, designed to test the parser's error handling capabilities.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/err/nonlocal_stmt_trailing_comma.py",
            "description": "This file contains invalid Python syntax, specifically malformed 'nonlocal' statements with trailing commas or lone commas, intended for testing error handling in a parser or linter.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/err/multiple_assignment_in_case_pattern.py",
            "description": "This file provides test cases for `match` statement patterns that involve multiple assignments of the same variable within a single `case` pattern, demonstrating scenarios that are likely invalid or erroneous.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/err/raise_stmt_invalid_cause.py",
            "description": "This file contains invalid `raise` statements with incorrect `from` causes, likely serving as test cases to verify a parser's error handling for such syntax.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/err/nonlocal_stmt_empty.py",
            "description": "This file is a test case designed to trigger a syntax error in the Python parser, specifically for an invalid `nonlocal` statement that is not followed by any variable names.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/err/params_star_after_slash.py",
            "description": "This file contains examples of syntactically incorrect Python function parameter definitions, specifically those involving a star argument ('*') followed by a positional-only argument separator ('/'). It is likely used as a test case for a Python parser to verify error detection.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/err/params_multiple_kwargs.py",
            "description": "This file contains a Python syntax error demonstrating multiple keyword argument unpackings (**kwargs) in a function definition, used as an inline test case for the parser.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/err/nested_quote_in_format_spec_py312.py",
            "description": "This file is a test case for `ruff_python_parser` that verifies a `ParseError` is raised for an f-string with a nested quote in its format specifier, specifically when targeting Python 3.12.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/err/params_multiple_slash_separator.py",
            "description": "Tests syntax errors related to multiple positional-only argument separators ('/') in function definitions. It provides examples of invalid function parameter lists that a Python parser should flag as errors.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/err/raise_stmt_invalid_exc.py",
            "description": "This file contains intentionally invalid 'raise' statements, serving as test cases for a parser or linter to detect syntax errors related to the 'raise' keyword in Python.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/err/pos_only_py37.py",
            "description": "This file contains Python code demonstrating invalid syntax for positional-only arguments when targeting Python 3.7, as positional-only parameters were introduced in Python 3.8. It is used to test error handling in the parser for this specific version mismatch.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/err/params_duplicate_names.py",
            "description": "This file contains a Python function definition with intentionally duplicated parameter names in various forms. It likely serves as a test case for a linter or parser to detect and report errors related to invalid or ambiguous function parameter declarations.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/err/named_expr_slice.py",
            "description": "Tests how the `ruff_python_parser` handles invalid usage of named expressions (walrus operator) within slice notation, which should raise a syntax error.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/err/return_stmt_invalid_expr.py",
            "description": "This file contains test cases for invalid Python `return` statements, specifically demonstrating various erroneous expressions following the `return` keyword. It is likely used to test error handling in a Python parser.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/err/simple_stmts_on_same_line_in_block.py",
            "description": "This file contains a Python code snippet designed to test the parser's error handling for multiple, invalid simple statements on a single line within a conditional block.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/err/raise_stmt_unparenthesized_tuple_cause.py",
            "description": "This file contains intentionally invalid `raise` statements that demonstrate unparenthesized tuple causes, serving as a test case for parsing error handling in the Ruff project.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/err/match_before_py310.py",
            "description": "This file is a test case for the Ruff Python parser, designed to verify that a `match` statement (Python 3.10+ syntax) correctly raises an error when parsed with a target Python version set to 3.9.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/err/params_no_arg_before_slash.py",
            "description": "This file contains Python syntax that is intentionally invalid, demonstrating function definitions with a positional-only argument separator (/) but no arguments before it. It serves as an error test case for a Python parser.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/err/params_var_positional_with_default.py",
            "description": "This file tests how the parser handles an invalid function definition where a variadic positional argument (`*args`) is assigned a default value, which is not allowed in Python syntax.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/err/params_multiple_varargs.py",
            "description": "This file contains intentionally erroneous Python function definitions, specifically designed to test the parser's handling of multiple variable-positional argument parameters (*args), which are syntactically invalid.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/err/type_alias_incomplete_stmt.py",
            "description": "This file contains incomplete and syntactically incorrect `type` alias statements, serving as test cases for error handling in a Python parser.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/err/params_star_separator_after_star_param.py",
            "description": "This file contains examples of invalid Python function parameter syntax, specifically defining a star separator argument (`*`) after a star parameter (`*args`), which should result in a parsing error.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/err/multiple_clauses_on_same_line.py",
            "description": "This file contains Python code examples with multiple `if/elif/else`, `for/else`, and `try/except/else/finally` clauses placed on the same line, serving as test cases for syntax error detection within the `ruff_python_parser`.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/err/parenthesized_context_manager_py38.py",
            "description": "Tests parsing errors for parenthesized context managers in Python 3.8, where this syntax is not supported. It contains multiple 'with' statements using parenthesized context managers that should raise syntax errors.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/err/params_non_default_after_default.py",
            "description": "This file contains an intentionally malformed Python function definition, specifically demonstrating a 'non-default parameter follows default parameter' syntax error. It serves as a negative test case for a Python parser or linter.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/err/params_var_keyword_with_default.py",
            "description": "This file demonstrates an invalid Python syntax where a variadic keyword argument (**kwargs) is assigned a default value, which is not allowed. It likely serves as a test case for a parser to detect this specific syntax error.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/err/single_star_yield.py",
            "description": "This file contains an intentional syntax error to test how the Python parser handles an invalid `yield *x` expression, which should be `yield from x`.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/err/try_stmt_missing_except_finally.py",
            "description": "This file demonstrates invalid Python `try` statements that are missing either an `except` or `finally` block, expected to produce a syntax error.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/err/function_type_params_py311.py",
            "description": "This file tests the parser's handling of function type parameters (PEP 695) introduced in Python 3.11. It includes a valid usage and an invalid case with an empty type parameter list, likely expecting an error.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/err/param_with_star_annotation_py310.py",
            "description": "This file is a test case demonstrating a syntax error in Python 3.10 where a star annotation is used directly on a parameter, which is not allowed. It is used to test the parser's error handling for this specific scenario.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/err/single_star_for.py",
            "description": "This file contains test cases for syntax errors related to the incorrect use of a single star (`*`) in a `for` loop expression, designed to test a Python parser's error handling.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/err/try_stmt_misspelled_except.py",
            "description": "This file contains intentionally misspelled 'except' keywords ('exept') within try-except-finally blocks. It serves as a test case for identifying parsing errors or syntax issues related to 'try' statements.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/err/t_string_invalid_conversion_flag_name_tok.py",
            "description": "Tests the parser's error handling for an f-string containing an invalid conversion flag (e.g., `!z`) in Python 3.14.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/err/type_alias_invalid_value_expr.py",
            "description": "This file contains examples of invalid type alias value expressions, intended for testing how the Python parser handles syntax errors related to type alias assignments.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/err/t_string_unclosed_lbrace_in_format_spec.py",
            "description": "This file contains test cases for f-strings with unclosed left braces in their format specifications, designed to trigger parsing errors in Python 3.14.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/err/star_slices.py",
            "description": "This file contains an example of an invalid slice syntax with a star operator in Python, used as an error test case for the `ruff_python_parser`.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/err/type_param_invalid_bound_expr.py",
            "description": "This file contains examples of invalid type parameter bound expressions using Python's `type` statement, demonstrating syntax errors for type parameter constraints.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/err/pep701_nested_interpolation_py311.py",
            "description": "Tests the parser's error handling for PEP 701 related nested f-string interpolations, specifically targeting Python 3.11 syntax with complex embedded quotes and newlines.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/err/decorator_non_toplevel_call_expression_py38.py",
            "description": "This file serves as a test case for the `ruff_python_parser` to verify its error handling for non-toplevel call expressions used as decorators. It expects the parser to raise an error when encountering this specific decorator syntax while targeting Python 3.8.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/err/type_param_missing_bound.py",
            "description": "This file contains Python type alias definitions with missing type parameter bounds, serving as a test case for expected syntax errors in a parser.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/err/type_param_type_var_tuple_bound.py",
            "description": "This file demonstrates a syntax error in Python type hints, specifically an invalid usage of a TypeVarTuple with a bound, intended for testing the `ruff_python_parser`'s error handling.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/err/t_string_invalid_conversion_flag_other_tok.py",
            "description": "This file contains test cases for f-strings with invalid conversion flags, specifically `!123` and `!'a'`, to ensure the parser correctly identifies and reports errors for these constructs in future Python versions (3.14).",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/err/single_star_return.py",
            "description": "Tests the parser's ability to identify and handle invalid Python syntax, specifically a bare star expression in a return statement.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/err/raise_stmt_unparenthesized_tuple_exc.py",
            "description": "This file contains examples of `raise` statements using unparenthesized tuples as exceptions, demonstrating syntax errors for parser testing. It likely serves as an error test case for the `ruff_python_parser`.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/err/type_param_param_spec_invalid_default_expr.py",
            "description": "This file contains test cases demonstrating invalid default expressions for ParamSpec type parameters within type aliases, likely used to test error handling in a parser or type checker.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/err/simple_and_compound_stmt_on_same_line_in_block.py",
            "description": "This file contains intentionally erroneous Python code to test a parser's ability to detect syntax errors. It specifically demonstrates disallowed combinations of simple and compound statements on the same line.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/err/type_param_type_var_missing_default.py",
            "description": "This file contains intentionally malformed type alias definitions with missing default values for type parameters, serving as a test case for the parser's error handling capabilities.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/err/t_string_empty_expression.py",
            "description": "This file contains test cases for f-strings with empty expression blocks, specifically designed to check the parser's error handling for Python 3.14.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/err/unparenthesized_named_expr_set_comp_py38.py",
            "description": "This file is a test case for `ruff_python_parser` demonstrating an invalid unparenthesized named expression (walrus operator) within a set comprehension, specifically for Python 3.8 where this syntax is not allowed.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/err/type_parameter_default_order.py",
            "description": "This file contains Python syntax examples demonstrating incorrect ordering of type parameters, specifically when a default-valued type parameter precedes a non-default one, likely for testing error handling in a parser.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/err/try_stmt_mixed_except_kind.py",
            "description": "This file is a test case demonstrating syntax errors or specific parsing behavior for `try...except` statements that mix bare `except:` clauses with `except* ExceptionGroup:` clauses.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/err/t_string_unclosed_lbrace.py",
            "description": "This file contains intentionally malformed Python f-strings or string literals with unclosed curly braces. It serves as an error test case to verify how the parser handles such syntax errors, specifically targeting Python 3.14.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/err/pep701_f_string_py311.py",
            "description": "This file contains various f-string examples designed to test error handling and complex parsing scenarios, particularly those related to PEP 701 and Python 3.11 syntax, within the `ruff_python_parser` project.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/err/unterminated_fstring_newline_recovery.py",
            "description": "This file contains a series of malformed f-strings with newlines, serving as a test case for parser error recovery mechanisms, specifically for unterminated f-strings.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/err/type_param_type_var_invalid_default_expr.py",
            "description": "This file contains a collection of Python `type` statements designed to trigger parsing errors due to invalid default expressions or constraints for type parameters, serving as test cases for a Python parser (likely Ruff's).",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/err/type_params_empty.py",
            "description": "This file is a test case demonstrating a syntax error where empty square brackets are used after a function definition or a type alias, indicating an issue with empty type parameters. It is likely used to test error handling in a Python parser or linter.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/err/type_param_param_spec_bound.py",
            "description": "This file demonstrates an invalid usage of a ParamSpec with a bound within a Python type alias, likely for testing error handling in a parser.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/err/with_items_parenthesized_missing_colon.py",
            "description": "This file is a syntax error test case for the Python parser, demonstrating a `with` statement where items are parenthesized but the colon is missing, followed by a newline.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/err/while_stmt_missing_colon.py",
            "description": "This file is a test case designed to trigger a syntax error due to a missing colon after the condition in a 'while' statement.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/err/simple_and_compound_stmt_on_same_line.py",
            "description": "This file is a test case demonstrating an invalid Python syntax where simple and compound statements are improperly mixed on the same line, which should trigger a parsing error.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/err/try_stmt_invalid_order.py",
            "description": "This file contains an intentionally invalid `try` statement with `finally` followed by `else`. It serves as a test case for the parser to ensure it correctly identifies and flags this syntax error.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/err/while_stmt_invalid_test_expr.py",
            "description": "Tests various invalid test expressions within `while` statements to ensure the parser correctly identifies and handles these syntax errors. It showcases cases like starred expressions, yield expressions, and multiple expressions as conditions.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/err/unparenthesized_named_expr_index_py38.py",
            "description": "A test case for the Python parser, demonstrating an unparenthesized named expression used in an index, which is expected to be an error in Python 3.8.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/err/parenthesized_kwarg_py38.py",
            "description": "This file contains intentionally invalid Python 3.8 syntax, specifically parenthesized keyword arguments like `(a)=1`, to test the parser's error handling capabilities.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/err/rebound_comprehension_variable.py",
            "description": "This file contains test cases for comprehensions using the walrus operator (`:=`) where the assigned variable is also the comprehension's loop variable, likely to check for re-binding errors or specific parsing behavior.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/err/type_param_param_spec_missing_default.py",
            "description": "This file contains test cases demonstrating syntax errors when a `ParamSpec` in a type alias is declared with an assignment operator but without a default value.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/err/walrus_py37.py",
            "description": "This file is a test case verifying that the walrus operator (':=') raises a syntax error when parsing Python 3.7 code, as it was introduced in Python 3.8.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/err/simple_stmts_on_same_line.py",
            "description": "This file contains intentionally malformed Python code with multiple simple statements on the same line, designed to test the `ruff_python_parser`'s error handling for syntax errors in such constructs.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/err/with_items_parenthesized_missing_comma.py",
            "description": "This file contains invalid Python `with` statements with parenthesized items where commas are missing, serving as error-case test data for the `ruff_python_parser`.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/err/type_param_type_var_tuple_invalid_default_expr.py",
            "description": "This file contains test cases demonstrating invalid default expressions for TypeVarTuple type parameters in `type` statements. It serves to verify error handling for incorrect syntax in Python type definitions.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/err/yield_from_in_async_function.py",
            "description": "This file contains a Python code snippet that demonstrates a `SyntaxError` by attempting to use `yield from` inside an `async def` function. It serves as a test case for `ruff_python_parser` to verify its error detection capabilities.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/err/type_param_type_var_tuple_missing_default.py",
            "description": "This file contains intentionally erroneous Python type alias definitions, specifically showcasing incorrect syntax for `TypeVarTuple` parameters when attempting to provide a default value or mix them with other parameters. It likely serves as a test case for a parser to detect syntax errors.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/err/tuple_context_manager_py38.py",
            "description": "This file demonstrates `with` statements using tuples as context managers, which are syntactically valid but lead to runtime errors in Python 3.8. It serves as a test case for a parser to flag these specific (effectively) invalid constructs.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/err/type_stmt_py311.py",
            "description": "This file contains a Python 3.11 'type' statement, likely used to test parsing of new type alias syntax introduced in that version.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/err/t_string_invalid_starred_expr.py",
            "description": "This file contains test cases for parsing f-strings (t-strings) with invalid starred expressions, ensuring the parser correctly identifies syntax errors related to operator precedence within such constructs for Python 3.14.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/err/star_index_py310.py",
            "description": "This file contains Python 3.11+ syntax features like star expressions in indexing and variadic generics, which are expected to cause parsing errors when targeting Python 3.10.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/err/unparenthesized_named_expr_set_literal_py38.py",
            "description": "This file tests parsing errors for unparenthesized named expressions (walrus operator) within set literals, specifically targeting Python 3.8 syntax where this is not allowed.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/err/while_stmt_missing_test.py",
            "description": "This file contains intentionally erroneous Python `while` statements that lack a test condition, serving as a test case for a parser to detect and report syntax errors.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/err/type_param_default_py312.py",
            "description": "This file contains Python 3.12 specific syntax for type parameters with default values in `type`, `def`, and `class` statements. It serves as a test case for the parser, likely verifying correct handling or expected errors related to these features.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/err/params_expected_after_star_separator.py",
            "description": "This file contains invalid Python function definitions designed to test parsing errors. It specifically demonstrates cases where parameters are missing or incorrectly specified after star separators (`*` or `*,`).",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/err/decorator_expression_py38.py",
            "description": "This file is a test case for `ruff_python_parser` to verify its error handling for complex decorator expressions, such as `buttons[0].clicked.connect`, when parsing Python 3.8 code. Its location in an `err` directory indicates that this code snippet is expected to trigger a parsing error.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_parser/resources/inline/err/params_kwarg_after_star_separator.py",
            "description": "This file is a test case for `ruff_python_parser`, located in an `err` directory, indicating that the parser is expected to report an error. It defines a function where the `**kwargs` parameter directly follows a keyword-only argument separator (`*`), testing the parser's handling of this specific function signature.",
            "spof": true
          },
          {
            "path": "crates/ruff_db/src/parsed.rs",
            "description": "This file provides functionality for parsing Python source files into Abstract Syntax Trees (ASTs) using Ruff's error-resilient parser, managing these parsed ASTs, and enabling efficient indexed access to their nodes.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/cst/matchers.rs",
            "description": "This file provides utility functions for parsing Python code into a Concrete Syntax Tree (CST) using `libcst_native`, and for safely matching and extracting specific CST node types for analysis and transformation within the linter.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_ast/src/operator_precedence.rs",
            "description": "This file defines an enumeration for Python's operator precedence levels and provides methods to determine the precedence of various Python expressions and operators.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_ast/src/token.rs",
            "description": "This file defines the `Token` struct and `TokenKind` enum, representing the lexical tokens of Python source code generated by a lexer for consumption by the `ruff_python_parser`. It includes various token types, their properties, and utility methods for classification.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_ast/src/str.rs",
            "description": "This file defines utilities for parsing and analyzing Python string, f-string, byte-string, and template literals, including enums for quote types and functions to identify and strip prefixes and suffixes.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_ast/src/token/tokens.rs",
            "description": "This file defines the `Tokens` struct, which manages a collection of lexed tokens and provides utility methods for querying and manipulating these tokens based on their text ranges and offsets.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_literal/src/char.rs",
            "description": "This file provides a utility function `is_printable` that determines whether a given character is considered printable according to Python's character category rules, excluding control, format, surrogate, private use, and specific separator characters.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_literal/src/format.rs",
            "description": "This file defines data structures and parsing logic for handling Python-style format string specifications, including static and dynamic formatting options.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_literal/src/cformat.rs",
            "description": "This file implements the parsing and representation of Python's printf-style string formatting specifications. It defines data structures for format types, flags, quantities, and errors, and provides functions to parse these components from a format string.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_literal/src/lib.rs",
            "description": "This file serves as the main library entry point for `ruff_python_literal`, defining modules and types related to parsing, formatting, and handling Python literals such as strings, characters, and floats.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_stdlib/src/identifiers.rs",
            "description": "Provides utility functions to validate various Python identifier formats, including standard variable names, private mangled names, PEP 8-compliant module names, and migration file names.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_index/src/interpolated_string_ranges.rs",
            "description": "Manages and queries the text ranges of interpolated strings (like f-strings) within Python code, allowing for efficient lookup and intersection checks. It includes a builder for constructing these ranges by processing tokens.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_trivia/src/cursor.rs",
            "description": "This file defines a `Cursor` struct for efficiently iterating over characters in a string slice, providing methods for peeking, consuming, and matching characters from both the front and back of the input, similar to a lexer's cursor.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_trivia/src/tokenizer.rs",
            "description": "This file defines the `SimpleTokenKind` enum for various Python token types and provides utility functions for basic tokenizing, such as identifying non-trivia tokens, counting newlines, and checking identifier rules.",
            "spof": false
          }
        ],
        "contributors": [
          {
            "name": "Micha Reiser",
            "percent": 39
          },
          {
            "name": "Dhruv Manilawala",
            "percent": 24
          },
          {
            "name": "Brent Westbrook",
            "percent": 10
          }
        ]
      },
      "Module Resolution and Dependency Analysis": {
        "files": [
          {
            "path": "crates/ruff/src/commands/analyze_graph.rs",
            "description": "Analyzes a set of Python files within a project to build and output an import graph (either dependencies or dependents) in JSON format.",
            "spof": true
          },
          {
            "path": "crates/ruff/tests/analyze_graph.rs",
            "description": "This file contains integration tests for the `ruff analyze graph` command-line interface. It verifies various aspects of dependency analysis, including direct imports, string imports, configuration via `ruff.toml`, and glob patterns.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/diagnostics/unresolved_import.md",
            "description": "This file contains markdown examples demonstrating various scenarios that trigger the `unresolved-import` diagnostic in Python code, showcasing different ways an import can fail to resolve modules or specific items.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/import/case_sensitive.md",
            "description": "This file demonstrates Python's case-sensitive import system through various examples, including correct and incorrect casing, module resolution across multiple search paths, and sensitivity to file extension casing.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/import/allowed_unresolved_imports.md",
            "description": "This document describes the `allowed-unresolved-imports` configuration in ruff (or ty), detailing how various wildcard patterns (`**`, `*`) and negative patterns can be used to suppress diagnostics for unresolved imports.",
            "spof": true
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/import/dunder_file_attribute.md",
            "description": "This file documents and tests the behavior of the `__file__` attribute on imported Python modules, illustrating when it's available (string), not available (None), or results in resolution errors, particularly differentiating between regular and namespace packages.",
            "spof": true
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/import/namespace.md",
            "description": "This file contains a collection of test cases and examples demonstrating various aspects of Python namespace packages, including their basic usage, interactions with regular packages, import precedence, and specific regression tests for import resolution.",
            "spof": true
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/import/legacy_namespace.md",
            "description": "This file documents and tests various methods for defining legacy Python namespace packages, including correct and incorrect usages of `pkg_resources.declare_namespace` and `pkgutil.extend_path`. It demonstrates how a type checker (likely Ruff's semantic analysis) resolves imports and versions within such package structures.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/import/workspaces.md",
            "description": "This document describes the 'desperate module resolution' strategy used for resolving Python imports in workspaces, especially within monorepos or atypical project structures. It details how absolute and relative desperate search-paths are determined to handle cases like invalid module names or multiple projects.",
            "spof": true
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/import/stub_packages.md",
            "description": "This file provides a collection of test cases and examples demonstrating various scenarios and behaviors of Python stub packages, including simple stubs, namespace packages, inconsistent configurations, and relative imports, likely for testing or documentation of a type checker.",
            "spof": true
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/40_import.py",
            "description": "This file demonstrates various Python import statements, including single module imports, multiple imports on one line, aliased imports, and importing submodules from a package.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/42_import_from_dot.py",
            "description": "This file demonstrates a relative import, specifically importing the `config` module from the current package. It likely functions as a test case for semantic analysis tools.",
            "spof": false
          },
          {
            "path": "crates/ty_completion_eval/truth/auto-import-skips-current-module/subdir/__init__.py",
            "description": "This `__init__.py` file defines a simple variable within a package subdirectory. It likely serves as a test case for auto-import behavior, specifically how imports handle modules within the current package.",
            "spof": true
          },
          {
            "path": "crates/ruff_graph/src/settings.rs",
            "description": "This file defines data structures and settings for configuring module dependency analysis within the `ruff_graph` crate, including general analysis settings, string import handling, and dependency graph direction.",
            "spof": false
          },
          {
            "path": "crates/ruff_graph/src/resolver.rs",
            "description": "This file defines a `Resolver` responsible for resolving Python import statements to their corresponding file paths within the project, handling both standard modules and type stub files.",
            "spof": false
          },
          {
            "path": "crates/ruff_graph/src/lib.rs",
            "description": "This file defines structures and methods to detect and resolve Python module imports, creating mappings (graphs) of module dependencies or dependents within a project. It serves as the core library for import graph analysis in Ruff.",
            "spof": false
          },
          {
            "path": "crates/ruff_graph/src/collector.rs",
            "description": "This file defines a `Collector` that traverses a Python Abstract Syntax Tree (AST) to extract all imported modules, including those from `import` and `import from` statements, and optionally from string literals. It is used to analyze module dependencies within Python code.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_importer/src/lib.rs",
            "description": "Provides low-level helper functionalities for manipulating Python import statements, including an `Insertion` type.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_stdlib/src/path.rs",
            "description": "This file provides utility functions for path analysis, specifically to identify `pyproject.toml` files and Python module files like `__init__.py` or `__main__.py`.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_semantic/src/imports.rs",
            "description": "This file defines data structures and utilities for representing and manipulating Python import statements, including `import` and `from ... import` forms, within the Ruff linter's semantic analysis. It provides methods to extract details like qualified names and includes serialization/deserialization capabilities.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_semantic/src/analyze/imports.rs",
            "description": "This file provides utility functions for identifying specific types of Python statement modifications or function calls, such as changes to `sys.path`, `os.environ`, or calls to `matplotlib.use` and `pytest.importorskip`, within a semantic analysis context. It helps detect dynamic behaviors affecting the environment or module loading.",
            "spof": false
          },
          {
            "path": "crates/ty_module_resolver/src/module_name.rs",
            "description": "This file defines the `ModuleName` struct, which represents an absolute Python module name (e.g., `foo.bar`). It provides methods for creating, validating, parsing, and manipulating module names, ensuring they adhere to Python's naming conventions.",
            "spof": true
          },
          {
            "path": "crates/ty_module_resolver/src/settings.rs",
            "description": "This file defines data structures and logic for configuring and validating search paths used in module resolution, including handling misconfigurations and various types of paths like extra paths, source roots, and typeshed locations.",
            "spof": true
          },
          {
            "path": "crates/ty_module_resolver/src/module.rs",
            "description": "This file defines the `Module` enum, which represents a Python module (either a single file or a namespace package), and provides methods for resolving its properties and discovering its submodules within the Ruff ecosystem.",
            "spof": false
          },
          {
            "path": "crates/ty_module_resolver/src/resolve.rs",
            "description": "This module provides routines for resolving Python module names to concrete `Module` representations, handling various resolution strategies like stub file inclusion, real implementation lookups, and shadowing rules.",
            "spof": true
          },
          {
            "path": "crates/ty_module_resolver/src/module_glob.rs",
            "description": "This file provides a system for defining, parsing, and matching glob-like patterns against Python module names. It supports efficient inclusion or exclusion of modules based on these patterns, handling wildcard syntax and negation.",
            "spof": true
          },
          {
            "path": "crates/ty_module_resolver/src/db.rs",
            "description": "This file defines the `Db` trait, extending the base `ruff_db::Db` with module resolution search paths. It also provides a `TestDb` implementation for testing purposes, which includes system and file management, and Salsa event logging.",
            "spof": true
          },
          {
            "path": "crates/ty_module_resolver/src/testing.rs",
            "description": "Provides utilities and builders for creating isolated test environments for the module resolver, allowing the specification of file systems, Python versions, and typeshed configurations for testing purposes.",
            "spof": false
          },
          {
            "path": "crates/ty_module_resolver/src/list.rs",
            "description": "This file is responsible for discovering and listing all available Python modules, including top-level and sub-modules, within specified search paths. It incorporates logic to handle module name conflicts and correctly identify different module types (e.g., file modules, packages, namespace packages).",
            "spof": false
          },
          {
            "path": "crates/ty_module_resolver/src/lib.rs",
            "description": "This `lib.rs` file acts as the public interface for the `ty_module_resolver` crate. It provides utilities and types for resolving Python modules, managing search paths, and handling module-related configurations within the Ruff project.",
            "spof": true
          },
          {
            "path": "crates/ty_module_resolver/src/path.rs",
            "description": "This file defines abstractions for `ModulePath` and `SearchPath`, used to manage, classify, and resolve paths to Python modules across different search contexts, such as the file system, standard library, and vendored archives.",
            "spof": true
          }
        ],
        "contributors": [
          {
            "name": "Micha Reiser",
            "percent": 33
          },
          {
            "name": "Aria Desires",
            "percent": 31
          },
          {
            "name": "Charlie Marsh",
            "percent": 15
          }
        ]
      },
      "Semantic Model and Type System": {
        "files": [
          {
            "path": "crates/ty_python_semantic/resources/mdtest/descriptor_protocol.md",
            "description": "This document explains the Python descriptor protocol, detailing how `__get__`, `__set__`, and `__delete__` methods customize attribute access. It illustrates the behavior and precedence of data and non-data descriptors, including their interaction with instance, class, and metaclass attributes.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/public_types.md",
            "description": "This document defines and illustrates the concept of \"public types\" in Python's type inference, specifically how types are determined for symbols accessed from nested scopes. It covers various scenarios including control flow, shadowing, and overload handling, alongside current limitations.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/deprecated.md",
            "description": "This document outlines test cases and expected diagnostic behavior for the `@deprecated` decorator in Python, covering its application to functions, classes, and methods under various import and usage scenarios. It details how static analysis should validate arguments and report deprecation warnings, including interactions with aliases, dunders, and overloads.",
            "spof": true
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/metaclass.md",
            "description": "This file contains a series of test cases and examples demonstrating the behavior and type inference of Python metaclasses in various scenarios. It covers basic usage, inheritance, conflicting metaclasses, and edge cases like invalid or cyclic definitions.",
            "spof": true
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/boundness_declaredness/public.md",
            "description": "This document describes how type inference and diagnostics handle public uses of symbols, considering their boundness and declaredness states. It outlines the resulting public types and diagnostics across various scenarios, including special cases for stub files.",
            "spof": true
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/boolean/short_circuit.md",
            "description": "This file is a markdown document demonstrating Python's short-circuit evaluation behavior in boolean expressions, specifically focusing on how it affects the evaluation and scope of assignment expressions (walrus operator) with `and` and `or`.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/comprehensions/basic.md",
            "description": "This file contains a collection of test cases and examples demonstrating various types of Python comprehensions (list, dict, set), including basic, nested, async, and those illustrating type inference and error scenarios.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/comparison/byte_literals.md",
            "description": "Tests type inference for comparisons between byte literals, asserting that precise Literal types are inferred for various comparison operators.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/comparison/unions.md",
            "description": "This file documents and tests the type inference behavior of comparison operators when one or both operands are Python union types, including scenarios with unsupported operations.",
            "spof": true
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/comparison/instances/rich_comparison.md",
            "description": "This markdown file details the implementation and behavior of Python's rich comparison operations (`==`, `!=`, `<`, `<=`, `>`, `>=`) through dunder methods, including reflected comparisons and subclass interactions.",
            "spof": true
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/comparison/instances/membership_test.md",
            "description": "This document compares how Python's membership test operators (`in`, `not in`) behave based on different special method implementations (`__contains__`, `__iter__`, `__getitem__`) and highlights various scenarios, including correct usage, fallbacks, and error conditions.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/dataclasses/dataclasses.md",
            "description": "This markdown document provides a detailed explanation and examples of Python dataclasses. It covers basic usage, `__init__` signature generation, and the effects of various dataclass parameters like `init`, `repr`, `eq`, and `order`.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/dataclasses/post_init.md",
            "description": "This file contains a series of Python dataclass examples, serving as test cases or documentation, to illustrate the correct and incorrect usage of the `__post_init__` method, especially in conjunction with `InitVar` fields. It demonstrates various valid and invalid `__post_init__` signatures and their expected `invalid-dataclass` error outcomes.",
            "spof": true
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/dataclasses/dataclass_transform.md",
            "description": "This file provides detailed examples and documentation for the `typing.dataclass_transform` decorator, demonstrating its application with functions, metaclasses, and base classes. It illustrates how different arguments like `order_default`, `kw_only_default`, and `frozen_default` affect the generated dataclass-like behavior.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/diagnostics/shadowing.md",
            "description": "This file documents and provides test cases for Ruff's `invalid-assignment` diagnostic, specifically demonstrating how implicit class and function shadowing are detected.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/diagnostics/unpacking.md",
            "description": "This file contains markdown-formatted test cases for `ruff`'s semantic analysis, specifically designed to verify the correct detection and reporting of various unpacking-related errors in Python code.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/diagnostics/missing_argument.md",
            "description": "This file documents and provides test cases for 'missing argument' diagnostics in a Python semantic analysis tool, explaining how the tool identifies and reports missing required parameters in function calls, including considerations for unions and class methods.",
            "spof": true
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/import/builtins.md",
            "description": "This file provides test cases and documentation for how built-in symbols and modules are handled during type analysis, including explicit imports, implicit usage, custom typeshed configurations, and project-specific `__builtins__.pyi` stubs.",
            "spof": true
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/import/dunder_all.md",
            "description": "This file is a markdown test resource detailing the behavior and supported idioms of Python's `__all__` variable for named imports, including valid and invalid usage scenarios and version-dependent examples.",
            "spof": true
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/import/nonstandard_conventions.md",
            "description": "This document outlines `ty`-specific interpretations and deviations from standard Python import conventions, focusing on how imports in `__init__.py` and `__init__.pyi` files affect module and attribute re-exports and local definitions.",
            "spof": true
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/decorators/total_ordering.md",
            "description": "This file documents the behavior and usage of Python's `functools.total_ordering` decorator. It provides examples demonstrating how the decorator synthesizes comparison methods, handles type signatures, inheritance, and interactions with other decorators like `@dataclass`.",
            "spof": true
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/literal/float.md",
            "description": "This file documents and tests the type inference for float literals within the `ty_python_semantic` crate, demonstrating how `1.0` is recognized as a `float`.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/literal/f_string.md",
            "description": "This file contains Python code examples and tests demonstrating the type inference behavior of f-strings, particularly how they interact with `Literal` types, using `reveal_type` for analysis.",
            "spof": true
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/scopes/global.md",
            "description": "This file contains a collection of test cases and examples illustrating the behavior of the `global` keyword in Python. It covers various scenarios related to variable scoping, type resolution, and error conditions when using `global` declarations.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/stubs/class.md",
            "description": "This file describes how class definitions and attribute access are handled in Python type stub files (`.pyi`), covering cyclical references and the treatment of class-scope attributes.",
            "spof": true
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/type_compendium/always_truthy_falsy.md",
            "description": "This document describes the `AlwaysTruthy` and `AlwaysFalsy` types, which categorize Python values based on their static truthiness or falsiness. It also introduces related types like `Truthy`, `Falsy`, and `AmbiguousTruthiness`, providing examples and outlining their subtype relationships.",
            "spof": true
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/type_compendium/never.md",
            "description": "This markdown document provides a comprehensive explanation of Python's `Never` type, detailing its properties, use cases in type hinting, and its interactions with other types like `object`, unions, and intersections. It also clarifies its equivalence to `NoReturn`.",
            "spof": true
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/type_compendium/integer_literals.md",
            "description": "This document describes the properties and behaviors of integer literal types in Python, including their subtyping relationships, single-valued nature, and how they interact with type-narrowing and arithmetic operations.",
            "spof": true
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/type_compendium/none.md",
            "description": "This file documents and provides examples for the `None` type in Python, detailing its singleton nature, relationship with `Optional[T]`, type narrowing, and the `NoneType` alias for type semantic analysis.",
            "spof": true
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/type_compendium/not_t.md",
            "description": "This document explains the `Not[T]` type, which represents the complement of type `T`. It details its properties, including disjointness from `T`, how it reverses subtyping and assignability relationships, its role in De Morgan's laws, and its interaction with gradual types like `Any`.",
            "spof": true
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/regression/paramspec_on_python39.md",
            "description": "This file is a regression test case for `ParamSpec` usage on Python 3.9, specifically to prevent a panic related to `ParamSpec` being introduced in Python 3.10. It demonstrates expected errors when `ParamSpec` is incorrectly used in an exception handler on Python 3.9.",
            "spof": true
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/regression/2236_tuple_is_disjoint.md",
            "description": "This file is a regression test for issue #2236, verifying that if two complex tuple types are disjoint, neither can be a subtype of the other. It includes Python code demonstrating `is_subtype_of` and `is_disjoint_from` assertions for these types.",
            "spof": true
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/type_properties/is_single_valued.md",
            "description": "This markdown file serves as documentation and test cases for the `is_single_valued` type property, defining and illustrating which Python types are considered 'single-valued' (i.e., not empty and all inhabitants compare equal).",
            "spof": true
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/type_properties/materialization.md",
            "description": "This document explains type materialization, defining top (most general static) and bottom (most specific static) forms of a type. It details how `Any` and `Unknown` are replaced based on variance (covariant, contravariant, invariant) for various type constructs like callables and tuples.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/type_qualifiers/final.md",
            "description": "This markdown document details the `typing.Final` type qualifier in Python, explaining its behavior regarding type inference, immutability of names and attributes, and its usage in different scopes and class definitions. It also covers restrictions on reassignment and legal syntax positions for `Final`.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/unary/invert_add_usub.md",
            "description": "This markdown file documents and tests the behavior of Python's unary operators (`+`, `-`, `~`) with various type annotations. It demonstrates their usage with custom classes, `TypeVar`s bounded by `int` or `float`, and constrained `TypeVar`s, alongside examples of unsupported operations.",
            "spof": true
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/unary/custom.md",
            "description": "This file contains test cases demonstrating the behavior of custom unary operators (`+`, `-`, `~`) on Python class instances, classes, function literals, and metaclasses. It shows expected type inference and `unsupported-operator` errors in various scenarios.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/02_expr_attr.py",
            "description": "This file contains example Python code demonstrating simple attribute access expressions, likely used as test cases for type checking or semantic analysis of attribute resolution.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/02_expr_rel.py",
            "description": "A test corpus file demonstrating various Python relational comparison operators for semantic analysis.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/01_expr_unary.py",
            "description": "This file provides a corpus of unary expressions in Python, including negation, bitwise inversion, and logical not, likely for testing or analyzing type and semantic behavior.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/03_dict_ex.py",
            "description": "This file contains a minimal Python example demonstrating dictionary unpacking using the `**` operator, likely for testing or illustration purposes within the `ty_python_semantic` crate's corpus.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/00_const.py",
            "description": "This file defines basic Python constant values like None, True, False, and Ellipsis. It likely serves as a test case or corpus for the type checker or semantic analyzer within the `ruff` project.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/02_expr_binary.py",
            "description": "This file serves as a corpus of Python binary expressions, demonstrating various arithmetic and bitwise operations. It is likely used for testing or analysis within a semantic parsing or type-checking system.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/02_expr_attr_multiline_assign.py",
            "description": "This file contains a Python code snippet demonstrating a multiline assignment to an attribute of a function call result. It likely serves as a test case or example for semantic analysis, specifically for handling expression attributes and multiline assignments.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/06_funcall_kwargs.py",
            "description": "This file demonstrates passing keyword arguments to a function by unpacking a dictionary using the `**` operator.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/04_assign_attr.py",
            "description": "This file demonstrates simple attribute assignments, including nested attribute assignments, likely for testing or analyzing Python's semantic model for attribute modification.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/04_assign.py",
            "description": "This file contains basic variable assignments of different types (integer, string, tuple, dictionary) for demonstration or testing purposes.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/02_expr_bin_bool.py",
            "description": "This file provides a corpus of Python binary boolean expressions for semantic or type analysis testing within the `ruff` project. It includes examples of 'or' and 'and' operators, demonstrating their combination and precedence.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/04_assign_attr_func.py",
            "description": "This file contains a Python function 'foo' that demonstrates assigning a value to an attribute of an object. It likely serves as a test case for type or semantic analysis of attribute assignments within functions.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/00_expr_discard.py",
            "description": "This file contains various Python literal expressions (string, integer, float, bytes) intended for testing a semantic analysis or type-checking component. It serves as a corpus example for discarded expressions.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/03_set_multi.py",
            "description": "This file defines a dictionary containing sets with multiple data types, including strings, None, and tuples. It likely serves as test data for type analysis or semantic checks related to heterogeneous sets.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/03_list_ex.py",
            "description": "This file contains a single line demonstrating a list pattern with multiple starred unpackings. It likely serves as a test case for type or semantic analysis in a Python linter or static analyzer.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/03_tuple_ex.py",
            "description": "This file contains examples of Python tuple unpacking syntax using starred expressions. It likely serves as a test case for semantic analysis related to tuple types within the ruff project.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/11_if_else.py",
            "description": "This file contains a simple Python 'if/else' statement, likely serving as a basic test case or example for conditional control flow logic.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/04_aug_assign_attr_sub.py",
            "description": "This file demonstrates various augmented assignment operations in Python, specifically targeting attributes, indexed items, and slices.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/04_assign_named_expr.py",
            "description": "This file demonstrates the use of a named expression (walrus operator) in Python. It likely serves as a corpus example for semantic analysis within the ruff project.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/05_funcall_2.py",
            "description": "This file contains a simple function call with two arguments, likely used as a test case for semantic analysis or type checking of function calls.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/05_funcall_kw.py",
            "description": "This file provides a simple example of a function call utilizing keyword arguments for semantic or type analysis testing.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/13_ifelse_complex1.py",
            "description": "This file demonstrates basic conditional logic using 'if/else' statements, including a nested 'if/else' block.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/20_lambda_default_arg.py",
            "description": "Tests or exemplifies a lambda function with a default argument.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/08_del.py",
            "description": "This file contains various 'del' statements demonstrating their usage for deleting variables, list items, and object attributes. It likely serves as a test case or example for `del` statement analysis.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/05_funcall_kw_pos.py",
            "description": "This file provides a Python code example demonstrating a function call with both positional and keyword arguments, likely used for testing semantic analysis of function calls.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/10_if_chained_compare.py",
            "description": "This file contains a simple chained comparison within an if statement, likely serving as a test case or example for Ruff's Python semantic analysis (ty_python_semantic) relating to comparison operators.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/13_ifelse_many.py",
            "description": "This file contains a series of chained 'if/elif' statements, likely serving as a test case or example for handling multiple conditional branches.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/10_if.py",
            "description": "This file contains a simple if statement, likely serving as a test case for semantic analysis of conditional logic within the `ty_python_semantic` crate.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/06_funcall_varargs.py",
            "description": "This file demonstrates a Python function call using variable arguments (`*args`), where a tuple is unpacked into positional arguments. It likely serves as a test case for analyzing function calls with unpacked iterables.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/06_funcall_many_args.py",
            "description": "Tests a function call with a large number of positional arguments. It likely serves as a corpus example for type or semantic analysis tools to handle complex function signatures.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/11_if_else_true.py",
            "description": "This file is a corpus example for semantic analysis, demonstrating an `if/else` statement where the `if` condition is a constant `True`, making the `else` branch unreachable.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/21_func_assign.py",
            "description": "Tests basic variable assignment and usage within a function, likely for type analysis or semantic checks.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/03_list_large.py",
            "description": "Initializes a large list with 31 elements. This file likely serves as a test case within a corpus for semantic or type analysis tools, specifically for handling large list literals.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/10_if_false.py",
            "description": "This file contains various Python constructs placed within 'if' statements with conditions that are always false. It appears to serve as a test case for analyzing unreachable code, dead code elimination, or static analysis tools that identify such patterns.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/20_lambda_ifelse.py",
            "description": "This file contains a Python lambda function demonstrating a conditional expression (if-else). It likely serves as a test case for type checking or semantic analysis of lambda functions in a Python codebase.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/15_while_break_non_empty.py",
            "description": "Tests semantic analysis of a 'while' loop with a conditional 'break' statement, demonstrating non-empty loop execution if the condition 'a' is initially true.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/11_if_else_false.py",
            "description": "This file tests the handling of an 'if False' condition in a Python semantic analyzer. It demonstrates a code path that is never taken (the 'if' branch) and one that is always taken (the 'else' branch).",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/15_while_true.py",
            "description": "This file contains a simple infinite loop, likely used as a basic test case for analyzing loop constructs or dead code detection within a Python semantic analysis tool.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/20_lambda_const.py",
            "description": "This file contains a simple Python lambda expression, likely used as a test case for type analysis or semantic understanding of lambda functions.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/21_func1.py",
            "description": "This file contains a simple Python function `foo` with an undefined variable 'a', likely serving as a test case for type checking or semantic analysis.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/03_dict.py",
            "description": "This file contains a simple dictionary literal, used as a test case for type or semantic analysis in the `ruff` project.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/21_func1_ret.py",
            "description": "Defines a Python function 'foo' that returns an undefined variable 'a', likely for testing type inference or name resolution in a static analysis context.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/15_while_false.py",
            "description": "This file contains a 'while False' loop, which represents an unreachable code block. It likely serves as a test case for static analysis tools to detect dead code.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/15_while_break.py",
            "description": "This file contains a simple Python script demonstrating the use of a `break` statement within a `while` loop, likely for testing or example purposes.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/11_if_else_deeply_nested_for.py",
            "description": "This file contains a deeply nested if/else structure, including a for loop, likely serving as a test case for type-checking or semantic analysis in a Python linter or static analyzer.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/15_while_break_invalid_in_class.py",
            "description": "This file provides a corpus example demonstrating an invalid `break` statement placed directly within a class definition, likely for type-checking or semantic analysis testing.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/24_func_ifelse_ret.py",
            "description": "Defines a function `foo` that conditionally returns `b` or `c` based on the boolean value of its input `a`. This file likely serves as a test case for semantic analysis or type inference.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/24_func_ifnot_ret.py",
            "description": "Defines a function `foo` that returns `b` if the input `a` is falsey, otherwise returns `c`.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/16_for_break_invalid_in_func.py",
            "description": "This file provides a test case for an invalid 'break' statement usage, where 'break' is inside a function definition that is itself nested within a loop.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/30_func_enclosed.py",
            "description": "This file demonstrates a nested function accessing a variable from its enclosing scope, illustrating Python's closure behavior.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/15_while_continue.py",
            "description": "This file is a test case or corpus example demonstrating a basic 'while' loop with a 'continue' statement in Python. It likely serves to test static analysis or semantic understanding of such control flow.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/16_for_list_literal.py",
            "description": "This file contains a simple `for` loop iterating over a list literal, likely serving as a test case for static analysis or type checking tools.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/15_while_break_non_exit.py",
            "description": "This Python file appears to be a test case for control flow analysis. It demonstrates a `while` loop containing a `try-except` block with a `break` statement, followed by conditional code that might be unreachable depending on the loop's execution path.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/15_while_infinite.py",
            "description": "This file contains a simple Python script demonstrating an infinite `while` loop. It likely serves as a test case for semantic analysis in the Ruff project, specifically for identifying or handling infinite loop constructs.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/31_func_global.py",
            "description": "This file demonstrates the use of the `global` keyword to modify a global variable `a` from within the `foo` function.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/12_if_elif_else.py",
            "description": "This file provides a basic example of an 'if/elif/else' statement for testing or demonstrating Python's conditional logic within a semantic analysis context.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/15_while_break_in_finally.py",
            "description": "This file demonstrates a `while` loop with a `try...finally` block containing a `break` statement in the `finally` clause and a `continue` statement in the `try` clause. It likely serves as a test case for control flow analysis.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/16_for_nested_ifs.py",
            "description": "This file demonstrates a nested loop and conditional logic, iterating through a sequence and executing different branches based on multiple conditions.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/30_func_enclosed_many.py",
            "description": "This file contains a series of nested functions demonstrating variable scoping and closures, likely serving as a test case for a static analysis tool.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/22_func_arg.py",
            "description": "This file contains a simple Python function demonstrating basic function definition and argument handling, likely serving as a test case for type or semantic analysis tools.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/21_func_assign2.py",
            "description": "This file contains a Python function demonstrating a runtime NameError due to using a variable before its assignment. It likely serves as a test case for semantic analysis in tools like `ruff`.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/23_func_ret.py",
            "description": "Defines a simple Python function `foo` that accepts an argument and contains an empty return statement. This likely serves as a test case for function return behavior.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/16_for_break_invalid_in_class.py",
            "description": "This file contains an invalid `break` statement placed directly within a class definition. It likely serves as a test case for a linter or static analysis tool to identify incorrect usage of control flow statements.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/22_func_vararg.py",
            "description": "This file contains example Python functions demonstrating the use and handling of `*args` and `**kwargs` (variable positional and keyword arguments) in function definitions, likely for testing or semantic analysis purposes.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/25_func_annotations_scope.py",
            "description": "Tests how type annotations resolve scope within nested functions, specifically when an annotation refers to a variable in an outer scope.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/31_func_nonlocal.py",
            "description": "This file demonstrates the usage of the 'nonlocal' keyword within nested functions in Python, showing how an inner function can modify a variable in its immediately enclosing scope.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/56_yield_from.py",
            "description": "This file contains a simple Python function demonstrating the 'yield from' expression. It likely serves as a test case or example for semantic analysis of generator delegation.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/64_assert.py",
            "description": "Contains example `assert` statements, likely serving as a test case or corpus for static analysis related to assertions.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/53_list_comp_method.py",
            "description": "This file contains a Python code snippet demonstrating a list comprehension followed by a method call, likely used as a test case for type analysis or semantic understanding of such expressions.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/53_list_comp.py",
            "description": "This file contains a simple Python list comprehension. It likely serves as a test case or example within a type checking or semantic analysis corpus to validate handling of list comprehensions.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/59_async_with_nested_with.py",
            "description": "This file contains an asynchronous function demonstrating nested `async with` and `with` statements, likely serving as a test case for a type checker or linter.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/60_try_finally_ret.py",
            "description": "This file contains a Python function with a try-finally block where the finally block returns a value, likely for testing return behavior in finally clauses.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/58_async_for_continue.py",
            "description": "Tests the behavior of an 'async for' loop with a 'continue' statement inside an 'async def' function.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/62_try_except_cond.py",
            "description": "This file demonstrates a basic 'try-except' block where the exception handler conditionally assigns a value to 'y' based on the truthiness of 'x' or 'z'.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/60_try_except_bare.py",
            "description": "This file demonstrates a basic Python `try...except` block without specifying a particular exception type.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/60_try_finally_for.py",
            "description": "Demonstrates the use of a 'try...finally' block with a 'for' loop nested inside the 'finally' clause, likely for testing control flow or cleanup patterns.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/32_func_global_nested.py",
            "description": "This file serves as a test case for Python's `global` keyword used within a nested function definition. It demonstrates the behavior of `global bar` followed by the definition of `bar` as a nested function.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/23_func_ret_val.py",
            "description": "This file contains a simple Python function `foo` that takes an argument `a` and returns it, likely serving as a basic test case for function return values.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/60_try_finally_cond.py",
            "description": "This file contains a simple `try...finally` block with a conditional assignment (`y = x` if `x` is true) inside the `finally` block, likely used as a test case for control flow analysis.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/54_list_comp_recur_func.py",
            "description": "Defines a recursive function `recur1` that processes nested lists using a list comprehension. This file likely serves as a test case for recursive list comprehension behavior.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/60_try_finally.py",
            "description": "This file demonstrates a basic Python `try...finally` block structure, ensuring that `b` is executed regardless of the outcome of `a`.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/58_async_for_break.py",
            "description": "This file contains commented-out Python code demonstrating the use of 'break' within an 'async for' loop. It appears to be a test case or example within a semantic analysis corpus, possibly for analyzing asynchronous control flow.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/61_try_except_finally.py",
            "description": "This file demonstrates the basic structure and execution flow of a Python `try`, `except`, and `finally` block for exception handling.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/63_raise_func.py",
            "description": "This file contains a simple Python function `f` that re-raises the last active exception or a `RuntimeError` if none is active. It likely serves as a test case for exception handling mechanisms or control flow analysis.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/67_with_as.py",
            "description": "This file provides a simple example of a Python 'with...as' statement, likely used as a test case or corpus entry for semantic analysis within a larger project.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/58_async_for_set_comp.py",
            "description": "Tests an async function combining an async for loop within a set comprehension and a subsequent list comprehension. Likely a test case for async generator type analysis.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/26_func_defaults_same_name.py",
            "description": "Defines a function named `bool` which takes an argument `x` with a default value set to the built-in `bool` type. This likely serves as a test case for analyzing function default arguments or shadowing built-in names.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/67_with_multi_exit.py",
            "description": "This file demonstrates a 'with' statement containing an 'if/else' block, likely serving as a test case for control flow analysis within 'with' contexts.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/54_list_comp_func.py",
            "description": "This file defines a Python function `get_names` that uses a list comprehension to copy elements from an input list. It likely serves as a test case for semantic analysis or type checking of list comprehensions within functions.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/33_func_with_docstring_optimizable_tuple_and_return.py",
            "description": "This file is a test corpus demonstrating a Python function `__add__` with a docstring and a return statement, likely for semantic analysis or type checking within the ruff project.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/67_with_return.py",
            "description": "This file contains a Python function demonstrating a 'with' statement immediately followed by a 'return' statement, likely for testing control flow analysis.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/78_class_dec.py",
            "description": "This file contains a simple Python class decorated with a placeholder decorator, likely serving as a test case for class decorator handling.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/62_try_except_break.py",
            "description": "This file appears to be a test case for type inference or semantic analysis within the `ruff` project. It demonstrates a `while` loop containing a `try-except` block that can `break` the loop, alongside conditional assignments.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/70_class_doc_str.py",
            "description": "This file appears to be a test case for analyzing inline docstrings within class definitions, specifically for a class inheriting from 'list'.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/71_class_var.py",
            "description": "Defines a simple Python class 'C' with a single class variable 'var' initialized to 1.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/54_list_comp_lambda_listcomp.py",
            "description": "This file contains a Python function `f` that demonstrates a complex nested list comprehension involving a lambda function. It likely serves as a test case for semantic analysis or type inference within a static analysis tool like Ruff.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/62_try_except_return.py",
            "description": "This file contains a Python function demonstrating a return statement within an `except` block, likely serving as a test case for control flow analysis.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/67_with_as_func.py",
            "description": "This file contains a simple Python function demonstrating a `with` statement, likely used as a test case for semantic analysis of `with` blocks within functions.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/67_with_inside_try_finally_multiple_terminal_elif.py",
            "description": "This file contains a Python function demonstrating a 'try-finally' block with a 'with' statement and multiple 'if-elif' conditions, including 'return' statements. It likely serves as a test case for control flow analysis in the 'ty_python_semantic' module.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/69_for_try_except_continue3.py",
            "description": "This file demonstrates a Python 'for' loop with a 'try-except' block, using 'continue' within the exception handler to skip the current iteration upon error.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/75_classderef_no.py",
            "description": "This file defines a class `Foo` with a method `foo` that contains an inner function. It likely serves as a test case for analyzing variable scope and name resolution, specifically how a parameter (`bar`) is accessed within nested functions.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/68_with2.py",
            "description": "This file contains a Python 'with' statement utilizing multiple context managers. It likely serves as a test case or example for semantic analysis of such 'with' statements within the `ty_python_semantic` crate.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/72_class_mix.py",
            "description": "This file defines a Python class `C` demonstrating various class features, including class variables, methods, method aliasing, and different ways to access class members. It likely serves as a test case for semantic analysis of Python classes.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/78_class_dec_member_func.py",
            "description": "This file defines a Python class `C` with a decorator and an `__init__` method that initializes an instance variable, serving as a test case for semantic or type analysis of decorated classes with member functions.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/15_while_break_invalid_in_func.py",
            "description": "This file demonstrates an invalid use of the `break` statement inside a function, which cannot exit an outer `while` loop. It serves as a test case for semantic analysis or linting tools to identify such errors.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/71_class_meth.py",
            "description": "Defines a simple Python class 'C' with a method 'foo' that references 'self', likely serving as a basic test case for semantic analysis or type inference within the ruff project.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/79_metaclass.py",
            "description": "This file defines a Python class `Foo` that inherits from `Base` and explicitly uses a metaclass `Meta`. It likely serves as an example or test case for metaclass usage in Python.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/77_class__class__nonlocals.py",
            "description": "This file demonstrates an invalid use of `nonlocal __class__` within a nested class, likely serving as a test case for a linter or semantic analyzer to detect this specific syntax error.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/55_list_comp_nested.py",
            "description": "This file provides Python code examples featuring nested list comprehensions, both within a function definition and a lambda expression. It likely serves as a test case for semantic analysis or type checking tools, particularly to verify how `__qualname__` is handled in such constructs.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/62_try_except_as.py",
            "description": "This file demonstrates the behavior and scope of variables captured in `try-except-as` blocks. It tests that these exception-bound variables are properly localized within their respective handlers, including inside function definitions.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/74_just_super.py",
            "description": "This file is a corpus test case demonstrating the `super()` built-in function, both at the module level and within a function body.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/25_func_annotations_same_name.py",
            "description": "This file contains Python function definitions where function names are identical to their return type annotations, including a built-in type and a custom class. It likely serves as a test case for type resolution or name binding in static analysis.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/77_class__class__param_lambda.py",
            "description": "This file contains a test case demonstrating the behavior of a lambda function capturing a parameter named `__class__` within a nested function inside a class method, specifically for scope resolution analysis.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/76_class_nonlocal3.py",
            "description": "Tests the behavior of the `nonlocal` keyword within a nested class, specifically demonstrating how a class method can modify a variable from an enclosing function scope.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/77_class__class__.py",
            "description": "This file contains test cases exploring various 'pathologies' or unusual behaviors related to the `__class__` special variable within class definitions, as indicated by its source and comments. It examines how `__class__` behaves when reassigned or accessed under different scopes.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/89_type_alias.py",
            "description": "Defines type aliases for basic types and generic collections, demonstrating Python's `type` statement for type aliasing.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/85_match_in_func_with_rest.py",
            "description": "This file defines a Python function that demonstrates the use of a `match` statement with a mapping pattern to capture remaining items into a dictionary.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/93_deadcode.py",
            "description": "This file contains a Python function with unreachable code, likely serving as a test case for dead code detection or analysis within a linter or static analysis tool.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/85_match_in_func.py",
            "description": "Demonstrates a basic match statement within a function definition, likely for testing type semantic analysis of the match-case syntax in Ruff.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/77_class__class__param.py",
            "description": "Tests the semantic analysis of `__class__` when it is used as a parameter name for a nested function.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/80_func_kwonlyargs1.py",
            "description": "This file defines a Python function `foo` that includes positional, variadic positional (*y), keyword-only (x), and variadic keyword (**c) arguments. It likely serves as a test case for analyzing complex function signatures, particularly keyword-only arguments.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/76_class_nonlocal2.py",
            "description": "This file contains a test case demonstrating Python's scoping rules, specifically how class namespace manipulation using `locals()` and `del` affects variables from an enclosing scope.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/76_class_nonlocal1.py",
            "description": "This file tests Python's scope rules, specifically how a class's namespace, particularly its `locals()` dictionary, interacts with and potentially overrides an outer scope variable during class definition.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/67_with_inside_try_finally_preceding_terminal_except.py",
            "description": "This file provides a test case for control flow analysis, specifically examining a `with` statement nested within a `try` block that also contains an inner `try-except` block with a `return` statement, preceding a `finally` block. It is likely used to validate linter behavior related to such complex constructs.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/92_qual_class_in_func.py",
            "description": "This file demonstrates a Python class definition nested within a function.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/75_classderef.py",
            "description": "This file appears to be a test case, demonstrating a class definition nested within a function scope, with a call expression directly in the class body, likely for static analysis or linting purposes.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/90_docstring_mod.py",
            "description": "This file serves as a test corpus for Ruff's semantic analysis, specifically to examine how it handles module-level docstrings.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/90_docstring_class.py",
            "description": "This file defines a simple Python class `Foo` with a docstring. It likely serves as a test case for docstring analysis or semantic parsing.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/77_class__class__no_class.py",
            "description": "This file tests the behavior of the `__class__` attribute when accessed inside nested functions, specifically in a context where no enclosing class is present.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/92_qual_class_in_class.py",
            "description": "This file defines a nested class 'Foo' within an outer class 'Bar'. It likely serves as a test case for analyzing qualified class names or nested class definitions in a semantic analysis context.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/69_for_try_except_continue1.py",
            "description": "This file contains a Python code snippet demonstrating a `for` loop with a `try-except` block that includes a `continue` statement. It likely serves as a test case for control flow analysis, specifically examining how `continue` behaves within `try` blocks inside a loop.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/94_strformat_conv.py",
            "description": "This file contains a Python function demonstrating f-string formatting with various conversion flags (!r, !s, !a). It likely serves as a test case for string conversion behaviors.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/77_class__class__nested.py",
            "description": "This file contains a test case demonstrating the usage of `super()` within a deeply nested function inside a class method. It likely assesses how `super()` behaves or resolves in such a lexical scope.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/74_class_super_nested.py",
            "description": "This file is a test case for Ruff's type checker or semantic analysis module. It defines a nested class 'Foo' within a function, demonstrating the usage of 'super().__init__()' in its constructor and another method without a super call.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/95_annotation_class_no_value.py",
            "description": "Defines a simple Python class `F` with a type-annotated attribute `z: int` that has no assigned value. This file likely serves as a test case for analyzing type annotations within classes.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/74_class_kwargs_2.py",
            "description": "Tests how a type checker or semantic analyzer handles an invalid class definition that includes a keyword argument in its base class list.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/97_global_nonlocal_store.py",
            "description": "This file provides a test case demonstrating the use of the 'global' keyword within a nested function, specifically when a variable of the same name exists in an outer, non-global scope.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/77_class__class__nonlocals_2.py",
            "description": "This file appears to be a test case exploring the use of `nonlocal __class__` within a nested class definition. It tests assigning a value to `__class__` after declaring it nonlocal.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/95_annotation_class_multiline.py",
            "description": "This file defines a Python class `F` with attributes `x` (integer) and `y` (an optional forward-referenced type `C`). It likely serves as a test case or example for type annotations within class definitions, especially with multiline class bodies.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/95_annotation_global.py",
            "description": "This file appears to be a test case demonstrating a type annotation for a variable named 'some_global' within a function scope, likely for semantic analysis or type checking purposes.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/cyclic_pep695_typevars_invalid_bound.py",
            "description": "This file contains a test case demonstrating an invalid cyclic type variable bound, likely for use with PEP 695 type variable syntax analysis.",
            "spof": true
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/76_class_nonlocal5.py",
            "description": "This file is a test case, adapted from Python's standard library tests, designed to examine scoping rules involving nested functions and classes, particularly within the context of type or semantic analysis in the 'ruff' project.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/76_class_nonlocal4.py",
            "description": "This file is a test case demonstrating Python's scope resolution rules, specifically how a method within a nested class accesses a variable from an enclosing function's scope, even when a method with the same name exists within the class itself.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/cyclic_symbol_in_comprehension.py",
            "description": "This file is a regression test for a specific issue (https://github.com/astral-sh/ruff/pull/20962) in the Ruff linter, likely related to handling cyclic symbols in comprehensions or other complex Python constructs, which previously led to an error concerning 'too many cycle iterations'.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/subclass_of_any_passed_to_tuple.py",
            "description": "This file tests type analysis for subclassing an unresolved type and passing the resulting class to the built-in `tuple()` function, likely to observe error handling or type inference behavior.",
            "spof": true
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/88_regression_pr_20962.py",
            "description": "This file contains various Python syntax constructs, including dictionary comprehensions, decorators, multiple function definitions, and a match statement. It likely serves as a test case for a linter or static analyzer, focusing on semantic or type analysis behaviors, possibly as a regression test for a specific pull request.",
            "spof": true
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/cyclic_reassignment.py",
            "description": "This file is a corpus example demonstrating cyclic reassignments and redefinitions of a name (`foo`) within a Python script.",
            "spof": true
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/cyclic_pep695_typevars.py",
            "description": "This file contains a test case for PEP 695 type variable syntax, specifically demonstrating a generic function with a self-referential type variable bound. It also explores the use of a type variable-typed parameter within an `except` clause, likely for type checking analysis.",
            "spof": true
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/future_annotations_recursive_annotation.py",
            "description": "This file demonstrates the usage of `from __future__ import annotations` in Python. It includes a class with a type annotation using a built-in type name to test how postponed evaluation handles such cases.",
            "spof": true
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/cyclic_pep695_variance.py",
            "description": "This file defines various Python classes, protocols, and type aliases, including recursive types and generic classes using PEP 695 syntax. It likely serves as a test case for type checking scenarios involving cyclic type definitions and type variance.",
            "spof": true
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/91_line_numbers_dict.py",
            "description": "A test corpus file defining a basic Python dictionary literal, likely used for semantic analysis benchmarking, potentially related to line number tracking.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/95_annotation_string_tuple.py",
            "description": "This file serves as a test case for the `ruff` semantic analysis engine, specifically demonstrating a string-based type annotation for a variable `t` as a tuple containing a list of integers. It likely verifies the correct parsing and interpretation of postponed type evaluations.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/tests/corpus.rs",
            "description": "This file contains integration tests for the `ty_python_semantic` analysis engine, ensuring it can process a large corpus of Python and Python stub files from various sources (e.g., linter fixtures, typeshed) without panicking.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/src/dunder_all.rs",
            "description": "This file implements logic to determine the set of names defined in a Python module's `__all__` variable, handling various assignment and modification patterns, including imports from other modules.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/src/subscript.rs",
            "description": "This module provides utility functions and traits (`PyIndex`, `PySlice`) for performing Python-style indexing and slicing operations on Rust collections and iterators. It handles both positive and negative indices, as well as slice steps, emulating Python's semantics.",
            "spof": true
          },
          {
            "path": "crates/ty_python_semantic/src/python_platform.rs",
            "description": "Defines the `PythonPlatform` enum, which represents the target operating system or platform (e.g., Linux, Windows, macOS) for type resolution within the Python semantic analysis system.",
            "spof": true
          },
          {
            "path": "crates/ty_python_semantic/src/lib.rs",
            "description": "This file serves as the main entry point for the `ty_python_semantic` crate, defining its public API, registering default semantic lints, and configuring analysis settings related to Python type checking and code analysis.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/src/semantic_model.rs",
            "description": "This file defines the `SemanticModel` struct, which serves as the primary interface for Language Server Protocol (LSP) to query semantic information (like types, scopes, and completions) within a Python file. It supports analysis of the file's AST and sub-ASTs from string annotations.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/src/unpack.rs",
            "description": "This file defines data structures and associated logic for representing and analyzing unpacking operations in Python, such as those found in assignments, for loops, or `with` statements, using the Salsa framework for incremental semantic analysis.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/src/semantic_index.rs",
            "description": "This file defines and constructs a semantic index for a Python source file, centralizing information about scopes, definitions, expressions, and use-definition maps. It provides tracked queries to access various semantic data structures for analysis.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/src/place.rs",
            "description": "This file defines core data structures and enums (`Place`, `DefinedPlace`, `Definedness`, `TypeOrigin`, `Widening`) used in Python semantic analysis to represent the type, origin, and definedness of variables or expressions. It includes logic for type widening and descriptor handling.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/src/semantic_index/expression.rs",
            "description": "Defines the `Expression` struct, which represents an independently type-inferable expression within a Python source file, tracking its AST node, scope, and context (e.g., if it's a type annotation or part of an assignment).",
            "spof": true
          },
          {
            "path": "crates/ty_python_semantic/src/semantic_index/member.rs",
            "description": "This file defines data structures (`Member`, `MemberExpr`) for representing and analyzing member access expressions in Python code, such as attribute access (`x.y`) and subscripting (`x[1]`). It also tracks properties like whether a member is bound or an instance attribute.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/src/semantic_index/use_def.rs",
            "description": "This file defines and implements use-def analysis, a foundational component for type inference and checking in Python. It tracks variable bindings, declarations, and their types across control flow paths to detect type errors and enable type narrowing.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/src/semantic_index/symbol.rs",
            "description": "This file defines data structures for representing and managing symbols within a specific scope for semantic analysis. It includes `Symbol` (with flags indicating its properties like usage, binding, and scope), `ScopedSymbolId` for unique identification, and `SymbolTable` for efficient storage and lookup of these symbols.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/src/semantic_index/narrowing_constraints.rs",
            "description": "This module defines the data structures and operations for 'narrowing constraints' within the semantic index, which are used to constrain the types of bindings. It focuses on efficient storage and manipulation of these constraints, which are essentially lists of predicates.",
            "spof": true
          },
          {
            "path": "crates/ty_python_semantic/src/semantic_index/reachability_constraints.rs",
            "description": "This file defines and manages 'reachability constraints' using ternary decision diagrams (TDDs) to track conditions for code and binding reachability during semantic analysis, aiding in type-checking and control flow analysis.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/src/semantic_index/ast_ids.rs",
            "description": "This file defines structures and traits for assigning unique, scope-specific identifiers to AST expression nodes representing 'uses' (like variable names or attributes). It provides a mechanism to map these expressions to `ScopedUseId` within a given semantic scope.",
            "spof": true
          },
          {
            "path": "crates/ty_python_semantic/src/semantic_index/re_exports.rs",
            "description": "This file provides a visitor and a query (`exported_names`) to identify all global-scope symbols exported from a module, especially those exposed via wildcard imports (`from ... import *`), to support semantic indexing.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/src/semantic_index/scope.rs",
            "description": "This file defines data structures and enums for representing and managing scopes within a Python module, including their identifiers, kinds (e.g., module, class, function), visibility, and laziness. It is a core component for semantic analysis in Ruff.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/src/semantic_index/place.rs",
            "description": "This file defines structures and logic for representing and managing \"place expressions\" in Python code, such as simple symbols (e.g., `x`) or member access chains (e.g., `x.y.z[0]`), within the semantic analysis.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/src/semantic_index/definition.rs",
            "description": "This file defines the `Definition` struct, representing a program element's definition within a Python file and its scope for semantic analysis. It provides methods to extract information like names and docstrings from various types of definitions.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/src/semantic_index/builder.rs",
            "description": "This file defines the `SemanticIndexBuilder`, which traverses a Python module's Abstract Syntax Tree (AST) to construct a detailed semantic index. It manages scope information, tracks definitions, expressions, and use-def chains, and identifies semantic syntax errors within the module.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/src/semantic_index/use_def/place_state.rs",
            "description": "This file defines data structures and logic for tracking live bindings, declarations, and associated narrowing/reachability constraints for variables at different points in a Python program's control flow. It manages how definitions and their constraints propagate and merge across scopes for static analysis.",
            "spof": true
          },
          {
            "path": "crates/ty_python_semantic/src/semantic_index/builder/except_handlers.rs",
            "description": "This file defines data structures for managing and tracking the state of definitions and control flow snapshots across nested `try`/`except`/`finally` blocks during semantic analysis, particularly for handling `finally` branches.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/src/types/definition.rs",
            "description": "Defines the `TypeDefinition` enum, representing various Python type definitions like modules, classes, and functions, and provides methods to retrieve their file and range information for semantic analysis.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/src/types/builder.rs",
            "description": "This file implements smart builders for Python union and intersection types, ensuring they adhere to a set of invariants like disjunctive normal form (DNF) and optimized handling of literal types for efficiency.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/src/types/constraints.rs",
            "description": "This module defines and manages type constraints for type variables in Python's type system. It uses Binary Decision Diagrams (BDDs) to represent sets of constraints, allowing the system to determine under what conditions type properties hold true.",
            "spof": true
          },
          {
            "path": "crates/ty_python_semantic/src/types/class_base.rs",
            "description": "Defines the `ClassBase` enum, which represents the limited set of valid types that can serve as base classes in Python's inheritance, and provides methods for converting general `Type` objects into this restricted form.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/src/types/type_ordering.rs",
            "description": "This file defines a canonical ordering for Python types, primarily used to sort elements within union and intersection types for consistent comparison and equivalence checking.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/src/types/member.rs",
            "description": "This file defines the `Member` struct, which represents a Python class member or symbol's type and qualifiers within a semantic analysis context. It also provides functionality to infer the public type of a class member based on its scope and definitions.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/src/types/typed_dict.rs",
            "description": "This file defines the `TypedDictType` enum and related structures, managing Python's `TypedDict` types, including their schema, parameters, and the complex subtyping rules as specified in PEP 589.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/src/types/cyclic.rs",
            "description": "Provides a `CycleDetector` struct and associated logic for detecting cyclic relationships and managing recursion depth when processing or transforming recursive type structures, preventing infinite loops and stack overflows.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/src/types/subclass_of.rs",
            "description": "This file defines the `SubclassOfType` struct, which represents a type that is a given class object or any of its subclasses. It includes methods for constructing, converting, and analyzing relationships involving such types within the type system.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/src/types/tuple.rs",
            "description": "This file defines Rust types and logic for modeling Python tuple types within the Ruff type system, handling fixed- and variable-length tuples as well as heterogeneous, homogeneous, and mixed element types.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/src/types/enums.rs",
            "description": "This file defines structures and functions for analyzing Python `enum.Enum` classes. It extracts enum members, determines their types, and identifies aliases, including special handling for `enum.auto` and inheritance.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/src/types/instance.rs",
            "description": "This file defines and implements various Python type instances, including nominal, structural, tuple, and protocol instances. It provides methods for creating, checking, and comparing these instance types within the semantic type system.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/src/types/visitor.rs",
            "description": "This file defines a visitor trait for traversing the structure of Python types within the semantic analysis. It provides methods to visit various complex type constructs and helper functions to guide the traversal.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/src/types/unpacker.rs",
            "description": "This file implements a type inference mechanism for Python unpacking assignments, determining the types of individual target elements (e.g., in a list or tuple) based on the type of the value being unpacked.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/src/types/class.rs",
            "description": "This file defines structures and logic for representing and analyzing Python class types within Ruff's semantic analysis, focusing on classes with code generation capabilities like dataclasses, NamedTuples, and TypedDicts. It handles their Method Resolution Order (MRO), metaclass resolution, and generic specializations.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/src/types/special_form.rs",
            "description": "This file defines the `SpecialFormType` enum, which enumerates and categorizes specific runtime symbols from Python's `typing` module and similar extensions that are considered unique types within the type system model. It includes methods for determining the associated class and valid origin modules for each special form.",
            "spof": true
          },
          {
            "path": "crates/ty_python_semantic/src/types/call/arguments.rs",
            "description": "This file defines data structures and logic for representing and manipulating Python function or method call arguments, including their types, for semantic analysis and type checking purposes. It supports parsing arguments from the AST, handling various argument kinds (positional, keyword, variadic), and performing argument type expansion for overload resolution.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/src/types/infer/builder/annotation_expression.rs",
            "description": "This file implements the logic for inferring the type of Python annotation expressions. It handles various AST node types and considers deferred states and PEP 613 policies during type inference.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/src/types/infer/builder/type_expression.rs",
            "description": "This file implements the logic for inferring and validating Python type expressions (annotations) from the abstract syntax tree, handling various literal types, special forms like unions, and reporting invalid type forms.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_parser/src/semantic_errors.rs",
            "description": "This file implements a `SemanticSyntaxChecker` responsible for detecting and reporting AST-based semantic syntax errors in Python code, such as incorrect `import from __future__` usage, `return` outside a function, or `break` outside a loop.",
            "spof": false
          },
          {
            "path": "crates/ty_completion_eval/truth/import-deprioritizes-sunder/_zqzqzq",
            "description": "This directory contains a specific test case for evaluating Ruff's type completion logic, particularly focusing on scenarios where imports are deprioritized in relation to 'sunder'. It likely holds Python source files that represent the 'ground truth' for this particular type analysis scenario.",
            "spof": false
          },
          {
            "path": "crates/ty_completion_eval/truth/import-deprioritizes-dunder/__zqzqzq",
            "description": "This directory represents a Python package used as a test case or fixture within the `ruff` project's type completion evaluation. It specifically targets the scenario where `import` statements might influence the prioritization of dunder methods or attributes. The directory's name likely serves as a unique identifier for this particular test package.",
            "spof": false
          },
          {
            "path": "crates/ty_completion_eval/truth/modules-over-other-symbols/main.py",
            "description": "This file appears to be a test case for symbol resolution, specifically demonstrating access to the built-in 'os' module. It likely evaluates how module names are handled when potentially conflicting with other symbols.",
            "spof": true
          },
          {
            "path": "crates/ty_completion_eval/truth/tighter-over-looser-scope/main.py",
            "description": "This file demonstrates variable scope resolution within nested functions, specifically testing that a variable from a 'tighter' (more immediate) scope is prioritized during completion or suggestion.",
            "spof": true
          },
          {
            "path": "crates/ty_completion_eval/truth/typing-gets-priority/main.py",
            "description": "This file demonstrates type completion preferences, specifically showcasing when `typing` module symbols should be prioritized over symbols from other modules (like `asyncio`, `ast`, `ctypes`) and when project-specific imports take precedence.",
            "spof": true
          },
          {
            "path": "crates/ty_completion_eval/truth/typing-gets-priority/sub1.py",
            "description": "This file defines a local variable named `NoReturn`. It likely serves as a test case to demonstrate how local definitions interact with or override standard library type hints.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/control-flow-graph/async-for.py",
            "description": "This file serves as a test fixture for control flow graph analysis, specifically demonstrating various scenarios involving `async for` loops and their interaction with `else`, `return`, `continue`, and `break` statements.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_stdlib/src/typing.rs",
            "description": "This file provides utility functions for identifying and categorizing Python standard library types, especially generics and typing module elements, for use in static analysis.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_semantic/src/context.rs",
            "description": "Defines the `ExecutionContext` enum, which distinguishes whether a code reference occurs in a runtime or a typing-only context within the semantic analysis of Python code.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_semantic/src/branches.rs",
            "description": "This file defines `BranchId` for uniquely identifying program branches (like `if`/`else` arms) and the `Branches` structure to manage and navigate the parent-child relationships between these branches.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_semantic/src/definition.rs",
            "description": "This file defines the core data structures for representing Python program elements such as modules, classes, and functions, collectively termed 'Definitions'. It also includes logic for identifying and resolving the visibility of these definitions within a program.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_semantic/src/reference.rs",
            "description": "This file defines data structures for representing and managing both resolved and unresolved name references within a Python program during semantic analysis. It includes details such as their scope, context, and semantic flags.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_semantic/src/star_import.rs",
            "description": "Defines the `StarImport` struct, which represents a Python star import (e.g., `from module import *`) within the Ruff linter's semantic analysis module. It captures the import level and the imported module name.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_semantic/src/model.rs",
            "description": "This file defines the `SemanticModel` struct, which serves as the central data structure for storing and querying the semantic information of a Python module, including its AST nodes, scopes, bindings, and references.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_semantic/src/lib.rs",
            "description": "This file serves as the main library entry point for the `ruff_python_semantic` crate, re-exporting various modules that collectively implement semantic analysis functionalities for Python code.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_semantic/src/scope.rs",
            "description": "This file defines the `Scope` struct and related types, which are used to represent and manage the hierarchical structure of lexical scopes in a Python program, including their bindings and imports.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_semantic/src/globals.rs",
            "description": "This module provides data structures and logic to identify, store, and query names declared as `global` within different scopes of a Python program during semantic analysis.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_semantic/src/binding.rs",
            "description": "This file defines the `Binding` struct, which represents a named entity (like a variable, function, or class) in Python code. It stores detailed information about the binding's kind, scope, usage, and various flags relevant to static analysis.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_semantic/src/analyze/mod.rs",
            "description": "This file serves as the main module for semantic analysis components within the `ruff_python_semantic` crate. It re-exports submodules related to analyzing Python classes, function types, imports, type inference, typing, and visibility, among others.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_semantic/src/analyze/visibility.rs",
            "description": "This file defines an enumeration for `Visibility` (Public/Private) and provides utility functions to determine the visibility of Python modules, functions, methods, and classes based on their naming conventions, decorators, and semantic analysis.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_semantic/src/analyze/logging.rs",
            "description": "This file contains functions for analyzing Python code to identify logging calls and related arguments, like `exc_info`, within the semantic model.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_semantic/src/analyze/function_type.rs",
            "description": "This file provides utilities for analyzing and classifying Python functions within a semantic model, determining their type (e.g., static method, class method, instance method) and other properties like whether they are stubs or subject to the Liskov Substitution Principle.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_semantic/src/analyze/class.rs",
            "description": "This file provides utility functions for analyzing Python class definitions within the semantic model, including traversing class inheritance hierarchies and checking for specific class members or properties.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_semantic/src/analyze/typing.rs",
            "description": "This file provides analysis rules and utility functions for identifying and interpreting various constructs from Python's `typing` module and type annotations within the Ruff semantic model.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_semantic/src/analyze/terminal.rs",
            "description": "This file defines the `Terminal` enum and logic to analyze the control flow of Python functions. It determines how a function or code block terminates, such as always returning, always raising an exception, or conditionally returning/raising.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_semantic/src/cfg/mod.rs",
            "description": "This file defines the control flow graph (CFG) module, including sub-modules for graph construction and visualization. It also contains snapshot tests to verify the generation and visualization of CFGs for Python code.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_semantic/src/cfg/graph.rs",
            "description": "This file implements the construction of a Control Flow Graph (CFG) for Python statements. It defines structures for the graph, basic blocks, and edges, and provides a builder to process statements and establish control flow paths.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_semantic/src/cfg/visualize.rs",
            "description": "This file provides functionality to visualize a Control Flow Graph (CFG) by converting its structure into Mermaid graph syntax. It defines traits and structures for representing nodes, edges, and their styling in Mermaid, and then implements the conversion for `ControlFlowGraph` objects.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_semantic/src/cfg/snapshots",
            "description": "This directory is designated to store test snapshots specifically for the Control Flow Graph (CFG) analysis within the `ruff_python_semantic` crate. These snapshots are typically used during testing to validate the correctness and consistency of CFG generation against expected outputs.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_semantic/src/model/all.rs",
            "description": "This file provides utilities for semantic analysis of `__all__` definitions in Python. It extracts names from `__all__` assignments and identifies issues such as invalid formats or non-string members within the definition.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_semantic/resources/test/fixtures/cfg/jumps.py",
            "description": "This file contains test fixtures for Control Flow Graph (CFG) analysis, demonstrating various scenarios involving `return` and `raise` statements and their impact on code reachability.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_semantic/resources/test/fixtures/cfg/no_flow.py",
            "description": "This file contains a series of simple Python function definitions, designed as a test fixture for Control Flow Graph (CFG) analysis, specifically for scenarios demonstrating basic execution with no complex control flow constructs like loops or conditionals.",
            "spof": true
          }
        ],
        "contributors": [
          {
            "name": "Douglas Creager",
            "percent": 20
          },
          {
            "name": "Charlie Marsh",
            "percent": 14
          },
          {
            "name": "Alex Waygood",
            "percent": 11
          }
        ]
      }
    },
    "stats": {
      "totalFiles": 1022,
      "spofCount": 606
    },
    "busFactor": 2,
    "authorCount": 37
  },
  "Infrastructure": {
    "description": "",
    "functions": {
      "Build & Configuration": {
        "files": [
          {
            "path": "docs/stylesheets",
            "description": "This directory is intended to store CSS stylesheets used for styling and formatting the project's documentation. Its purpose is to define the visual presentation of the `ruff` documentation.",
            "spof": false
          },
          {
            "path": "docs/integrations.md",
            "description": "This document outlines various integrations for Ruff, providing configuration examples for tools and platforms such as GitHub Actions, GitLab CI/CD, pre-commit hooks, mdformat, and Docker.",
            "spof": false
          },
          {
            "path": "docs/assets",
            "description": "This directory is intended to house static assets such as images, stylesheets, or other media files used within the documentation of the `ruff` project. It serves to support and enhance the content of the project's official documentation.",
            "spof": false
          },
          {
            "path": "docs/versioning.md",
            "description": "This document describes Ruff's custom versioning scheme, detailing what changes trigger minor versus patch version increases, and explains concepts like preview mode, rule stabilization, and fix stabilization.",
            "spof": false
          },
          {
            "path": "docs/.overrides/partials/integrations/analytics",
            "description": "This directory is designated to store custom partials (reusable documentation components) specifically for analytics-related integrations, overriding default documentation components. It would house snippets or templates for documenting analytics setup within other tools.",
            "spof": false
          },
          {
            "path": "python/ruff/__main__.py",
            "description": "This file acts as a bootstrap script to locate the `ruff` executable within various Python installation environments and then executes it with the provided command-line arguments.",
            "spof": false
          },
          {
            "path": "scripts/transform_readme.py",
            "description": "This script modifies the README.md file to adjust how images are rendered, specifically for light and dark modes, to support different deployment targets like PyPI or MkDocs instead of the default GitHub rendering.",
            "spof": true
          },
          {
            "path": "scripts/add_rule.py",
            "description": "This script generates boilerplate code and files for a new linting rule within the Ruff linter project. It automates the creation of test fixtures, Rust rule definitions, and necessary code registrations.",
            "spof": false
          },
          {
            "path": "scripts/add_plugin.py",
            "description": "This script generates boilerplate code and directory structures for integrating a new Flake8 plugin into the Ruff linter project. It automates the creation of necessary files and modifications to existing Rust source files to register the new plugin.",
            "spof": false
          },
          {
            "path": "crates/ty/CONTRIBUTING.md",
            "description": "This document provides guidelines for contributing to the 'ty' project, covering setup, development workflow, testing, project structure, and coding standards. It's an essential guide for new and existing contributors.",
            "spof": false
          },
          {
            "path": "crates/ty/build.rs",
            "description": "This build script (`build.rs`) retrieves and sets environment variables for the Rust crate, including the host target, version from `dist-workspace.toml`, and Git commit information (hash, date, and tags).",
            "spof": false
          },
          {
            "path": "crates/ty/src/version.rs",
            "description": "This file defines structures and functions to retrieve and format the application's version number and associated git commit information. It reads build-time environment variables to construct version details.",
            "spof": true
          },
          {
            "path": "crates/ty/src/logging.rs",
            "description": "This file sets up and configures the logging system for the 'ty' crate, handling verbosity levels, terminal coloring, and custom formatting for log events.",
            "spof": false
          },
          {
            "path": "crates/ruff/src/version.rs",
            "description": "This file defines data structures and functions to represent and retrieve Ruff's release version number, including associated Git commit information. It constructs the version details from compile-time environment variables set by Cargo and a `build.rs` script.",
            "spof": true
          },
          {
            "path": "crates/ruff/src/args.rs",
            "description": "This file defines the command-line interface (CLI) arguments and subcommands for the Ruff linter and formatter, using the `clap` crate to parse user input.",
            "spof": false
          },
          {
            "path": "crates/ruff/src/resolve.rs",
            "description": "This file implements the logic for resolving Ruff's configuration settings, determining the correct `pyproject.toml` or default settings to use based on a priority order of user arguments, project structure, and fallback mechanisms.",
            "spof": false
          },
          {
            "path": "crates/ruff/src/commands/clean.rs",
            "description": "This file provides the `clean` command for Ruff, which recursively finds and removes all Ruff cache directories (`.ruff_cache`) within the current working directory and its subdirectories.",
            "spof": false
          },
          {
            "path": "crates/ruff/src/commands/config.rs",
            "description": "This file defines the `config` command, which allows users to view available configuration options and their details, either all of them or a specific one, in text or JSON format.",
            "spof": false
          },
          {
            "path": "crates/ruff/src/commands/completions/config.rs",
            "description": "This file defines a custom `clap` argument parser and completion provider for Ruff's configuration options, enabling tab completion for `ruff option [OPTION]` commands. It collects all available Ruff options and their documentation to offer as possible values.",
            "spof": true
          },
          {
            "path": "crates/ruff/src/commands/completions/mod.rs",
            "description": "This file acts as the module declaration for CLI shell completions in Ruff, primarily exposing its `config` submodule which likely defines completion-related configurations.",
            "spof": true
          },
          {
            "path": "crates/ruff/tests/config.rs",
            "description": "This file contains unit tests for the `ruff config` subcommand. It verifies the behavior and output of the command when querying configuration options.",
            "spof": false
          },
          {
            "path": "crates/ruff/tests/version.rs",
            "description": "This file contains unit tests for the `ruff --version` command, ensuring it displays the correct version information and handles global options like `--config` and `--isolated` appropriately.",
            "spof": false
          },
          {
            "path": "crates/ruff/build.rs",
            "description": "This build script extracts Git commit and tag information (like hash, date, and nearest tag) at compile time and exposes it as environment variables to the Rust application. It also ensures the build reruns if Git metadata changes.",
            "spof": true
          },
          {
            "path": "crates/ty_python_semantic/src/types/property_tests/setup.rs",
            "description": "This file provides a utility to lazily initialize and cache a `TestDb` instance. It ensures that a single database instance is used across multiple tests, improving test performance and consistency.",
            "spof": true
          },
          {
            "path": "crates/ruff_server/src/logging.rs",
            "description": "This file implements and configures the logging system for the `ruff server`. It allows setting the log level and directing output to either `stderr` or a specified log file, using the `tracing` library.",
            "spof": true
          },
          {
            "path": "crates/ruff_server/src/server/schedule/thread.rs",
            "description": "This module provides a utility for spawning and managing threads, enforcing explicit thread priorities (Quality of Service) and offering controlled thread termination (join/detach) upon drop.",
            "spof": true
          },
          {
            "path": "crates/ruff_server/src/server/schedule/thread/pool.rs",
            "description": "This file implements a custom thread pool (`Pool`) for `ruff_server` that manages worker threads, allowing tasks to be spawned with specified thread priorities and handling panics by aborting the process.",
            "spof": false
          },
          {
            "path": "crates/ruff_server/src/server/schedule/thread/priority.rs",
            "description": "This file provides a platform-agnostic abstraction for thread priority (`ThreadPriority`) and maps it to platform-specific Quality of Service (QoS) classes, primarily for Apple operating systems. It allows setting and querying the QoS class for the current thread.",
            "spof": true
          },
          {
            "path": "crates/ruff_db/src/system.rs",
            "description": "This file defines the `System` trait, an abstraction layer for interacting with the host system's file system and environment, enabling Ruff to operate consistently across different platforms like CLI, LSP, and WASM.",
            "spof": true
          },
          {
            "path": "crates/ruff_db/src/system/os.rs",
            "description": "This file implements the `System` trait using the operating system's file system, providing functionalities like path metadata retrieval, file reading, directory walking, and environment variable access. It handles OS-specific details such as case sensitivity and standard directory locations.",
            "spof": true
          },
          {
            "path": "crates/ruff_db/src/diagnostic/render/gitlab.rs",
            "description": "This file implements a `GitlabRenderer` responsible for formatting diagnostic messages into a GitLab Code Quality report (JSON format). It serializes diagnostics, calculates unique fingerprints, and relativizes file paths for display in GitLab CI.",
            "spof": true
          },
          {
            "path": "crates/ruff_db/src/diagnostic/render/azure.rs",
            "description": "This file defines the `AzureRenderer` responsible for formatting diagnostic messages into a specific `##vso[task.logissue]` format, suitable for logging warnings and errors in Azure DevOps pipelines.",
            "spof": true
          },
          {
            "path": "crates/ruff_db/src/diagnostic/render/github.rs",
            "description": "This file implements a renderer for diagnostic messages, formatting them into GitHub Actions workflow commands for annotations. It maps diagnostic severities to GitHub annotation types and includes file, line, and column information when available.",
            "spof": true
          },
          {
            "path": "crates/ty_wasm/build.rs",
            "description": "This build script (`build.rs`) retrieves the current Git commit information, making the short hash available to the Rust crate via an environment variable (`TY_WASM_COMMIT_SHORT_HASH`). It also configures Cargo to re-run the build if the Git HEAD or relevant ref changes.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/src/test.rs",
            "description": "This file contains helper functions and utilities specifically designed for testing the linter's rule implementations and fixing capabilities, including diagnostic comparison and fix convergence checks.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_django/rules/locals_in_render_function.rs",
            "description": "This file implements a Ruff linter rule (DJ003) that detects and flags the use of `locals()` as the context argument in Django's `render` functions. It aims to prevent the unintentional exposure of internal variables in rendered templates.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_slots/rules/mod.rs",
            "description": "This module acts as an aggregator, re-exporting and organizing individual rules related to the `flake8_slots` lint, specifically for preventing the use of `__slots__` in subclasses of `NamedTuple`, `str`, and `tuple`.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/src/rules/tryceratops/rules/raise_vanilla_class.rs",
            "description": "This file implements a lint rule (TRY002) for the Ruff linter that identifies and flags instances where generic `Exception` or `BaseException` classes are raised directly.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pylint/rules/if_stmt_min_max.rs",
            "description": "This file implements a Ruff rule (PLR1730, PLR1731) that identifies `if` statements which can be refactored into more concise `min()` or `max()` function calls, and provides a fix for them.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/airflow/AIR302_druid.py",
            "description": "This file is an Airflow test fixture that imports and instantiates various Druid-related hooks and operators for testing purposes, specifically for rule AIR302.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_django/DJ003.py",
            "description": "This file provides test cases for the `flake8-django` linter rule DJ003, which likely identifies problematic uses of `locals()` as the context argument for Django's `render` function.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_datetimez/DTZ003.py",
            "description": "This file serves as a test fixture for the `flake8_datetimez` linter rule DTZ003, demonstrating various qualified and unqualified uses of `datetime.datetime.utcnow()` for detection.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_datetimez/DTZ007.py",
            "description": "This file serves as a test fixture for the `DTZ007` rule within the `flake8_datetimez` linter, demonstrating various correct and incorrect uses of `datetime.datetime.strptime` related to timezone handling, particularly focusing on the use of `%Z` versus `%z` and subsequent timezone adjustments.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_pyi/PYI006.py",
            "description": "This file serves as a test fixture for the `ruff` linter's `PYI006` rule, demonstrating valid and invalid Python version comparisons using `sys.version_info`.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_pyi/PYI062.py",
            "description": "This file is a test fixture for a linter rule (PYI062) that detects redundant or duplicate arguments within `typing.Literal` type hints, showcasing various cases including nested literals and different data types.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_pyi/PYI051.py",
            "description": "This file is a test fixture for the `flake8_pyi` linter's `PYI051` rule. It demonstrates type hints using `typing.Literal` and `typing.Union` to show cases that should be simplified by the linter, alongside their corrected (`# OK`) versions.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_return/RET502.py",
            "description": "This file contains Python code examples designed to test the `flake8-return` linter rule RET502, which checks for inconsistent return values within a function.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_type_checking/TC005.py",
            "description": "This file serves as a test fixture for the 'TC005' rule in a linter, demonstrating various valid and invalid uses of `if TYPE_CHECKING:` blocks for type checking-related code.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pylint/potential_index_error.py",
            "description": "This file contains test cases for a linter rule (PLE0643) detecting potential `IndexError` when accessing lists with out-of-bounds indices, along with examples of valid list access.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/ruff/RUF009_deferred.py",
            "description": "Test fixture for the RUF009 linter rule, demonstrating deferred evaluation of mutable default arguments in a dataclass, including `ClassVar` usage.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/ruff/RUF052_1.py",
            "description": "This file contains test cases for the `RUF052` rule in the Ruff linter, demonstrating scenarios where dummy variables (prefixed with `_`) are incorrectly accessed within loops and comprehensions.",
            "spof": true
          },
          {
            "path": "crates/ty_project/src/metadata/pyproject.rs",
            "description": "This file defines data structures and deserialization logic for `pyproject.toml` files, including project metadata, tool-specific configurations (like Ruff's `ty` options), and Python package name normalization. It also provides functionality to resolve Python version requirements from `requires-python`.",
            "spof": true
          },
          {
            "path": "crates/ty_project/src/metadata/options.rs",
            "description": "Defines the top-level configuration options for the 'ty' tool, including environment, rules, and overrides, and provides methods to deserialize these options from TOML and convert them into concrete program settings.",
            "spof": false
          },
          {
            "path": "crates/ty_project/src/metadata/settings.rs",
            "description": "This file defines the project's resolved settings structure, including global configurations and file-specific overrides. It contains logic to determine and merge the effective settings for any given file based on defined override patterns.",
            "spof": true
          },
          {
            "path": "crates/ty_project/src/metadata/value.rs",
            "description": "This file defines types and mechanisms to track the origin (e.g., file, CLI, editor) and optional text range of configuration values. It uses a `RangedValue` wrapper to attach source information to data, particularly for paths (`RelativePathBuf`), during deserialization.",
            "spof": true
          },
          {
            "path": "crates/ruff_workspace/src/options.rs",
            "description": "This file defines the core configuration options (`Options` struct) for the Ruff linter and formatter, including settings for caching, output, fixing behavior, file exclusion/inclusion, and version requirements.",
            "spof": false
          },
          {
            "path": "crates/ruff_workspace/src/configuration.rs",
            "description": "This file defines the `Configuration` struct, which represents user-provided program settings for Ruff, consolidating options from `pyproject.toml` and command-line arguments. It includes logic to resolve and convert these configurations into internal `Settings` used by the linter, formatter, and analyzer.",
            "spof": false
          },
          {
            "path": "crates/ruff_workspace/src/settings.rs",
            "description": "This file defines the core settings and configuration structures for the `ruff` tool, including overall application behavior, file resolution rules, and Python code formatting options.",
            "spof": false
          },
          {
            "path": "crates/ruff_workspace/src/lib.rs",
            "description": "This file serves as the main library module for the `ruff_workspace` crate, defining and exporting structures and modules for handling workspace-level configuration, options, and settings within the Ruff linter.",
            "spof": true
          },
          {
            "path": "crates/ty_static/src/lib.rs",
            "description": "This file is the main entry point for the `ty_static` crate, primarily defining and re-exporting modules related to environment variables.",
            "spof": false
          },
          {
            "path": "crates/ty_server/src/logging.rs",
            "description": "This file initializes and configures the logging system for the `ty server` component. It supports setting a log level, directing output to a file or stderr, and filtering log messages based on their level and target.",
            "spof": false
          },
          {
            "path": "crates/ty_server/src/server/schedule/thread.rs",
            "description": "This module provides a controlled mechanism for spawning threads, enforcing explicit thread priority settings and automatically managing thread lifecycle (joining or detaching) upon the completion of their associated join handles.",
            "spof": false
          },
          {
            "path": "crates/ty_server/src/server/schedule/thread/priority.rs",
            "description": "This file defines and manages thread priorities by mapping internal priority levels to platform-specific Quality of Service (QoS) classes, particularly for Apple operating systems. It allows setting and querying the priority of the current thread to optimize resource allocation for different types of work.",
            "spof": true
          },
          {
            "path": "playground/ruff/vite.config.ts",
            "description": "This file configures Vite for a React application, integrating the React plugin and Tailwind CSS for styling.",
            "spof": true
          },
          {
            "path": "playground/ty/vite.config.ts",
            "description": "This file configures Vite for a web project, integrating React and Tailwind CSS. It specifically handles the static copying of Pyodide assets to the build output, excluding certain file types, and manages dependency optimization.",
            "spof": true
          },
          {
            "path": "assets/png",
            "description": "This directory is designated to store PNG image assets for the `ruff` project. It serves as a dedicated location for graphical elements and is currently empty, potentially awaiting future content.",
            "spof": false
          },
          {
            "path": "assets/badge",
            "description": "This directory is designated to store assets such as images or configuration files for badges related to the `ruff` project. These badges are typically used to display status, version, or other project metrics. They would commonly be embedded in the project's README or documentation.",
            "spof": false
          }
        ],
        "contributors": [
          {
            "name": "Micha Reiser",
            "percent": 44
          },
          {
            "name": "Brent Westbrook",
            "percent": 13
          },
          {
            "name": "Dhruv Manilawala",
            "percent": 4
          }
        ]
      }
    },
    "stats": {
      "totalFiles": 67,
      "spofCount": 32
    },
    "busFactor": 4,
    "authorCount": 24
  },
  "Code Formatter": {
    "description": "An extremely fast, Black-compatible code formatter that automatically standardizes Python code style. It ensures consistent formatting across the entire codebase, improving readability and developer productivity.",
    "functions": {
      "Testing and Black Compatibility Infrastructure": {
        "files": [
          {
            "path": "docs/formatter/black.md",
            "description": "This document details the known, intentional differences in code style between the Black formatter and Ruff's formatter. It provides examples and explanations for each deviation.",
            "spof": false
          },
          {
            "path": "crates/ruff/tests/cli/format.rs",
            "description": "This file contains command-line interface (CLI) tests for the `ruff format` command. It verifies various aspects of the formatter's behavior, including default options, file handling, configuration overrides, and error conditions.",
            "spof": false
          },
          {
            "path": "crates/ruff/resources/test/fixtures/unformatted.py",
            "description": "This file contains intentionally unformatted Python code. It likely serves as a test fixture for a linter or formatter (such as Ruff) to verify its ability to detect and correct formatting issues.",
            "spof": false
          },
          {
            "path": "crates/ruff/resources/test/fixtures/unformatted.md",
            "description": "This file serves as a test fixture containing unformatted Python and Python interface (pyi) code blocks within a Markdown document. It is likely used to test Ruff's formatting capabilities for code embedded in Markdown.",
            "spof": true
          },
          {
            "path": "crates/ruff/resources/test/fixtures/formatted.py",
            "description": "This file serves as a test fixture containing a Python script that is already correctly formatted. It is likely used to test a linter or formatter's ability to recognize already formatted code without making changes.",
            "spof": false
          },
          {
            "path": "crates/ruff_annotate_snippets/tests/formatter.rs",
            "description": "This file contains unit tests for the `ruff_annotate_snippets` crate's formatter, verifying its ability to correctly render code snippets with annotations, line numbers, and various formatting options, including handling multi-byte characters and line breaks.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/CONTRIBUTING.md",
            "description": "This document outlines the development workflow and internal details for contributing to the Ruff Python formatter. It covers topics such as testing changes, adding new syntax, and handling comments.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_formatter/src/comments/snapshots",
            "description": "This directory contains snapshot test files specifically for the comment formatting logic within the `ruff_python_formatter` crate. These snapshots act as golden files, ensuring that any modifications to the formatter consistently produce the expected output for comments and prevent regressions.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_formatter/src/snapshots",
            "description": "This directory is intended to store test snapshots for the `ruff_python_formatter` crate. These snapshots are crucial for comparing the formatter's output against expected results during testing, thereby ensuring consistent and correct formatting behavior.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_formatter/tests/fixtures.rs",
            "description": "This file defines test fixtures and functions for the `ruff_python_formatter` crate. It includes tests for Black compatibility, general formatting behavior with various options, and snapshot generation.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/tests/normalizer.rs",
            "description": "This file defines an AST Normalizer that transforms Python Abstract Syntax Tree (AST) nodes to enable semantic comparison, specifically to ignore non-semantic differences introduced by formatting, such as whitespace changes in strings or specific AST structures.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_formatter/tests/snapshots",
            "description": "This directory contains snapshot test files for the `ruff_python_formatter` crate. These snapshots serve as expected output references, ensuring that changes to the formatter's logic do not inadvertently alter the formatted Python code in unintended ways. During testing, the actual output is compared against these stored files to detect regressions.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/import_black_tests.py",
            "description": "This script imports test fixtures from the Black formatter's repository, converting them into a format suitable for Ruff's own test suite, including parsing input, expected output, and Black-specific configuration flags.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/ruff/docstring.py",
            "description": "This file contains a collection of Python functions and classes designed to test the formatting of docstrings, including various indentation styles, backslash handling, comments before/after docstrings, and different quote types.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/ruff/docstring_code_examples_crlf.py",
            "description": "Tests how the Ruff Python formatter handles CRLF line endings within docstring code examples, specifically in doctests.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/ruff/fluent.py",
            "description": "This file serves as a test fixture for `ruff_python_formatter`, specifically demonstrating and testing the fluent formatting of Python call chains. It includes various examples of method chaining and subscripting to verify the formatter's behavior.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/ruff/tab_width.py",
            "description": "Tests how the Ruff formatter handles line wrapping and tab width configurations. It includes examples of lines designed to fit within specific tab width settings (2, 4, and 8).",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/ruff/docstring_non_visible_characters.py",
            "description": "This file is a test fixture for the Ruff Python formatter, specifically a regression test for issue #11724. It verifies how the formatter handles docstrings containing non-visible or unusual characters.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/ruff/docstring_newlines.py",
            "description": "This file contains test fixtures for the Ruff Python formatter, specifically designed to verify its behavior in preserving newlines within docstrings, especially before the closing quotes.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/ruff/blank_line_before_class_docstring.py",
            "description": "This file contains test cases for formatting Python class docstrings, specifically focusing on the placement of blank lines and comments before the docstring.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/ruff/f-string-carriage-return-newline.py",
            "description": "This file is a test fixture for the ruff Python formatter, demonstrating how it handles f-strings and regular strings that contain newline characters within their literals. It serves as a regression test for issue #18667.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/ruff/multiline_string_deviations.py",
            "description": "This file serves as a test fixture for the Ruff Python formatter, specifically documenting and showcasing deviations in multiline string formatting compared to Black's style.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/ruff/module_dangling_comment2.py",
            "description": "This file appears to be a Python stub or module re-exporting various symbols related to X-related libraries. It explicitly defines its public API using `__all__`.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/ruff/form_feed.py",
            "description": "This file is a regression test fixture for the Ruff Python formatter, specifically to verify its handling of form feed characters (U+000C) in source code, addressing issue #7624.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/ruff/trailing_comments.py",
            "description": "This file serves as a test fixture for the Ruff Python formatter, specifically to verify its handling of various trailing comments, including pragmas like 'noqa' and 'type', and the presence of non-breaking spaces.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/ruff/pattern_match_regression_brackets.py",
            "description": "This file is a test fixture for the Ruff Python formatter, ensuring it correctly handles bracket formatting in pattern matching `case` statements, specifically preventing a regression where brackets might be incorrectly added around tuples, deviating from Black's style.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/ruff/notebook_docstring.py",
            "description": "This file is a test fixture for the Ruff Python formatter, designed to verify that a docstring-like multiline string is correctly preserved in a non-notebook context. It ensures the formatter leaves such strings unchanged, as they are not true docstrings in this scenario.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/ruff/preview.py",
            "description": "This file serves as a test fixture for the Ruff Python formatter, showcasing various formatting behaviors and 'preview' features from Black, such as docstring newlines, dummy implementations, raw docstring handling, and assignment splitting.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/ruff/docstring_tab_indentation.py",
            "description": "This file contains test cases for a Python formatter, specifically examining its behavior when handling various indentation styles (tabs, spaces, and mixed) within docstrings. It focuses on scenarios like preserving tab indentation, handling space-aligned arguments, and maintaining ASCII art formatting.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/ruff/docstring_chaperones.py",
            "description": "This file contains test fixtures for the Ruff Python formatter, demonstrating how it handles various escape sequences and quotes within docstrings, particularly in relation to a 'chaperone' logic.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/ruff/docstring_code_examples.py",
            "description": "This file provides test fixtures for the `ruff_python_formatter` to ensure correct formatting of Python code snippets within docstrings. It covers various scenarios for both doctest and reStructuredText code examples, including valid cases and those expected to be skipped.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/ruff/quote_style.py",
            "description": "This file serves as a test fixture for the Ruff Python formatter, showcasing various Python string literal types and quote styles, including single/double quotes, raw, f-strings, byte strings, and triple-quoted docstrings, to ensure consistent formatting.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/ruff/docstring_code_examples_dynamic_line_width.py",
            "description": "This file serves as a test fixture for a Python formatter, verifying its ability to correctly format code examples within docstrings, particularly with respect to dynamic line width, indentation, and line wrapping behavior.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/ruff/trivia.py",
            "description": "This file serves as a test fixture for the `ruff` Python formatter, demonstrating its handling of various trivia elements like comments, blank lines, and their placement relative to code constructs.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/ruff/module_dangling_comment1.py",
            "description": "This file defines a module's public interface using the `__all__` variable and includes a comment indicating shared type definitions. It likely serves as a test fixture for the `ruff_python_formatter`.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/ruff/skip_magic_trailing_comma.py",
            "description": "This file serves as a test fixture for the Ruff Python formatter, demonstrating various scenarios involving trailing commas in tuples, function arguments, and lambda expressions, particularly focusing on how \"magic trailing commas\" are handled or skipped.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/ruff/newlines.py",
            "description": "This file serves as a test fixture for the Ruff Python formatter, specifically designed to test its handling of blank lines around functions, imports, classes, and other control structures, as well as the preservation or removal of newlines in various scenarios.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/ruff/fmt_skip/match.py",
            "description": "This file serves as a test fixture for the Ruff formatter, demonstrating the behavior of `fmt: skip` comments within various Python `match` statements. It showcases different patterns and `case` structures, ensuring specific parts are not formatted.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/ruff/fmt_skip/decorators.py",
            "description": "This file serves as a test fixture for the Ruff Python formatter, demonstrating its behavior with `fmt: skip` directives applied to decorators on both classes and functions. It includes tests for complex decorator arguments, multiple decorators, and addresses a specific regression issue.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/ruff/fmt_skip/compound_one_liners.py",
            "description": "This file contains test cases demonstrating the `fmt: skip` directive on various one-line compound Python statements. It ensures that the formatter correctly ignores these specific lines, preserving their original formatting.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/ruff/fmt_skip/or_else.py",
            "description": "This file is a test fixture for the Ruff Python formatter, demonstrating how the `# fmt: skip` directive is applied to `for...else`, `while...else`, and `try...except...else...finally` control flow statements.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/ruff/fmt_skip/parentheses.py",
            "description": "This file is a test fixture for the Ruff Python formatter, specifically demonstrating how `fmt: skip` interacts with comments around parentheses in `if` conditions.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/ruff/fmt_skip/reason.py",
            "description": "This file contains test cases for the `fmt: skip` directive in Python code, demonstrating how the ruff formatter handles additional comments or 'reasons' on the same line. It distinguishes between supported and unsupported syntaxes for combining `fmt: skip` with other text.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/ruff/fmt_skip/top_level_semicolon.py",
            "description": "This file is a test fixture for the ruff Python formatter, demonstrating the use of `fmt: skip` comments to prevent formatting of lines containing multiple statements separated by semicolons.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/ruff/fmt_skip/type_params.py",
            "description": "This file contains test cases for the Ruff Python formatter, specifically demonstrating the use of `fmt: skip` for class and function definitions with type parameters, including various comment placements.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/ruff/fmt_skip/trailing_semi.py",
            "description": "This file serves as a test fixture for the Ruff Python formatter, specifically demonstrating cases where trailing semicolons are present on lines marked with `# fmt: skip` to ensure they are not reformatted.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/ruff/fmt_skip/semicolons.py",
            "description": "This file contains a series of test cases for a Python formatter, specifically demonstrating how `fmt: skip` directives prevent formatting for various semicolon usages, line continuations, and multi-line statements.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/ruff/fmt_skip/docstrings.py",
            "description": "This file serves as a test fixture for the Ruff Python formatter, demonstrating how it handles docstrings when explicitly marked with `# fmt: skip` versus when they are not, to ensure correct formatting behavior.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/ruff/fmt_on_off/fmt_off_docstring.py",
            "description": "This file is a test fixture demonstrating the `fmt: off` and `fmt: on` directives within Python code, specifically for docstrings and general code formatting behavior.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/ruff/fmt_on_off/fmt_off_unclosed_trailing_comment.py",
            "description": "This file is a regression test fixture for the `ruff_python_formatter`, specifically designed to ensure the `fmt: off` directive correctly handles unclosed trailing comments without causing issues, addressing a bug reported in issue #8211.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/ruff/fmt_on_off/form_feed.py",
            "description": "This file is a test fixture for the `ruff_python_formatter`, demonstrating how it handles `fmt: off` and `fmt: on` directives, specifically when a form feed character is present between them.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/ruff/fmt_on_off/mixed_space_and_tab.py",
            "description": "This file is a test fixture for the `ruff_python_formatter`, specifically designed to test how `fmt: off` and `fmt: on` directives handle code with mixed space and tab indentation, ensuring it remains unformatted within the `off` block.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/ruff/fmt_on_off/simple.py",
            "description": "This file is a test fixture for the Ruff Python formatter, demonstrating the behavior of `fmt: off` and `fmt: on` directives to selectively disable and enable formatting within a file.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/ruff/fmt_on_off/newlines.py",
            "description": "This file serves as a test fixture for the Ruff Python formatter, demonstrating how it handles `fmt: off` and `fmt: on` directives and their interaction with newlines in the code.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/ruff/fmt_on_off/off_on_off_on.py",
            "description": "This file serves as a test fixture for a Python formatter, demonstrating the expected behavior when encountering complex or tricky sequences of `fmt: off` and `fmt: on` directives.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/ruff/fmt_on_off/empty_file.py",
            "description": "This file is a test fixture for the Ruff Python formatter, specifically designed to test the behavior of `fmt: off` and `fmt: on` directives in an empty Python file.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/ruff/fmt_on_off/fmt_off_unclosed_deep_nested_trailing_comment.py",
            "description": "This file is a regression test fixture for Ruff's Python formatter, specifically for the `fmt: off` directive. It tests how the formatter handles unclosed, deep-nested trailing comments within a `fmt: off` block, addressing a reported issue.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/ruff/fmt_on_off/comments.py",
            "description": "This file is a test fixture for the Ruff Python formatter, showcasing the behavior of `fmt: off` and `fmt: on` directives with various comment styles and indentation, ensuring certain code blocks are left unformatted.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/ruff/fmt_on_off/trailing_comments.py",
            "description": "This file serves as a test fixture for the Ruff Python formatter, specifically demonstrating and verifying the behavior of the `fmt: off` and `fmt: on` directives, particularly when interspersed with trailing comments, to control code formatting.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/ruff/fmt_on_off/trailing_semicolon.py",
            "description": "This file serves as a test fixture for the Ruff Python formatter, specifically to verify its behavior with `fmt: off` directives when encountering code containing trailing semicolons.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/ruff/fmt_on_off/indent.py",
            "description": "This file serves as a test fixture for the `ruff` Python formatter, demonstrating the behavior of `fmt: off` and `fmt: on` directives. It verifies that code within these blocks, including indentation and comments, is preserved from reformatting.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/ruff/fmt_on_off/no_fmt_on.py",
            "description": "This test fixture demonstrates the behavior of `ruff_python_formatter` when encountering the `# fmt: off` directive, ensuring that the specified code blocks are not formatted.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/ruff/fmt_on_off/yapf.py",
            "description": "This file is a test fixture for the Ruff Python formatter, specifically designed to verify how it handles `yapf: disable` and `yapf: enable` comments, and their interaction with `fmt: on` directives, within Python code.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/ruff/fmt_on_off/last_statement.py",
            "description": "This file is a test fixture for the Ruff Python formatter, designed to verify that the `fmt: off` directive correctly prevents formatting of code and comments, even for the last statement in a block.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/ruff/carriage_return/string.py",
            "description": "This file serves as a test fixture for the Ruff Python formatter, demonstrating how it handles various string literals, including backslash-continued strings and multiline strings with escaped quotes.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/ruff/parentheses/nested.py",
            "description": "This file contains test cases demonstrating various scenarios of nested parentheses and inline comments in Python code, likely for a formatter or linter's stability and correctness checks.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/ruff/parentheses/expression_parentheses_comments.py",
            "description": "This file contains test cases demonstrating the formatting behavior of comments within and around parenthesized expressions, including lists and nested parentheses, for the Ruff Python formatter.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/ruff/parentheses/opening_parentheses_comment_value.py",
            "description": "This file serves as a test fixture for a Python formatter, demonstrating various scenarios where comments immediately follow an opening parenthesis or bracket, to ensure correct formatting of such cases.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/ruff/parentheses/opening_parentheses_comment_empty.py",
            "description": "This file serves as a test fixture for the Ruff Python formatter, demonstrating its behavior when handling comments placed immediately after an opening parenthesis in various empty parenthesized expressions. It covers diverse Python constructs like assignments, function calls, control flow statements, and definitions.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/ruff/parentheses/call_chains.py",
            "description": "This file contains test cases for the Python formatter, focusing on call chains, fluent style, and the usage of parentheses in various complex expressions and statement structures to ensure correct line-breaking and indentation.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/ruff/expression/await.py",
            "description": "This file contains test cases for the Ruff formatter to ensure correct formatting of various `await` expressions, including specific regression tests for GitHub issues.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/ruff/expression/hug.py",
            "description": "This file provides test cases for Ruff's Python formatter, specifically demonstrating the 'hug' style for brackets and parentheses in various expressions, comprehensions, dictionaries, and starred arguments, including scenarios with comments.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/ruff/expression/dict_comp.py",
            "description": "This file contains various examples and test cases for Python dictionary comprehensions, including different formatting styles, comments, and specific regression tests. It serves as a fixture for testing a Python formatter's handling of dictionary comprehensions.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/ruff/expression/binary_pow_spacing.py",
            "description": "This file contains test cases for the `ruff` Python formatter, specifically to verify its handling of spacing around the binary power operator (`**`) with various operand types.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/ruff/expression/set_comp.py",
            "description": "This file contains various test cases for the Ruff Python formatter, specifically focusing on the formatting of set comprehensions, including multi-line expressions, comments, and long lines. It also includes regression tests for issue #5911 related to set comprehensions.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/ruff/expression/binary_implicit_string.py",
            "description": "This file serves as a test fixture for the Ruff Python formatter, specifically designed to test its behavior with binary expressions involving implicit string concatenation, string formatting (using `%`), and the placement of comments in such contexts.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/ruff/expression/join_implicit_concatenated_string_assignment.py",
            "description": "This file contains test cases for the `ruff` formatter, specifically focusing on how it handles implicit, f-string, and t-string concatenations in assignments and type aliases, particularly in relation to line length limits, parenthesization, and comments.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/ruff/expression/named_expr.py",
            "description": "This file provides various test cases for Python's named expression (walrus) operator `:=` to ensure correct parsing and formatting across different contexts.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/ruff/expression/dict.py",
            "description": "This file contains various test cases for the Python formatter, specifically focusing on dictionary syntax, including comments, unpacking operators, and complex structures. It serves to ensure correct formatting behavior for different dictionary expressions.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/ruff/expression/list_comp.py",
            "description": "This file contains various test cases and regression tests for Python list comprehensions, used as a fixture for the Ruff Python formatter to verify its formatting behavior.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/ruff/expression/lambda.py",
            "description": "This file serves as a test fixture for a Python formatter, demonstrating various `lambda` expression syntaxes and formatting edge cases, including argument lists, bodies, and comment handling. It includes regression tests for specific formatting issues related to `lambda` expressions.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/ruff/expression/attribute.py",
            "description": "This file serves as a test fixture for the Ruff Python formatter, specifically to test the formatting of attribute access expressions. It includes various scenarios with comments, line breaks, and parenthesization in attribute chains, including several regression tests for known formatting issues.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/ruff/expression/yield.py",
            "description": "This file serves as a test fixture for a Python formatter, showcasing various `yield` expressions and statements to ensure correct formatting in different contexts. It includes examples of `yield` used in assignments, loops, conditional statements, and with complex expressions.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/ruff/expression/yield_from.py",
            "description": "This file serves as a test fixture for the Ruff Python formatter, specifically to evaluate its handling of various 'yield from' expression patterns, including complex formatting and indentation cases.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/ruff/expression/bytes.py",
            "description": "This file serves as a test fixture for the Ruff Python formatter, providing a comprehensive set of byte string literal expressions to verify correct formatting behavior, including various quoting styles, continuations, and edge cases.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/ruff/expression/fstring_preview.py",
            "description": "This file contains regression tests for f-string formatting, specifically addressing the casing of escaped characters (`\\xFF`, `\\xff`) within debug expressions in both raw and non-raw f-strings.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/ruff/expression/compare.py",
            "description": "This file contains a collection of Python code snippets demonstrating various comparison expressions. It serves as a test fixture for the Ruff Python formatter, specifically to ensure correct formatting of comparison operators, chained comparisons, and complex expressions involving comparisons.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/ruff/expression/subscript.py",
            "description": "This file contains regression tests for the Ruff Python formatter, specifically focusing on how it handles subscript expressions in various scenarios, including those with long lines and comments, addressing issues identified in Ruff's GitHub repository.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/ruff/expression/tuple.py",
            "description": "This file serves as a test fixture for a Python formatter, showcasing various tuple formatting scenarios, including different parentheses styles, line wrapping, and comment placements.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/ruff/expression/number.py",
            "description": "This file contains a collection of Python number literal expressions, serving as test fixtures for the `ruff_python_formatter` to verify its correct handling of various number formats.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/ruff/expression/boolean_operation.py",
            "description": "This file serves as a test fixture for the Ruff Python formatter, showcasing various complex boolean and other expressions to verify correct formatting behavior, especially concerning line breaks and parenthesization.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/ruff/expression/unary.py",
            "description": "This file contains a collection of test cases for a Python formatter, specifically demonstrating how it handles various unary expressions (not, -, +, ~), including those with comments, parentheses, and complex operands, often related to specific formatting issues in Ruff.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/ruff/expression/list.py",
            "description": "This file serves as a test fixture for the Ruff Python formatter, specifically to verify its behavior with various comment placements and trailing commas within list expressions. It includes test cases for empty lists, lists with multiple items, and complex nested scenarios to ensure correct formatting.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/ruff/expression/call.py",
            "description": "This file serves as a test fixture for the Ruff Python formatter, showcasing various function call syntaxes, argument handling, and comment placements to ensure correct formatting behavior.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/ruff/expression/fstring.py",
            "description": "This file contains a comprehensive set of test cases for f-string formatting within the Ruff Python formatter. It covers various scenarios such as comments, quote handling, multiline expressions, and debug f-string formatting.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/ruff/expression/join_implicit_concatenated_string_preserve.py",
            "description": "This file is a test fixture for the ruff Python formatter, demonstrating various scenarios of implicitly concatenated strings, including those with mixed quote types and f-strings, to ensure correct formatting preservation.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/ruff/expression/slice.py",
            "description": "This file serves as a test fixture for the Ruff Python formatter, showcasing various valid slice expressions in Python, including complex cases with comments, spacing, regression tests for specific issues, and PEP 646 starred expressions.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/ruff/expression/optional_parentheses_comments.py",
            "description": "This file contains test cases for the Ruff Python formatter, demonstrating its behavior with optional parentheses and comment placement for long expressions, strings, numbers, assignments, and return statements.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/ruff/expression/if.py",
            "description": "This file contains various test cases and fixtures for the `if` expression (ternary operator) in Python, demonstrating how a code formatter should handle different formatting scenarios including comments, line breaks, and nesting.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/ruff/expression/split_empty_brackets.py",
            "description": "This file is a test fixture for the Ruff Python formatter, showcasing various complex expressions to verify how the formatter handles line splitting and empty brackets (parentheses, lists, dictionaries) within chained method calls and function arguments.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/ruff/expression/join_implicit_concatenated_string.py",
            "description": "This file serves as a test fixture for the Ruff Python formatter, demonstrating how it handles the joining of implicitly concatenated string literals across various Python constructs and string types. It covers scenarios including f-strings, byte strings, raw strings, docstrings, and strings within control flow statements like `if`, `for`, `with`, `assert`, and `match`.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/ruff/expression/unsplittable.py",
            "description": "This file serves as a test fixture for the Ruff Python formatter, showcasing its behavior with long expressions, line breaks, parenthesization, and comment placement, particularly in comparison to the Black formatter.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/ruff/expression/tstring.py",
            "description": "This file provides test fixtures for the Ruff Python formatter, specifically designed to validate the formatting of 'tstring' expressions under various conditions, including multi-line content, embedded comments, complex expressions, and quote handling.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/ruff/expression/starred.py",
            "description": "This file serves as a test fixture for the `ruff_python_formatter`, specifically to evaluate the formatting of function calls with starred expressions. It includes various scenarios to test comment placement around the star operator and within unpacked sequences.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/ruff/statement/assert.py",
            "description": "This file serves as a test fixture for the Ruff Python formatter, specifically demonstrating and testing the formatting of various `assert` statements, including those with comments, long expressions, and messages, to ensure consistent and correct formatting behavior.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/ruff/statement/for.py",
            "description": "This file contains a collection of `for` loop examples, including various comment placements, long lines, parenthesization, and `else` clauses, primarily serving as test cases for a Python code formatter.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/ruff/statement/break.py",
            "description": "This file serves as a test fixture for the `ruff_python_formatter`, specifically demonstrating how the formatter handles `break` statements and associated comments within a `while` loop.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/ruff/statement/global.py",
            "description": "This file contains test cases for the Python `global` statement, showcasing various uses and comment styles within function definitions. It likely serves as a fixture for testing a code formatter's handling of `global` statements.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/ruff/statement/aug_assign.py",
            "description": "This file contains test cases for the `ruff_python_formatter` to evaluate its handling of augmented assignment statements, specifically `+=`, including cases with long string literals.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/ruff/statement/with.py",
            "description": "This file serves as a test fixture for a Python formatter, specifically showcasing various `with` statement syntax, formatting, and comment handling.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/ruff/statement/ann_assign.py",
            "description": "Test fixture for the `ruff` formatter, demonstrating how it handles annotated assignments with long lines and line breaks, particularly ensuring correct parenthesis usage in both values and annotations.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/ruff/statement/import.py",
            "description": "This file contains various test cases for the Ruff Python formatter, specifically demonstrating how it handles different `import` statement scenarios, including long lines, continuations, aliases, and blank line rules in both global and nested scopes.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/ruff/statement/nonlocal.py",
            "description": "This file serves as a test fixture for the Ruff Python formatter, specifically to evaluate its handling and formatting of `nonlocal` statements under various conditions, including with comments and long variable lists.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/ruff/statement/return_type_parameters.py",
            "description": "Tests how the Ruff Python formatter handles various return type annotations for functions with parameters, particularly focusing on line wrapping and parenthesization rules for different type expressions like strings, unions, and subscripts.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/ruff/statement/top_level.py",
            "description": "This file serves as a test fixture for the ruff formatter, containing various top-level class and function definitions to test formatting of such statements.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/ruff/statement/try.py",
            "description": "This file contains a collection of test cases and fixtures for `try...except...else...finally` and `try...except*` statements, demonstrating various formatting scenarios including comments, line breaks, multiple exceptions, and `as` clauses.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/ruff/statement/delete.py",
            "description": "This file serves as a test fixture for the `ruff_python_formatter`, specifically to verify its behavior when formatting `del` statements. It includes various `del` statement configurations, including single-line, multi-line, and those with diverse comment placements and line lengths.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/ruff/statement/raise.py",
            "description": "This file serves as a test fixture for the `ruff` Python formatter, specifically to test its handling of various `raise` statements, including those with long expressions, `from` clauses, and embedded comments and line breaks.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/ruff/statement/match.py",
            "description": "This file contains a comprehensive collection of Python `match` statement examples, serving as a test fixture for a code formatter. It showcases various `case` patterns, including comments, long lines, complex patterns (tuples, lists, dicts, class patterns), `or` patterns, and `if` guards, to ensure correct formatting.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/ruff/statement/return.py",
            "description": "This file contains test fixtures for the Ruff Python formatter, specifically designed to test the formatting of various `return` statement structures, including long lines, tuple returns, and their interaction with line wrapping.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/ruff/statement/if.py",
            "description": "This file serves as a test fixture for the Ruff Python formatter, specifically to test the handling and placement of comments within `if`, `elif`, and `else` statements. It includes various comment scenarios and regression tests for known issues related to comment preservation and association.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/ruff/statement/stub_functions_trailing_comments.py",
            "description": "This file contains regression tests for Ruff's Python formatter, specifically addressing how it handles comments, including trailing comments, around stub functions and regular function definitions.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/ruff/statement/assign.py",
            "description": "This file contains test cases for the Ruff Python formatter, specifically demonstrating how it handles various assignment statements, including complex left-hand sides, multi-line assignments, and long expressions, to ensure correct formatting and line-breaking behavior.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/ruff/statement/class_definition.py",
            "description": "This file contains test fixtures for the Ruff Python formatter, demonstrating various class definition syntaxes, including inheritance, type parameters, decorators, docstrings, and comment placements, to ensure correct formatting.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/ruff/statement/type_alias.py",
            "description": "This file serves as a test fixture for a Python formatter, showcasing various forms and edge cases of the 'type' alias syntax introduced in PEP 695. It includes examples of basic usage, generic type aliases, multiline definitions, bounds, defaults, and comment placements.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/ruff/statement/with_39.py",
            "description": "This file serves as a test fixture for the `ruff_python_formatter`, demonstrating various `with` statement formatting scenarios, particularly focusing on parenthesization, line breaking, and comparisons to Black's formatting style.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/ruff/statement/import_from.py",
            "description": "This file serves as a test fixture for the Ruff Python formatter, specifically to evaluate its handling and formatting of various `from ... import ...` statement syntaxes, including long lines, multiple imports, aliases, and comments.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/ruff/statement/long_type_annotations.py",
            "description": "This file serves as a test fixture for the `ruff` Python formatter, showcasing various long and complex type annotations to verify correct formatting and comment handling.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/ruff/statement/assignment_split_value_first.py",
            "description": "This file contains test fixtures for the Ruff Python formatter, demonstrating how assignment statements, especially value parenthesization and line wrapping, are handled under various conditions like long targets, values, call expressions, and comments.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/ruff/statement/while.py",
            "description": "This file serves as a test fixture for the Ruff Python formatter, providing various examples of 'while' statements, including those with 'else' clauses, multi-line conditions, and diverse comment placements, to ensure correct formatting behavior.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/ruff/statement/return_type_no_parameters.py",
            "description": "This file contains test cases for formatting function return type annotations in Python, focusing on how different types (strings, names, unions, multiline strings, implicitly concatenated strings, and subscripts) are wrapped and parenthesized based on line length constraints, often comparing Ruff's behavior to Black's.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/ruff/statement/function.py",
            "description": "This file contains a comprehensive set of test cases for the `ruff` Python formatter, demonstrating its handling of various function definition formats, argument wrapping styles, type parameters, comments (dangling, leading, trailing, and within arguments), and special argument separators.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/ruff/statement/return_annotation.py",
            "description": "This file serves as a test fixture for the Ruff Python formatter, specifically designed to test the formatting of function return type annotations. It includes various complex scenarios, comment placements, and line-breaking behaviors for return type expressions.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/ruff/pattern/pattern_maybe_parenthesize.py",
            "description": "This file serves as a test fixture for a Python formatter, demonstrating how different types of match case patterns are parenthesized or broken into multiple lines based on their length and structure, including literals, identifiers, implicit concatenations, and complex patterns.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/ruff/range_formatting/empty_file.py",
            "description": "This file is a test fixture for the Ruff Python formatter, specifically designed to test its behavior when formatting an empty Python file or an empty range within a file.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/ruff/range_formatting/empty_range.py",
            "description": "This fixture tests the `ruff_python_formatter`'s behavior when an empty (zero-width) range is provided for formatting, specifically demonstrating it before a print statement.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/ruff/range_formatting/end_of_file.py",
            "description": "Tests how the formatter handles an empty range at the very end of a file. It verifies behavior when `RANGE_START` and `RANGE_END` are identical and located at the file's conclusion.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/ruff/range_formatting/fmt_skip.py",
            "description": "This file contains test cases for range formatting, specifically to verify how the formatter interacts with `fmt: skip` directives when a formatting range is applied to parts of or entire skipped sections.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/ruff/range_formatting/module.py",
            "description": "This file is a test fixture for the `ruff_python_formatter`'s range formatting functionality. It demonstrates how the formatter applies changes within a specified code range, indicated by `RANGE_START` and `RANGE_END` markers.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/ruff/range_formatting/same_line_body.py",
            "description": "This file serves as a test fixture for the `ruff` formatter, demonstrating its behavior when reformatting specific code ranges within Python function and conditional bodies, especially concerning single-line statements and line-wrapping.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/ruff/range_formatting/docstring_code_examples.py",
            "description": "This file serves as a test fixture for the Ruff Python formatter, showcasing various scenarios for formatting doctest code examples within docstrings, including line wrapping and formatter suppression.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/ruff/range_formatting/comment_only_range.py",
            "description": "This test fixture demonstrates how the ruff formatter handles formatting a range that exclusively contains comments, ensuring it doesn't affect surrounding code.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/ruff/range_formatting/leading_comments.py",
            "description": "Test fixtures for `ruff_python_formatter` demonstrating how leading comments within selected ranges are handled during range formatting, particularly focusing on their impact on indentation and formatting behavior.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/ruff/range_formatting/decorators.py",
            "description": "This file is a test fixture for the ruff Python formatter, specifically designed to test range formatting behavior around decorators. It contains examples of functions with decorators, marked with range boundaries, to ensure the formatter correctly handles these scenarios.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/ruff/range_formatting/whitespace_only_range.py",
            "description": "This file serves as a test fixture for the `ruff` formatter, specifically to evaluate its behavior when applying range formatting to sections containing only whitespace.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/ruff/range_formatting/parentheses.py",
            "description": "This file contains Python code snippets used as test fixtures to evaluate the `ruff` formatter's behavior, specifically focusing on how it handles parentheses and range formatting within expressions.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/ruff/range_formatting/ancestory.py",
            "description": "This file serves as a test fixture for the `ruff_python_formatter`, specifically to verify its behavior when performing range formatting on code snippets that span multiple lines and nested blocks, potentially involving ancestor nodes in the AST.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/ruff/range_formatting/trailing_comments.py",
            "description": "This file is a test fixture for the `ruff_python_formatter` testing how it handles range formatting, specifically focusing on the treatment of trailing comments and multi-line comment sections.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/ruff/range_formatting/regressions.py",
            "description": "This file contains Python code serving as regression tests for Ruff's range formatting capabilities, demonstrating scenarios like trimming empty lines, reformatting calls, handling new comments, and managing whitespace between statements during partial formatting.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/ruff/range_formatting/clause_header.py",
            "description": "This file serves as a test fixture for the Ruff Python formatter, specifically demonstrating how range formatting interacts with 'clause headers' (like function definitions, class definitions, and control flow statements) and bodies, including cases where formatting is explicitly skipped or limited to a range.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/ruff/range_formatting/leading_trailing_comments.py",
            "description": "This file is a test fixture for the Ruff Python formatter, specifically designed to verify how it handles leading and trailing comments when formatting a specific range of code. It ensures that comments within or adjacent to the formatted range are preserved and correctly associated.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/ruff/range_formatting/indent.py",
            "description": "This file is a test fixture for the Ruff Python formatter, specifically designed to test the `range_formatting` feature's ability to correct and handle various indentation scenarios within a specified code range.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/ruff/stub_files",
            "description": "This directory is designated to store Python stub files (`.pyi`) that serve as test fixtures. These fixtures are utilized by the `ruff_python_formatter` crate to test its formatting capabilities specifically on stub file content.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/black/cases/beginning_backslash.py",
            "description": "Tests how the Black formatter handles Python files that begin with a backslash and empty lines before any code.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/black/cases/comment_after_escaped_newline.py",
            "description": "This file serves as a test case for the Python formatter, specifically to verify its behavior when handling comments placed after escaped newlines in function definitions, aligning with Black's formatting rules.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/black/cases/async_stmts.py",
            "description": "This file serves as a test fixture for the ruff Python formatter, specifically to verify the formatting of async function definitions and async for loops, adhering to black's style guidelines.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/black/cases/class_blank_parentheses.py",
            "description": "This file contains various Python class and function definitions, primarily serving as a test fixture to evaluate how a code formatter handles parentheses in declarations, particularly when they are blank or contain spaces.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/black/cases/backslash_before_indent.py",
            "description": "This file is a Black formatter test fixture for ruff_python_formatter, demonstrating how the formatter handles backslashes used for line continuation before indented blocks and within multiline docstrings.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/black/cases/comments8.py",
            "description": "This file is a test fixture demonstrating how Black (and Ruff's formatter) standardizes Spyder IDE cell comments, specifically converting '#%%' to '# %%'.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/black/cases/comments5.py",
            "description": "This Python file serves as a Black formatter test case, specifically demonstrating and evaluating how various types of comments (trailing, block-level, standalone, leading function/decorator comments) are handled and preserved within different Python constructs.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/black/cases/comment_type_hint.py",
            "description": "This file serves as a test fixture for the ruff Python formatter, specifically to evaluate its handling of type comments in Python code, particularly in scenarios that might be affected by line length or trailing spaces.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/black/cases/conditional_expression.py",
            "description": "This file contains various test cases demonstrating the formatting of conditional expressions (ternary operators) in Python, used in assignments, function arguments, comprehensions, and other contexts. It serves as a fixture to ensure a Python formatter correctly handles different layouts of `if/else` expressions.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/black/cases/annotations.py",
            "description": "This file is a regression test fixture for the Ruff Python formatter, specifically to test the Black-compatible formatting of type annotations involving `Mapping` and `Optional` for issue #1765.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/black/cases/allow_empty_first_line.py",
            "description": "This file serves as a test fixture for the Ruff Python formatter, specifically designed to test its behavior regarding empty lines at the beginning of different code blocks, including after docstrings and comments, consistent with Black's formatting rules.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/black/cases/context_managers_autodetect_310.py",
            "description": "Tests how the formatter handles Python 3.10+ pattern matching and multi-line context managers, likely as a Black formatting test case.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/black/cases/bracketmatch.py",
            "description": "This file contains various complex and unusual Python syntax examples, primarily used as a test fixture for the `ruff` formatter. It specifically tests the formatter's ability to handle bracket matching and intricate expressions, likely for `black` compatibility.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/black/cases/cantfit.py",
            "description": "This file contains test cases for a Python formatter, specifically demonstrating scenarios where lines are intentionally very long and difficult to wrap or format automatically.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/black/cases/context_managers_autodetect_39.py",
            "description": "This file tests the formatter's ability to handle parenthesized context managers, a feature introduced in Python 3.9.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/black/cases/comments3.py",
            "description": "This file serves as a Black formatter test fixture, showcasing how the formatter handles complex code structures, multi-line strings, list comprehensions, and various comment styles, including Spyder IDE cell markers.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/black/cases/attribute_access_on_number_literals.py",
            "description": "This file serves as a test fixture for a Python formatter (likely Black) to evaluate its handling of attribute access on various number literals, including integers, floats, complex numbers, and some syntactically incorrect expressions.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/black/cases/comments.py",
            "description": "This file serves as a comprehensive test case for a Python formatter, specifically demonstrating how various types of comments (docstrings, inline, block, special characters, etc.) should be preserved and handled across different code structures.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/black/cases/docstring_newline.py",
            "description": "This file is a test fixture for the ruff-python-formatter, specifically designed to test how it formats docstrings, likely in alignment with Black's style concerning newlines within docstrings.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/black/cases/docstring_no_extra_empty_line_before_eof.py",
            "description": "This file is a test fixture for the Ruff Python formatter, specifically to ensure that no extra empty lines are added before the end of the file when a class's docstring is the last element.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/black/cases/context_managers_38.py",
            "description": "This file contains test cases demonstrating the formatting of `with` statements, including those with line continuations, multiple context managers, and `mock.patch.object` usage, likely for a Python formatter.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/black/cases/class_methods_new_line.py",
            "description": "This file provides a collection of diverse Python class definitions, including nested classes, docstrings, class variables, and `__init__` methods, to serve as a test fixture for a Python formatter's handling of class-related syntax and newlines.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/black/cases/comments_in_blocks.py",
            "description": "This file contains various Python code snippets featuring comments placed within different blocks (e.g., lambdas, comprehensions, conditions). It serves as a test fixture for code formatters to verify their handling of such inline comments.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/black/cases/collections.py",
            "description": "This file serves as a Black formatter test case, showcasing its behavior with various Python collections (sets, tuples, lists, dictionaries) and import statements, particularly regarding trailing commas and line wrapping.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/black/cases/f_docstring.py",
            "description": "Contains Black formatter test cases for f-strings used as docstrings and f-string expressions within function bodies.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/black/cases/comments_in_double_parens.py",
            "description": "This file serves as a test fixture for the ruff Python formatter, specifically to ensure correct handling and preservation of comments located within single and double parentheses constructs, mirroring Black's formatting behavior.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/black/cases/composition.py",
            "description": "This file serves as a test fixture for the Ruff Python formatter, specifically to evaluate its handling of complex composition and formatting scenarios, including long lines, deeply nested structures, and assertion statements.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/black/cases/fmtonoff.py",
            "description": "This file serves as a test fixture for a Python code formatter, demonstrating the behavior of 'fmt: off' and 'fmt: on' directives across various code constructs, including imports, functions, data structures, and comments, to prevent or allow formatting in specific sections.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/black/cases/fmtskip5.py",
            "description": "This file is a Black formatter test case for ruff_python_formatter, specifically demonstrating how the `fmt: skip` directive prevents formatting of a specific line within a multi-line conditional expression.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/black/cases/docstring_preview.py",
            "description": "This file contains test cases for docstring formatting, specifically focusing on how docstrings behave when they are at or near the configured line limit, including single-line, multi-line, and f-string variations.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/black/cases/bytes_docstring.py",
            "description": "This file contains test cases for the `ruff_python_formatter`, specifically demonstrating how byte string literals are handled when they appear in the position of a docstring. It verifies that these are treated as expressions and not actual docstrings by the `black` formatter rules.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/black/cases/fmtonoff4.py",
            "description": "This file is a test fixture for a Python formatter, demonstrating how code blocks marked with `fmt: off` and `fmt: on` directives are handled, likely mimicking a Black formatter behavior.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/black/cases/fmtskip_multiple_strings.py",
            "description": "This file contains test cases for a Python formatter, demonstrating the behavior of `fmt: skip` directives when applied to multiple string literals within a single expression and to dictionary entries.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/black/cases/fmtonoff6.py",
            "description": "This file contains regression tests for `ruff_python_formatter` related to `black/cases`, specifically checking how the formatter handles `fmt: off` comments to prevent reformatting of specific code blocks, referencing Black issues #2478 and #3458.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/black/cases/fmtskip7.py",
            "description": "This file is a test fixture for the ruff Python formatter, demonstrating how it handles lines explicitly marked with `fmt:skip` comments, including variations in spacing and capitalization.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/black/cases/expression.py",
            "description": "This file serves as a test fixture for a Python formatter, showcasing various Python expressions, including literals, operators, lambdas, comprehensions, function calls, and slicing, to test formatting behavior.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/black/cases/docstring.py",
            "description": "This file serves as a test fixture for a Python formatter, containing a comprehensive collection of docstring examples to test various formatting scenarios, including multiline, indentation, quotes, whitespace, and special characters.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/black/cases/comments2.py",
            "description": "This file is a test fixture for a Python formatter, demonstrating various complex scenarios involving comments within import statements, list definitions, function calls, comprehensions, and conditional logic to validate formatting rules.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/black/cases/comments_non_breaking_space.py",
            "description": "This file serves as a test fixture for the Ruff Python formatter, specifically to verify its handling of comments and non-breaking spaces, mimicking Black's formatting behavior. It includes various scenarios such as inline comments, `type: ignore` comments, and docstrings.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/black/cases/fmtskip10.py",
            "description": "This file serves as a test fixture for a Python formatter (likely Black or Ruff), demonstrating how `fmt: skip` comments prevent specific lines or blocks of code from being formatted. It showcases various Python constructs with `fmt: skip` directives.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/black/cases/fmtskip13.py",
            "description": "This file serves as a test fixture for the Python formatter, demonstrating how the `fmt: skip` directive prevents reformatting of dictionary literals within tuples, specifically in scenarios involving line wrapping.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/black/cases/comments4.py",
            "description": "This file serves as a test fixture for a Python formatter, demonstrating various comment placements and formatting scenarios within import statements, parameterized test cases, and chained method calls.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/black/cases/empty_lines.py",
            "description": "This file contains test cases for a Python formatter, specifically focusing on how empty lines, spacing, and comments are handled around tokens and syntactic structures, likely aiming for Black-style formatting compliance.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/black/cases/context_managers_39.py",
            "description": "This file serves as a test fixture for a Python formatter, showcasing various complex `with` statement scenarios, including multi-line context managers, comment handling, and specific formatting edge cases, to ensure correct code formatting.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/black/cases/fstring_quotations.py",
            "description": "This file contains regression tests for the Black formatter's handling of f-strings, specifically focusing on long f-strings and various quotation scenarios, including examples related to issue #3623.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/black/cases/fmtskip.py",
            "description": "This file serves as a test fixture for the Ruff Python formatter, specifically to verify its handling of the '# fmt: skip' directive, replicating behavior expected from Black.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/black/cases/format_unicode_escape_seq.py",
            "description": "Tests how the formatter handles various Python string literals, including different unicode escape sequences, raw strings, and byte strings, as part of the `black` formatter test cases for `ruff`.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/black/cases/fstring.py",
            "description": "This file provides various f-string examples to serve as test cases for a Python formatter, specifically for how it handles different f-string syntaxes and complexities.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/black/cases/fmtskip6.py",
            "description": "This file is a Black formatter test fixture for ruff, demonstrating the `fmt: skip` directive on a `pass` statement within an `if` block inside a loop.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/black/cases/fmtskip_multiple_in_clause.py",
            "description": "This file is a test fixture for the Ruff Python formatter, demonstrating how multiple `fmt: skip` comments are handled within a multi-part `if` statement to prevent specific lines from being reformatted.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/black/cases/docstring_newline_preview.py",
            "description": "This file is a test fixture for the Ruff Python formatter, specifically designed to test the formatting of docstrings with a long line, mimicking a Black formatter test case.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/black/cases/context_managers_autodetect_38.py",
            "description": "This file serves as a Black formatter test case, ensuring that various `with` statement syntaxes, including parenthesized single context managers and multi-line definitions, are correctly formatted without being erroneously detected as Python 3.9+ grammar.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/black/cases/fmtpass_imports.py",
            "description": "This file is a test fixture for the Ruff Python formatter, specifically designed to verify how it handles import statements with `fmt: skip` and `fmt: off`/`fmt: on` directives, addressing a regression related to Black's formatting of imports.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/black/cases/fmtskip11.py",
            "description": "This file serves as a test fixture for the Ruff Python formatter, specifically to evaluate its handling of `fmt: skip`, `fmt: off`, and `fmt: on` directives in various contexts, including commented-out code and different comment placements, to ensure Black compatibility.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/black/cases/fmtskip4.py",
            "description": "This file is a test fixture for the Ruff Python formatter, designed to verify its handling of the '# fmt: skip' directive by ensuring the skipped line is not reformatted.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/black/cases/fmtskip9.py",
            "description": "This file is a test fixture for the Ruff Python formatter, specifically designed to verify how it handles the `fmt: skip` directive, ensuring certain lines are ignored during formatting.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/black/cases/context_managers_autodetect_311.py",
            "description": "This file serves as a test fixture for a Python formatter, demonstrating the formatting of Python 3.11 features like `except*` clauses and multi-line context managers.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/black/cases/fmtonoff5.py",
            "description": "This file contains a collection of regression tests for the Black formatter, specifically targeting its `fmt: off`/`on` and `yapf: disable`/`enable` directives to ensure correct handling of intentionally unformatted code sections.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/black/cases/fmtskip12.py",
            "description": "This file serves as a test case for a Python formatter, demonstrating how `fmt: skip` directives are applied to `with` statements. It specifically highlights scenarios where skipping only parts of a statement can lead to parsing errors or require skipping the entire statement.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/black/cases/fmtonoff3.py",
            "description": "This file is a test fixture for the Ruff Python formatter, specifically to verify its behavior when encountering `fmt: off` and `fmt: on` directives within Python code, mimicking Black formatter's skip regions.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/black/cases/fmtskip8.py",
            "description": "This file tests the `ruff_python_formatter`'s handling of `fmt: skip` directives on various Python constructs, ensuring that unformatted code and comments within these blocks are preserved as-is.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/black/cases/form_feeds.py",
            "description": "This file serves as a test fixture for the `ruff_python_formatter`, specifically designed to test how the formatter handles form feed characters (ASCII 0x0C) in various contexts within Python code.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/black/cases/composition_no_trailing_comma.py",
            "description": "This file serves as a test fixture for the ruff-python-formatter, derived from Black's test cases. It demonstrates how the formatter handles complex code compositions, chained calls, assignments, and various assertion scenarios, particularly focusing on formatting behavior without trailing commas.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/black/cases/fmtskip2.py",
            "description": "Tests how the `fmt: skip` directive affects line breaking and comment preservation for a Python formatter, especially in edge cases like short line lengths or preview modes. It demonstrates scenarios where formatting should and should not apply to long lists.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/black/cases/keep_newline_after_match.py",
            "description": "This file contains a Python `match` statement used to map HTTP status codes to descriptive strings. It likely serves as a test case for a code formatter (like Black or Ruff) to ensure correct handling of `match` statements and newline preservation.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/black/cases/import_comments.py",
            "description": "This file serves as a test fixture for the `ruff_python_formatter` to ensure that comments within various `import` statement styles are correctly preserved and formatted according to Black's conventions.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/black/cases/jupytext_markdown_fmt.py",
            "description": "This file contains tests to ensure that Jupytext markdown comments are preserved when interacting with `fmt: off` and `fmt: on` directives within Python code, including scenarios with and without code blocks.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/black/cases/module_docstring_3.py",
            "description": "This file is a test case for the `ruff_python_formatter`, specifically demonstrating the Black formatter's expected behavior for a single-line module-level docstring followed by a single newline.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/black/cases/line_ranges_decorator_edge_case.py",
            "description": "This file is a test case for the Ruff Python formatter, specifically designed to verify how line-range formatting (`--line-ranges=6-7`) handles code with decorators in an edge-case scenario.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/black/cases/pattern_matching_long.py",
            "description": "This file is a test fixture for the `ruff_python_formatter` to evaluate its handling of long and complex pattern matching statements, specifically focusing on `case` patterns with multiple `or` conditions.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/black/cases/function_trailing_comma.py",
            "description": "This file serves as a test case for a Python formatter (specifically Black, as indicated by the path) to demonstrate and verify its behavior regarding trailing commas in various language constructs, including function definitions, dictionary literals, tuples, and type annotations. It covers scenarios with and without trailing commas, long lines, and comments within parenthesized expressions.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/black/cases/linelength6.py",
            "description": "This file is a regression test for the ruff Python formatter, specifically addressing issue #3427 related to formatting behavior when the line length limit is set to 6 or less.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/black/cases/line_ranges_exceeding_end.py",
            "description": "This file is a test fixture for the `ruff` Python formatter, specifically designed to test how `black` formatting behaves when line ranges exceed the actual end of the file.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/black/cases/numeric_literals.py",
            "description": "This file contains various examples of Python numeric literals, serving as a test fixture for the Ruff Python formatter to ensure correct formatting of different numeric types and notations.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/black/cases/line_ranges_imports.py",
            "description": "This file is a test fixture for the Ruff Python formatter, specifically designed to verify that no empty lines are added around import statements when formatting a specific line range, addressing an issue related to Black's behavior.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/black/cases/funcdef_return_type_trailing_comma.py",
            "description": "This file serves as a test fixture for a Python code formatter, demonstrating various function definition scenarios, including return type annotations, parameter lists with trailing commas, line wrapping, and comment preservation, to ensure correct formatting behavior.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/black/cases/line_ranges_fmt_off_overlap.py",
            "description": "Tests how the Ruff Python formatter handles the interaction between `--line-ranges` and `fmt: off`/`fmt: on` directives, specifically when they overlap, to ensure correct reformatting behavior.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/black/cases/long_strings__type_annotations.py",
            "description": "This file serves as a test fixture for the `ruff_python_formatter`, specifically to verify its handling and formatting of long type annotations that involve string literal concatenation, mimicking `black`'s formatting style for such cases.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/black/cases/docstring_no_string_normalization.py",
            "description": "This file contains a collection of Python functions and classes serving as test cases for a code formatter. It specifically showcases various docstring formats to verify how the formatter handles them, particularly concerning normalization and indentation.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/black/cases/line_ranges_diff_edge_case.py",
            "description": "This file is a test case for `ruff_python_formatter` (Black compatibility) specifically designed to reproduce and test an edge case related to the `--line-ranges` flag, as identified in Black issue #4033.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/black/cases/module_docstring_4.py",
            "description": "This file is a test fixture for the Ruff Python formatter, specifically demonstrating the Black formatting rule that a single-line module-level docstring should be followed by a single newline.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/black/cases/line_ranges_fmt_off_decorator.py",
            "description": "This file is a regression test case for the Ruff Python formatter, specifically to ensure correct handling of `fmt: off`/`fmt: on` comments when used in conjunction with decorators, especially within line range formatting.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/black/cases/line_ranges_basic.py",
            "description": "A test fixture for the Ruff Python formatter, demonstrating various unformatted Python syntax constructs to test formatting behavior, especially when `line-ranges` are specified.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/black/cases/pattern_matching_extras.py",
            "description": "This file contains a collection of complex and unusual `match` statement patterns, likely serving as a test fixture for a Python formatter to ensure correct formatting of advanced pattern matching syntax.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/black/cases/module_docstring_followed_by_function.py",
            "description": "This file is a test fixture for a Python formatter, demonstrating the Black-style rule for spacing between a module docstring and the first function definition.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/black/cases/pattern_matching_style.py",
            "description": "This file contains various Python `match` and `case` statements, along with calls to `re.match`, serving as a test fixture for the ruff formatter to ensure correct Black-style formatting for pattern matching and function calls.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/black/cases/line_ranges_unwrapping.py",
            "description": "This file serves as a test fixture for the `ruff_python_formatter`, specifically to evaluate its compatibility with Black's line-range formatting behavior for unwrapping scenarios in Python code.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/black/cases/parenthesized_context_managers.py",
            "description": "Test case for a Python formatter demonstrating various `with` statements where context managers are enclosed in parentheses, including multiple managers and `as` clauses.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/black/cases/pattern_matching_simple.py",
            "description": "This file contains a series of examples demonstrating various features of Python's `match` statement (pattern matching) as defined in PEP 636, including sequence, wildcard, OR, object patterns, and `if` guards.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/black/cases/pep_570.py",
            "description": "This file contains test cases for Python's PEP 570 positional-only parameters, demonstrating various function and lambda definitions with '/' and '*' markers. It's used to verify how formatters like Black or Ruff handle this syntax.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/black/cases/pep_572_slices.py",
            "description": "This file contains test cases for formatting slices that include assignment expressions (walrus operator, PEP 572) according to Black's style guidelines.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/black/cases/fmtskip3.py",
            "description": "This file is a test fixture for the Ruff Python formatter, used to verify its handling of Black's `fmt: off`/`on` and `fmt: skip` directives. It includes examples of code that should and should not be formatted.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/black/cases/fmtonoff2.py",
            "description": "This file contains pytest test cases for fader-related functionality and utilizes `fmt: off` and `fmt: on` directives. It likely serves as a test fixture for a Python code formatter to ensure correct handling of formatting exclusion blocks and various code structures.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/black/cases/line_ranges_fmt_off.py",
            "description": "This file serves as a test fixture for the Ruffle Python formatter, specifically to evaluate its behavior when combining line range formatting with `fmt: off` and `fmt: on` directives, ensuring only targeted lines are reformatted.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/black/cases/module_docstring_followed_by_class.py",
            "description": "This file is a Black formatter test case. It verifies the formatting of a module docstring when followed by a class definition, specifically regarding blank lines.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/black/cases/one_element_subscript.py",
            "description": "Tests how the formatter handles trailing commas in single-element and multi-element Python subscripts (like `tuple[int,]`) and other list-like structures, aligning with Black's formatting rules.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/black/cases/pep_572.py",
            "description": "This file contains a comprehensive collection of test cases demonstrating the use of the assignment expression (walrus operator `:=`) introduced in PEP 572, covering various scenarios such as conditional statements, list comprehensions, function arguments, and lambda functions.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/black/cases/import_spacing.py",
            "description": "This file consolidates imports from various submodules, primarily for the `asyncio` package, and defines the package's public interface via the `__all__` variable. It serves as an aggregation point for module exports.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/black/cases/power_op_spacing.py",
            "description": "This file contains various test cases demonstrating the formatting of the power operator (`**`) with different operands and spacing, mimicking Black formatter's behavior.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/black/cases/line_ranges_two_passes.py",
            "description": "This file is a test fixture for the Ruff Python formatter, specifically designed to verify its two-pass formatting behavior when line ranges are applied. It ensures that the second formatting pass correctly respects the initial line range specified by the `--line-ranges` flag.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/black/cases/line_ranges_indentation.py",
            "description": "This file is a test fixture for `ruff_python_formatter` to verify its ability to format only a specific line range, particularly focusing on how indentation is handled when only a subset of lines is affected, simulating Black's behavior.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/black/cases/is_simple_lookup_for_doublestar_expression.py",
            "description": "This file is a test fixture for the Ruff Python formatter, specifically demonstrating how the `black` formatting style handles spacing around the double-star (exponentiation) operator in different expressions.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/black/cases/module_docstring_after_comment.py",
            "description": "This file is a Black-compatible test fixture for the Ruff Python formatter, specifically designed to test the formatting of a module docstring placed after an initial comment.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/black/cases/pattern_matching_with_if_stmt.py",
            "description": "This file is a test fixture for the `ruff_python_formatter`, specifically designed to test the formatting of `match` statements with `if` conditions, including those with long conditions, multi-line conditions, and embedded comments.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/black/cases/pep_572_py39.py",
            "description": "This file serves as a test fixture for the `ruff_python_formatter`, specifically demonstrating and verifying the formatting of Python 3.9 PEP 572 (walrus operator) features in set literals and comprehensions, and handling of parentheses.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/black/cases/pep646_typed_star_arg_type_var_tuple.py",
            "description": "This file serves as a test fixture for the Ruff Python formatter, specifically to verify its formatting behavior for PEP 646 (TypeVarTuple) with typed star arguments, ensuring compatibility with Black's output.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/black/cases/module_docstring_1.py",
            "description": "This file serves as a test fixture for the Ruff Python formatter, specifically demonstrating the expected newline formatting rules after a module-level docstring and a standalone string literal, mimicking Black's style.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/black/cases/pattern_matching_trailing_comma.py",
            "description": "This file serves as a test fixture for the `ruff_python_formatter` to verify its handling of trailing commas within pattern matching `case` statements, adhering to Black's formatting rules. It includes various `match` patterns demonstrating this specific syntax.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/black/cases/pep_750.py",
            "description": "This file serves as a test fixture for the ruff_python_formatter, specifically demonstrating the formatting of Python's PEP 750 template string literals with various complex interpolations and structures.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/black/cases/preview_comments7.py",
            "description": "This file contains various Python code snippets, primarily serving as a test fixture to evaluate how the formatter handles comments in different contexts, including imports, assignments, function calls, class definitions, and list literals.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/black/cases/no_blank_line_before_docstring.py",
            "description": "This file serves as a test fixture for a Python formatter, specifically to evaluate how it handles the placement and blank lines before docstrings in various function and class definitions, mimicking Black's formatting style.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/black/cases/pattern_matching_complex.py",
            "description": "This file contains a collection of Python pattern matching examples with various complex cases. It serves as a test fixture for a Python formatter, likely to ensure correct formatting of `match` statements.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/black/cases/percent_precedence.py",
            "description": "This file serves as a test fixture for the Ruff Python formatter, specifically to verify correct Black-compatible formatting for expressions involving the string formatting operator (`%`) and various other operators, testing their precedence.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/black/cases/function.py",
            "description": "This file serves as a test fixture for the Ruff Python formatter, containing various function definitions to test different formatting scenarios and Python syntax elements, particularly those handled by the Black style.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/black/cases/numeric_literals_skip_underscores.py",
            "description": "This file contains various numeric literals, including integers, floats, and hexadecimal values, some with underscores. It serves as a test fixture for the `ruff` formatter to ensure it correctly handles and preserves underscores in numeric literals, consistent with Black's formatting style.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/black/cases/pep_654_style.py",
            "description": "This file contains test cases demonstrating various usages of PEP 654's `except *ExceptionGroup` syntax. It serves as a fixture to ensure the `ruff_python_formatter` correctly formats code using exception groups.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/black/cases/module_docstring_2.py",
            "description": "This file is a test fixture for the `ruff_python_formatter` focused on evaluating how it handles module docstrings, including those with trailing spaces, and distinguishes them from other multi-line string literals, aligning with Black's formatting style.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/black/cases/pep_572_py310.py",
            "description": "This file contains Python 3.10 code examples demonstrating the use of the walrus operator (`:=`) in dictionary indices, generator expressions within function calls, and `with` statements, likely serving as a test case for a Python formatter.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/black/cases/long_strings_flag_disabled.py",
            "description": "This file contains a collection of test cases for a Python formatter (like Black) demonstrating how various long string literals, f-strings, and formatted strings should be handled in different contexts, particularly regarding line wrapping and preservation of their structure or comments. It showcases scenarios for string assignments, dictionary values, function arguments, and assertions.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/black/cases/preview_fmtpass_imports.py",
            "description": "This file is a test fixture for the Ruff Python formatter, specifically designed to test the correct handling of `fmt: skip` and `fmt: off`/`fmt: on` comments around import statements, addressing a Black formatter regression.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/black/cases/preview_long_strings__regression.py",
            "description": "This file contains regression test cases for a Python formatter, specifically focusing on how it handles long strings, string concatenation, and various string formatting techniques across different Python constructs.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/black/cases/pep_572_remove_parens.py",
            "description": "This file contains various test cases demonstrating the use of the walrus operator (`:=`) across different Python constructs. It primarily serves to test how a code formatter handles parentheses around assignment expressions as per PEP 572.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/black/cases/preview_standardize_type_comments.py",
            "description": "This file serves as a test case for a Python formatter to verify the standardization of type comments with varying spacing and formats, likely for a 'preview' mode feature.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/black/cases/prefer_rhs_split_reformatted.py",
            "description": "This file contains Black-compatible reformatted test cases for `ruff_python_formatter`, demonstrating specific formatting behaviors related to line splitting, assignments, and a regression test for issue #1187.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/black/cases/preview_fstring.py",
            "description": "This file serves as a test case for Python's f-string formatting, specifically demonstrating the behavior of the debug (`=`) specifier with empty string literals.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/black/cases/preview_long_strings__type_annotations.py",
            "description": "This file contains test cases demonstrating the formatting of long type annotations, particularly those involving multi-line string literals, within Python function definitions.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/black/cases/remove_except_types_parens.py",
            "description": "This file contains test cases demonstrating how a Python formatter (like Black) handles the removal or retention of parentheses around exception types in `try...except` and `try...except*` statements.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/black/cases/preview_long_strings__east_asian_width.py",
            "description": "Tests how the formatter handles line wrapping for long East Asian strings, specifically considering their rendered width rather than just code point count, as part of `black` compatibility tests for `ruff`.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/black/cases/preview_long_strings__edge_case.py",
            "description": "This file contains various test cases for how a Python formatter handles long string literals, string formatting, and string concatenation across different Python constructs, focusing on line wrapping and splitting behavior.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/black/cases/preview_pep646_typed_star_arg_type_var_tuple.py",
            "description": "This file is a Black compatibility test fixture for the Ruff Python formatter, specifically designed to test the formatting of PEP 646 typed star arguments using `TypeVarTuple`.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/black/cases/raw_docstring_no_string_normalization.py",
            "description": "This file contains test cases for Python docstrings with various prefixes (raw, f-string raw, unicode) to ensure they are not normalized during formatting, specifically when string normalization is disabled.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/black/cases/multiline_consecutive_open_parentheses_ignore.py",
            "description": "This test fixture for the Ruff Python formatter verifies Black-compatible formatting of multiline consecutive open parentheses. It specifically checks how `type: ignore` comments are handled when placed on the same line as an opening parenthesis.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/black/cases/pep_654.py",
            "description": "This file serves as a test fixture for the Ruff Python formatter, specifically to test the formatting of code using PEP 654's exception groups (except* syntax) and their interactions.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/black/cases/preview_cantfit.py",
            "description": "This file serves as a test fixture for a Python formatter, showcasing various scenarios where lines of code are inherently too long to fit within standard line limits, even with formatting applied. It includes examples of long variable names, function calls, and string literals to test formatter behavior in 'cannot fit' situations.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/black/cases/pep604_union_types_line_breaks.py",
            "description": "This file contains Python code examples designed as a test fixture for a formatter, specifically focusing on how it handles PEP 604 union type syntax, line breaks in long expressions and type annotations, and function definitions with complex type hints and default arguments in a Black-like style.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/black/cases/preview_cantfit_string.py",
            "description": "This file serves as a test fixture for the Ruff Python formatter, specifically to evaluate its behavior when formatting function calls with arguments that are too long to fit within the line limit, even after reformatting. It ensures the formatter handles 'cannot fit' scenarios gracefully for string arguments in a Black-like preview mode.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/black/cases/python39.py",
            "description": "This file contains test cases for Python code formatting, specifically focusing on decorators with complex arguments like subscripting and assignment expressions, especially when they are long and require wrapping.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/black/cases/py310_pep572.py",
            "description": "Tests the `ruff_python_formatter`'s ability to format PEP 572 assignment expressions (walrus operator) within subscripting contexts, specifically mimicking Black's style.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/black/cases/pep_646.py",
            "description": "Tests the Black formatter's handling of PEP 646 features, including unpacked `*args` in subscript expressions for item access, assignment, deletion, and function annotations.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/black/cases/single_line_format_skip_with_multiple_comments.py",
            "description": "This file serves as a test fixture for the Ruff formatter, demonstrating how it handles `fmt: skip` directives when combined with other comments like `noqa` or `pylint` on single lines.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/black/cases/remove_with_brackets.py",
            "description": "This file serves as a test fixture for a Python formatter (likely Ruff or Black) to verify its behavior regarding the removal or retention of parentheses in 'with' statements, covering various syntax permutations and edge cases.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/black/cases/trailing_comma.py",
            "description": "This file contains Python code snippets demonstrating various collection types (dictionaries, lists, tuples, sets) with different elements, trailing commas, and comments. It serves as a test fixture for a code formatter to evaluate its handling of these formatting scenarios.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/black/cases/power_op_spacing_long.py",
            "description": "This file is a test fixture for the Ruff Python formatter, specifically designed to test the handling of spacing around the power operator (**) in long expressions, ensuring compatibility with the Black formatter's style.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/black/cases/slices.py",
            "description": "This file is a test fixture for a Python formatter, containing various examples of slice notation in Python, including complex expressions, lambdas, and async operations, to ensure correct formatting.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/black/cases/remove_for_brackets.py",
            "description": "Tests Black's formatting behavior for `for` loops with tuple unpacking, specifically how it handles the removal or retention of parentheses around loop variables under various conditions.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/black/cases/tricky_unicode_symbols.py",
            "description": "This file contains variable assignments using various Unicode symbols, likely serving as a test case to ensure the formatter (Ruff, emulating Black) correctly handles tricky Unicode characters in identifiers.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/black/cases/preview_remove_multiline_lone_list_item_parens.py",
            "description": "This file serves as a test fixture for a Python formatter (likely Black or Ruff's Black-compatible formatter). It demonstrates cases where parentheses around a single, multiline list item should either be removed, preserved, or handled correctly with comments, especially when using conditional expressions or logical operators.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/black/cases/tupleassign.py",
            "description": "Tests Black's formatting of tuple assignments, particularly focusing on line wrapping for long assignments and parenthesization for single-element tuples on the left-hand side.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/black/cases/remove_lone_list_item_parens.py",
            "description": "This file serves as a Black-compatible test fixture for the Ruff Python formatter, demonstrating how parentheses around lone list or set items are handled, including cases involving multiline expressions and comments.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/black/cases/type_comment_syntax_error.py",
            "description": "Tests how the formatter handles Python type comments with syntax errors, specifically an incorrectly placed type comment for a function parameter.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/black/cases/preview_wrap_comprehension_in.py",
            "description": "This file serves as a test fixture for the Ruff Python formatter, specifically demonstrating how list and dictionary comprehensions are wrapped and formatted according to Black's style, particularly concerning the 'in' keyword and line length.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/black/cases/power_op_newline.py",
            "description": "This file is a test fixture for the `ruff_python_formatter`, used to verify its behavior in formatting expressions involving the power operator (`**`), especially concerning newline placement. It's part of a Black-compatibility test suite.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/black/cases/python38.py",
            "description": "This file contains Python 3.8 specific syntax examples, such as starred expressions in return/yield statements and annotated assignments, serving as a test fixture for code formatting.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/black/cases/prefer_rhs_split.py",
            "description": "This file is a test fixture for a Python formatter, demonstrating how assignments with long right-hand side expressions are formatted, particularly focusing on line splitting behavior and parenthesis placement in various scenarios, including chained assignments and `type: ignore` comments.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/black/cases/remove_await_parens.py",
            "description": "This file serves as a test fixture for the Ruff Python formatter, specifically to verify its behavior in removing or retaining parentheses around `await` expressions under various conditions, including different nesting levels, comments, and operator precedence.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/black/cases/preview_long_dict_values.py",
            "description": "This file serves as a test fixture for a Python code formatter, specifically demonstrating various complex and long dictionary structures, including long values, function calls as keys, dictionary comprehensions, and nested dictionaries, to ensure correct formatting.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/black/cases/preview_format_unicode_escape_seq.py",
            "description": "This file contains a collection of Python string literals with various escape sequences (hex, unicode, named characters, raw, byte) to serve as a test fixture for the `ruff` formatter's handling of such strings, particularly under `black`'s preview formatting.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/black/cases/type_param_defaults.py",
            "description": "Test fixture demonstrating various type parameter syntax, including default values and parameter packs, for type aliases and function definitions. It covers simple cases, long identifiers, and trailing commas to test formatting behavior.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/black/cases/preview_hug_parens_with_braces_and_square_brackets.py",
            "description": "This file serves as a test fixture for a Python formatter, containing various code examples to evaluate how it formats dictionaries, lists, and list comprehensions, particularly concerning parenthesization, line wrapping, and comment placement around braces and square brackets.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/black/cases/remove_parens_from_lhs.py",
            "description": "Tests the removal of unnecessary parentheses from the left-hand side of assignments, including single variables and tuple unpacking, while preserving necessary parentheses for single-element tuples or precedence on the right-hand side.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/black/cases/split_delimiter_comments.py",
            "description": "This file contains test cases for the Python formatter, specifically demonstrating how it handles line splitting with various types of inline comments, such as 'type: ignore' and general comments.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/black/cases/return_annotation_brackets.py",
            "description": "This file serves as a test fixture for a Python formatter, demonstrating various return type annotation syntaxes, including parenthesized types, newline variations, comments, deeply nested parentheses, and long or tuple type annotations.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/black/cases/remove_redundant_parens_in_case_guard.py",
            "description": "This file contains test cases for a Python formatter (likely Black or Ruff) to verify the removal or retention of redundant parentheses in `case` guards, considering different placements of comments.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/black/cases/skip_magic_trailing_comma.py",
            "description": "This file serves as a test fixture for the Ruff Python formatter, demonstrating its behavior regarding the removal or retention of magic trailing commas in various Python constructs, including subscripts, collections, and function calls.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/black/cases/trailing_comma_optional_parens2.py",
            "description": "This file is a test fixture for the Ruff Python formatter, specifically used to verify its behavior when formatting complex conditional statements involving tuple comparisons and optional parentheses, ensuring correct indentation and line breaking.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/black/cases/typed_params_trailing_comma.py",
            "description": "This file serves as a test fixture for the `ruff_python_formatter`, specifically to verify its handling of function definitions with type-hinted parameters and trailing commas, adhering to Black's formatting style.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/black/cases/dummy_implementations.py",
            "description": "This file acts as a test fixture for a Python formatter, showcasing various code structures that use the Ellipsis (`...`) as a placeholder. It verifies how the formatter handles function stubs, overloaded definitions, protocol methods, and class methods, including those with comments.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/black/cases/raw_docstring.py",
            "description": "This file serves as a test fixture for the Ruff Python formatter, showcasing various raw docstring styles for Black compatibility.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/black/cases/remove_parens.py",
            "description": "This file contains test cases for a Python formatter, demonstrating scenarios where redundant or excessively nested parentheses around various expressions (literals, strings, comprehensions) should be removed or handled correctly.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/black/cases/preview_multiline_strings.py",
            "description": "This file serves as a test fixture for a Python code formatter, providing numerous examples of multiline string usage, including those with `textwrap.dedent`, f-strings, and within various Python constructs. It's designed to ensure correct formatting of diverse multiline string scenarios.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/black/cases/type_aliases.py",
            "description": "This file contains various test cases demonstrating the `type` alias statement in Python, including generic, conditional, and lambda type aliases, along with a scenario where 'type' is used as a variable name. It serves as a fixture for a Python formatter to test its handling of these constructs.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/black/cases/python37.py",
            "description": "This file contains test cases showcasing various asynchronous generator comprehensions and `await` expressions within comprehensions. It serves as a fixture to test a Python formatter's handling of Python 3.7+ async syntax.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/black/cases/remove_except_parens.py",
            "description": "Test cases demonstrating the formatting rules for parentheses around exception types in `except` clauses, distinguishing between redundant parentheses for single exceptions and required parentheses for tuples of exceptions.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/black/cases/walrus_in_dict.py",
            "description": "Tests the `ruff_python_formatter`'s ability to correctly format dictionaries containing walrus operators as values, specifically when the `wrap_long_dict_values_in_parens` preview style is active.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/black/cases/preview_return_annotation_brackets_string.py",
            "description": "This file is a test fixture for the Ruff Python formatter, simulating Black's behavior with long string literal return type annotations. It examines how these annotations are formatted, particularly regarding line wrapping and the presence of function parameters.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/black/cases/string_prefixes.py",
            "description": "This file serves as a test fixture for a Python formatter, specifically to verify its handling of various string literal prefixes (e.g., `f`, `b`, `u`, `r`, and their combinations) and raw docstrings.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/black/cases/preview_hug_parens_with_braces_and_square_brackets_no_ll1.py",
            "description": "This file is a test fixture for `ruff_python_formatter` demonstrating how it handles parenthesization (hugging) around braces and square brackets, especially with long lines and specific line length settings. It explores cases where expressions should or should not be hugged based on their length and content.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/black/cases/pep_604.py",
            "description": "This file contains Python code demonstrating long type annotations using PEP 604 union syntax (`|`). It serves as a test fixture for the Ruff Python formatter, specifically to verify its handling of complex and lengthy type unions when formatting code.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/black/cases/torture.py",
            "description": "This file serves as a Black formatter test fixture, containing various challenging and 'torturous' code snippets designed to stress-test the formatter's resilience and behavior with edge cases, long lines, and complex syntax.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/black/cases/type_expansion.py",
            "description": "This file contains test cases for the Ruff Python formatter, specifically designed to verify its handling of generic type parameters with complex type bounds (type expansion) as per Black's formatting style. It tests various tuple-based type constraints for type variables.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/black/cases/trailing_comma_optional_parens1.py",
            "description": "This file provides a collection of Python code snippets designed as test cases for a code formatter. It showcases various scenarios involving line breaks, parenthesization, and complex expressions to ensure correct formatting behavior.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/black/cases/type_params.py",
            "description": "This file contains various Python function and class definitions utilizing type parameters. It serves as a test fixture to evaluate how a code formatter handles complex, long, or unusual type parameter syntax.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/black/cases/trailing_comma_optional_parens3.py",
            "description": "This file serves as a Black formatter test case for `ruff_python_formatter`, specifically demonstrating how the formatter handles long, multi-line string literals and string formatting within nested function calls, including optional parentheses and trailing commas.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/black/cases/function2.py",
            "description": "This file is a test fixture for the `ruff_python_formatter`, showcasing diverse Python function definitions, conditional blocks, and complex argument lists. It evaluates the formatter's ability to apply consistent styling, particularly line wrapping and newline conventions, mirroring `black`'s test cases.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/black/cases/remove_newline_after_code_block_open.py",
            "description": "This file serves as a test fixture for a Python formatter, demonstrating scenarios where blank lines within various code blocks (functions, loops, conditionals) should be preserved, especially after the block's opening statement.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/black/cases/pep_701.py",
            "description": "This file contains a comprehensive collection of f-string examples, including various edge cases, complex expressions, and formatting options. It serves as a test fixture to ensure Python formatters correctly handle f-string syntax according to PEP 701.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/black/cases/trailing_commas_in_leading_parts.py",
            "description": "This file contains test cases (fixtures) for a Python code formatter, specifically to verify its behavior with trailing commas in various expressions and function calls. It includes examples replicating issues and edge cases found in the Black formatter.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/black/cases/tuple_with_stmt.py",
            "description": "This file serves as a Black formatter test case, specifically demonstrating and testing the formatting of `with` statements that involve context managers grouped within parentheses, including tuple-like expressions. It also includes a test verifying expected `TypeError` behavior for such constructs.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/black/cases/remove_except_types_parens_pre_py314.py",
            "description": "This file is a test fixture for the Ruff Python formatter, specifically to verify its behavior in removing or retaining parentheses around exception types in `try...except` and `try...except*` statements, adhering to Black's formatting style for Python versions before 3.14.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/black/cases/preview_long_strings.py",
            "description": "This file is a test fixture for a Python formatter, showcasing various scenarios involving long strings in assignments, data structures, function calls, and assertions to verify correct line wrapping and formatting behavior.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/black/cases/preview_import_line_collapse.py",
            "description": "This file serves as a test fixture for the `ruff_python_formatter`, demonstrating various scenarios for import statement formatting, including handling comments, multiple imports, imports within `try-except` blocks, and imports inside functions, to mimic Black's `preview_import_line_collapse` behavior.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/black/miscellaneous/missing_final_newline.py",
            "description": "This test fixture, related to Black's formatting, is a comment-only Python file that specifically lacks a final newline character, used to test formatter behavior in such edge cases.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/black/miscellaneous/blackd_diff.py",
            "description": "This file serves as a test fixture for the `ruff_python_formatter`, specifically demonstrating how `blackd` (Black formatter daemon) would handle generating a diff for unformatted Python code. It contains intentionally unformatted Python code to test the formatter's diffing capabilities.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/black/miscellaneous/string_quotes.py",
            "description": "This file serves as a comprehensive test fixture for a Python formatter, demonstrating various string literal types including single, double, triple, f-strings, and raw strings, along with their quote handling and escaping rules. It specifically tests how formatters preserve or modify quotes in different scenarios, including complex f-string expressions.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/black/miscellaneous/force_py36.py",
            "description": "A test fixture for the `ruff_python_formatter` to verify how it formats long function signatures without introducing Python 3.6+ specific syntax, mirroring `black`'s behavior.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/isort/combine_import_from.py",
            "description": "This file serves as a test fixture for ruff's isort functionality, specifically to test how multiple 'from collections import ...' statements are combined.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/isort/force_single_line.py",
            "description": "This file serves as a test fixture for import sorting/formatting, demonstrating various import statement styles, including multi-line, aliased, and commented imports.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/isort/length_sort_straight_imports.py",
            "description": "Tests how the `isort` formatter within Ruff sorts straight imports based on their length. It contains imports of different lengths to verify the sorting logic.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/isort/if_elif_else.py",
            "description": "This file tests or demonstrates conditional imports of the `sdist` command, providing fallbacks based on whether `setuptools` is available or `sdist` is already defined in `cmds`.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/isort/no_lines_before.py",
            "description": "This file serves as a test fixture for the `ruff_linter`, specifically demonstrating import sorting behavior by `isort` when no blank lines precede the import statements.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/isort/magic_trailing_comma.py",
            "description": "This file serves as a test fixture for import sorting (isort), demonstrating various scenarios related to trailing commas in import statements and their effect on reformatting (e.g., multi-line vs. single-line imports).",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/isort/preserve_comment_order.py",
            "description": "This file is a test fixture for `isort` within the `ruff` linter, designed to verify that comments embedded between import statements are preserved in their original order after sorting.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/isort/line_ending_lf.py",
            "description": "This file is an `isort` test fixture for the `ruff_linter`. It likely tests `isort`'s behavior or formatting rules when processing a Python file with a long import statement and LF line endings.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/isort/force_sort_within_sections_lines_between.py",
            "description": "This test fixture demonstrates how `isort` (or Ruff's `isort` formatter) handles sorting imports when `force_sort_within_sections` is enabled, specifically testing scenarios with blank lines between import statements within the same section.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/isort/lines_after_imports_class_after.py",
            "description": "This file is a test fixture for `isort` demonstrating various import types followed by a class definition, likely to verify import sorting rules and line spacing before a class.",
            "spof": false
          }
        ],
        "contributors": [
          {
            "name": "Brent Westbrook",
            "percent": 30
          },
          {
            "name": "Dylan",
            "percent": 26
          },
          {
            "name": "Micha Reiser",
            "percent": 25
          }
        ]
      },
      "Formatting Orchestration and CLI": {
        "files": [
          {
            "path": "docs/formatter.md",
            "description": "This document describes the Ruff formatter, a fast Python code formatter designed as a Black replacement. It covers its usage, philosophy, configuration options, and features for formatting code examples in docstrings and Markdown files.",
            "spof": false
          },
          {
            "path": "crates/ruff/src/commands/format_stdin.rs",
            "description": "This file implements the logic for formatting source code read from standard input (stdin) using the Ruff formatter, applying configuration settings and outputting the result to standard output (stdout).",
            "spof": false
          },
          {
            "path": "crates/ruff/src/commands/format.rs",
            "description": "This file orchestrates the formatting of Python files within the Ruff project. It handles different formatting modes (write, check, diff), processes file paths, applies formatting rules, utilizes caching, and reports the results or any encountered errors.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_formatter/README.md",
            "description": "This README describes the Ruff Python Formatter, an extremely fast Python code formatter integrated into the `ruff` CLI. It highlights its goals as a performance-focused replacement for Black, detailing its output similarity and providing getting started information.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_formatter/src/cli.rs",
            "description": "This file defines the command-line interface (CLI) for the Ruff Python formatter, handling argument parsing and orchestrating the formatting process, including debug output options.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_formatter/src/main.rs",
            "description": "This file implements the main command-line interface for the Ruff Python formatter. It parses arguments, reads Python code from stdin or files, formats it, and writes the output back to stdout or the original files.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_formatter/src/verbatim.rs",
            "description": "This file implements the logic for handling `fmt: off` and `fmt: on` comments, allowing the Python formatter to skip reformatting specific sections of code. It determines suppressed ranges and formats the code within them verbatim.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_formatter/src/range.rs",
            "description": "This file implements range formatting for Python code, allowing a specific section of the source to be formatted while preserving consistency with full document formatting.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/ruff/range_formatting/fmt_on_off.py",
            "description": "This file contains test cases for the `ruff_python_formatter` to verify its behavior with `fmt: off` and `fmt: on` markers, specifically for ranges that are entirely suppressed or partially suppressed from formatting.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/ruff/range_formatting/range_narrowing.py",
            "description": "Tests the `ruff` formatter's ability to format code within a specific range, particularly focusing on an `if/elif` statement structure.",
            "spof": true
          },
          {
            "path": "crates/ruff_markdown/src/lib.rs",
            "description": "This file provides functionality to format Python code blocks embedded within Markdown documents. It identifies Python code fences and applies Ruff's Python formatter, respecting 'off' and 'on' directives.",
            "spof": true
          }
        ],
        "contributors": [
          {
            "name": "Amethyst Reese",
            "percent": 41
          },
          {
            "name": "Brent Westbrook",
            "percent": 22
          },
          {
            "name": "Micha Reiser",
            "percent": 14
          }
        ]
      },
      "Python Syntax Formatting": {
        "files": [
          {
            "path": "crates/ruff_python_formatter/src/context.rs",
            "description": "This file defines `PyFormatContext`, which encapsulates the formatting state and options used by the Ruff Python formatter, along with related helper enums and structs for managing indentation and node levels during formatting.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_formatter/src/prelude.rs",
            "description": "This file serves as a prelude for the `ruff_python_formatter` crate, re-exporting commonly used types, traits, and utilities to simplify imports within other modules of the crate. It aggregates essential formatting components from both `ruff_python_formatter` and the underlying `ruff_formatter` library.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/src/builders.rs",
            "description": "This file provides Rust formatting utilities for Python code, including conditional parenthesizing and indentation for expressions, and a builder for handling comma-separated sequences with flexible trailing comma logic.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_formatter/src/shared_traits.rs",
            "description": "This file defines shared traits (`AsFormat`, `IntoFormat`, `FormattedIterExt`) for consistently formatting Python AST nodes and other objects within the `ruff_python_formatter` crate, allowing for ergonomic conversion to format-able types.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_formatter/src/lib.rs",
            "description": "This file serves as the main entry point and core logic for the Python formatter, defining traits and functions to format Python Abstract Syntax Tree (AST) nodes into a standardized code style. It handles parsing, formatting, and printing the source code, including comments and error handling.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_formatter/src/module/mod_expression.rs",
            "description": "This file implements the formatting logic for `ModExpression` nodes in Python, specifically formatting its body. It defines how a modulo expression should be represented in the formatted output.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/src/module/mod_module.rs",
            "description": "This file implements the formatting logic for a top-level Python module (`ModModule`), handling both empty modules and modules with content, ensuring proper line breaks.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_formatter/src/module/mod.rs",
            "description": "This file defines the `FormatMod` struct and its implementation, which serves as a central dispatcher for formatting different types of Python modules or expressions within the `ruff_python_formatter` crate, delegating the actual formatting to specialized sub-modules.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_formatter/src/other/alias.rs",
            "description": "This file defines the formatting logic for Python import aliases (`Alias` nodes in the AST), handling the 'as' keyword and associated comments such as trailing, leading, and dangling comments.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/src/other/commas.rs",
            "description": "This file provides utility functions to detect the presence of trailing commas within a given text range in Python code, specifically handling a 'magic trailing comma' formatting option.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_formatter/src/other/f_string.rs",
            "description": "This file defines the `FormatFString` rule, which is responsible for formatting Python f-string expressions within the `ruff_python_formatter` crate.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_formatter/src/other/decorator.rs",
            "description": "This file defines the formatting rule for Python decorator nodes (`@expression`) within the Ruff Python formatter. It ensures the `@` symbol is correctly placed and the decorator expression is formatted, potentially with optional parentheses.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/src/other/keyword.rs",
            "description": "This file defines the formatting logic for Python 'Keyword' AST nodes within the Ruff Python formatter, handling cases like 'arg=value' or '**value'.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_formatter/src/other/comprehension.rs",
            "description": "This file implements the formatting logic for Python comprehension expressions, including their 'for' and 'if' clauses, and handles associated comments and spacing.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/src/other/identifier.rs",
            "description": "This file defines how to format Python identifiers, including a special handler for dot-delimited identifiers in imports that may contain non-standard whitespace or newlines, ensuring consistent formatting by removing them.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_formatter/src/other/with_item.rs",
            "description": "This file defines the formatting logic for Python `with` statement items (`WithItem`) in the Ruff formatter. It uses different layout strategies (`WithItemLayout`) to handle varying parenthesization, Python versions, and comment placements.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/src/other/interpolated_string_element.rs",
            "description": "This file defines the formatting logic for individual elements within Python f-strings (interpolated string literals), handling both literal text segments and embedded expressions, along with their conversion flags and format specifications.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/src/other/parameter.rs",
            "description": "This file defines the formatting logic for a Python function parameter, including its name and optional type annotation, within the Ruff Python formatter.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/src/other/parameters.rs",
            "description": "This file implements the formatting logic for Python function and lambda parameters within Ruff, handling different parameter types, parentheses, separators, and comment placement rules.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_formatter/src/other/interpolated_string.rs",
            "description": "This file defines data structures and logic for determining the formatting layout (flat or multiline) of interpolated strings (f-strings) within the Python formatter, based on their existing content.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/src/other/t_string.rs",
            "description": "This file defines the formatting logic for 't-strings' within the Ruff Python formatter. It handles the structure, quotes, and interpolated elements of a TString node.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/src/other/mod.rs",
            "description": "This module (`mod.rs`) serves as a central declaration file, exposing various sub-modules that handle the formatting of specific Python syntax elements or AST nodes within the `ruff_python_formatter` crate.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_formatter/src/other/match_case.rs",
            "description": "This file defines the formatting logic for Python's `match-case` statements within the `ruff_python_formatter` crate. It implements the `FormatNodeRule` for `MatchCase` AST nodes, handling the formatting of the pattern, guard, and body.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_formatter/src/other/elif_else_clause.rs",
            "description": "This file defines a formatter for `ElifElseClause` in Python, specifically for the `ruff` formatter. It provides a `FormatNodeRule` implementation to format `elif` and `else` blocks, though its direct use is limited by a more comprehensive formatting function in `stmt_if`.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/src/other/parameter_with_default.rs",
            "description": "This file implements the formatting logic for Python parameters with default values, including handling line breaks and comments around the assignment operator.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/src/other/except_handler_except_handler.rs",
            "description": "This file defines the formatting logic for `ExceptHandlerExceptHandler` AST nodes, which represent `except` clauses in Python's `try...except` statements. It handles the formatting of exception types, optional `as` names, starred exceptions, and special casing for tuple exception types in newer Python versions.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_formatter/src/other/arguments.rs",
            "description": "This file defines the formatting logic for function call arguments in Python, handling their layout, parenthesization, comments, and specific formatting styles like 'hugging' for certain argument types.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_formatter/src/expression/expr_await.rs",
            "description": "This file defines the formatting rules and parentheses handling for Python `await` expressions within the Ruff Python formatter. It specifies how `await` keywords and their associated values should be formatted.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_formatter/src/expression/expr_bin_op.rs",
            "description": "This file defines the formatting logic and parenthesis requirements for Python binary operation expressions within the Ruff Python formatter.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/src/expression/expr_named.rs",
            "description": "This file defines the formatting logic for Python 'named expressions' (assignment expressions, e.g., `a := b`), handling the formatting of its target, value, and any associated comments. It also specifies when named expressions require parentheses based on their parent context.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_formatter/src/expression/expr_boolean_literal.rs",
            "description": "This file defines how to format Python boolean literals ('True' and 'False') within the `ruff_python_formatter` crate, ensuring they are rendered correctly and determine parenthesis needs.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/src/expression/expr_none_literal.rs",
            "description": "This file defines the formatting logic for Python's `None` literal expression within the Ruff formatter, including how it's rendered and its parenthesization rules.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/src/expression/expr_bytes_literal.rs",
            "description": "This file defines the formatting logic for Python byte literals (`ExprBytesLiteral`) within the `ruff` formatter. It handles single-part and implicitly concatenated byte strings, and determines when parentheses are required for their formatting.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_formatter/src/expression/expr_dict_comp.rs",
            "description": "This file implements the formatting logic for Python dictionary comprehensions within the R `ruff` Python formatter. It defines how dictionary comprehensions, including their keys, values, and generators, should be formatted, handling inline comments appropriately.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_formatter/src/expression/expr_name.rs",
            "description": "This file defines the formatting logic for `ExprName` (name expression) nodes in the Ruff Python formatter, ensuring they are rendered correctly, including handling their range and parentheses.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_formatter/src/expression/binary_like.rs",
            "description": "This module defines structures and logic to flatten nested binary, comparison, and boolean expressions into a linear sequence of operands and operators, crucial for consistent formatting and handling operator precedence in Python code.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/src/expression/expr_list.rs",
            "description": "This file implements the formatting logic for Python list expressions (`ExprList`) within the Ruff Python formatter, ensuring elements are correctly enclosed in square brackets and separated by commas.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_formatter/src/expression/expr_ipy_escape_command.rs",
            "description": "This file defines the formatting logic for IPython escape command expressions (`ExprIpyEscapeCommand`) within the Ruff Python formatter, specifically stating they never require parentheses.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_formatter/src/expression/expr_call.rs",
            "description": "This file defines the formatting rules for `ExprCall` (function calls) in Python, including logic for handling call chain layouts and determining necessary parentheses.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_formatter/src/expression/expr_compare.rs",
            "description": "This file implements the formatting logic for Python comparison expressions (`ExprCompare`) and their operators (`CmpOp`) within the Ruff Python formatter.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/src/expression/expr_dict.rs",
            "description": "This file implements the formatting logic for Python dictionary expressions (ExprDict) within the Ruff formatter. It handles the layout of dictionary items, including key-value pairs and `**kwargs` entries, along with their associated comments.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_formatter/src/expression/expr_starred.rs",
            "description": "This file defines the formatting logic for Python `ExprStarred` nodes (e.g., `*args`, `**kwargs`) within the Ruff Python formatter, including handling the asterisk token, the starred expression's value, and associated comments.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_formatter/src/expression/expr_bool_op.rs",
            "description": "This file defines the formatting logic for Python boolean expressions (`and`, `or`) within the Ruff formatter, including how to render the operators and determine parenthesis requirements.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/src/expression/expr_set_comp.rs",
            "description": "This file implements the formatting logic for Python set comprehension expressions (`ExprSetComp`) within the `ruff` formatter. It defines how to arrange the element and generators, including handling comments and parentheses.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_formatter/src/expression/expr_ellipsis_literal.rs",
            "description": "This file defines the formatting logic for Python ellipsis literals (`...`) within the `ruff_python_formatter` crate, including how they are rendered and their parenthesis requirements.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/src/expression/expr_f_string.rs",
            "description": "This file defines the formatting logic for Python f-string expressions, including how they are formatted and when they require parentheses, especially for multiline or implicitly concatenated f-strings.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_formatter/src/expression/expr_slice.rs",
            "description": "Formats Python slice expressions (e.g., `[lower:upper:step]`), handling the layout of its components, comments, and spacing around colons according to a specific style guide (likely Black).",
            "spof": false
          },
          {
            "path": "crates/ruff_python_formatter/src/expression/expr_set.rs",
            "description": "This file defines how to format Python set expressions (`ExprSet`) within the `ruff_python_formatter`, including handling their elements and surrounding braces.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_formatter/src/expression/expr_yield.rs",
            "description": "This file defines the formatting logic and parenthesization rules for Python 'yield' and 'yield from' expressions within the Ruff Python formatter.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_formatter/src/expression/expr_yield_from.rs",
            "description": "This file defines the formatting logic for Python `yield from` expressions within the `ruff` formatter, including rules for determining when parentheses are required around them.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_formatter/src/expression/expr_list_comp.rs",
            "description": "This file defines the formatting logic for Python list comprehension expressions (`ExprListComp`) within the Ruff Python formatter. It specifies how the element and generators of a list comprehension should be rendered.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_formatter/src/expression/operator.rs",
            "description": "This file implements the formatting logic for Python operators within the `ruff_python_formatter`, converting `Operator` enum variants into their corresponding string representations (e.g., `+`, `-`, `*`).",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/src/expression/expr_if.rs",
            "description": "This file defines the formatting logic for Python's conditional expressions (e.g., `value if condition else other_value`), handling their layout, parenthesization, and special rules for nested expressions within the Ruff formatter.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/src/expression/expr_string_literal.rs",
            "description": "This file defines the formatting logic for Python expression string literals, including handling single-part strings, implicitly concatenated strings, and determining when parentheses are necessary for these literals.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/src/expression/expr_t_string.rs",
            "description": "This file defines how `ExprTString` (type strings or templated strings) nodes are formatted in the Ruff Python formatter, including handling implicit string concatenation and determining when parentheses are needed.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/src/expression/mod.rs",
            "description": "This module serves as the primary dispatcher for formatting all types of Python expressions (Expr) within the `ruff_python_formatter` crate. It orchestrates the formatting process, delegating to specialized formatters for each expression variant and managing complex parenthesization and comment placement logic.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_formatter/src/expression/expr_number_literal.rs",
            "description": "This file implements the formatting logic for number literals (integers, floats, and complex numbers) in the Ruff Python formatter. It includes functions to normalize the string representation of these numbers according to formatting rules.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_formatter/src/expression/expr_attribute.rs",
            "description": "This file defines the formatting logic for Python attribute expressions (e.g., `obj.attr`) within the Ruff Python formatter. It includes rules for handling call chains, parenthesization, and comments surrounding the dot operator.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_formatter/src/expression/parentheses.rs",
            "description": "This file defines the logic and strategies for determining when and how to format Python expressions with parentheses, including handling optional parentheses for line breaking and preserving existing ones.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_formatter/src/expression/expr_lambda.rs",
            "description": "This file defines the formatting logic for Python `lambda` expressions within the `ruff` formatter, including handling their parameters, body, and associated comments. It also specifies different layout options for lambdas, particularly when they are part of an assignment.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/src/expression/expr_unary_op.rs",
            "description": "This file defines the formatting rules for Python unary expressions (e.g., `not x`, `-y`, `~z`), handling operator placement, comments, and the necessary parenthesization for correct output.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/src/expression/expr_tuple.rs",
            "description": "This file defines the formatting rules for Python tuple expressions (`ExprTuple`), including complex logic for determining when and how parentheses should be applied based on context, such as single-element tuples, comprehension targets, or existing parenthesization.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_formatter/src/expression/expr_subscript.rs",
            "description": "This file implements the formatting logic for Python subscript expressions (e.g., `value[slice]`) within the Ruff formatter. It includes rules for proper parenthesization, comment handling, and integration with call chain formatting.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_formatter/src/pattern/pattern_match_class.rs",
            "description": "This file defines the formatting logic for `PatternMatchClass` nodes in the Python Abstract Syntax Tree (AST), specifying how its fields are formatted and when it requires parentheses in the output.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_formatter/src/pattern/pattern_match_mapping.rs",
            "description": "This file defines the formatting logic for Python's `PatternMatchMapping` syntax (e.g., `{key: pattern, **rest}`), including handling keys, patterns, rest elements, and associated comments.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_formatter/src/pattern/pattern_match_or.rs",
            "description": "This file implements the formatting logic for `or` patterns within Python match statements, handling the layout of multiple patterns separated by the `|` operator and managing parentheses.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_formatter/src/pattern/pattern_match_star.rs",
            "description": "This file defines the formatting logic for `PatternMatchStar` nodes in Python abstract syntax trees for the Ruff formatter. It handles rendering the `*` token, any associated comments, and the variable name (or underscore) within a pattern matching context.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/src/pattern/pattern_match_as.rs",
            "description": "This file defines how to format Python `match ... as` patterns in the Ruff formatter. It handles the layout of the pattern, the `as` keyword, the bound name, and associated comments, as well as determining parenthesis requirements.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_formatter/src/pattern/pattern_keyword.rs",
            "description": "This file implements the formatting logic for a `PatternKeyword` AST node in Python, rendering it as 'attribute = pattern'.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_formatter/src/pattern/pattern_match_sequence.rs",
            "description": "This file defines the formatting logic for Python pattern matching sequences, handling various forms such as lists and tuples (both parenthesized and unparenthesized). It determines the sequence type and applies the appropriate formatting rules.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_formatter/src/pattern/pattern_match_singleton.rs",
            "description": "Formats Python singleton literals (None, True, False) when they appear in `match` statement patterns, ensuring consistent formatting and parenthesization rules within the `ruff_python_formatter`.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_formatter/src/pattern/pattern_arguments.rs",
            "description": "This file defines the formatting logic for `PatternArguments` in Python's pattern matching, handling cases with empty arguments, single arguments, multiple arguments, and associated comments.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_formatter/src/pattern/pattern_match_value.rs",
            "description": "This file implements formatting and parenthesis determination for `PatternMatchValue` nodes within the Ruff Python formatter. It ensures that the inner value of a pattern match expression is formatted correctly without additional parentheses.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_formatter/src/pattern/mod.rs",
            "description": "This module serves as the central hub for formatting Python match statement patterns within the Ruff Python formatter. It defines the core `FormatPattern` structure, manages parentheses application, and dispatches to specific sub-modules for different pattern types.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_formatter/src/statement/stmt_continue.rs",
            "description": "This file defines the formatting logic for Python's `continue` statement within the Ruff Python formatter, ensuring it is formatted correctly in the output.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/src/statement/stmt_break.rs",
            "description": "This file implements the formatting logic for Python `break` statements within the Ruff Python formatter. It ensures that `break` statements are formatted correctly when the code is processed.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/src/statement/stmt_if.rs",
            "description": "This file is responsible for formatting Python `if`, `elif`, and `else` statements within the `ruff` Python formatter. It defines how these statement structures are rendered in the formatted output.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_formatter/src/statement/stmt_ipy_escape_command.rs",
            "description": "This file implements the formatting logic for IPython escape commands (`StmtIpyEscapeCommand`) within the Ruff Python formatter, ensuring they are rendered correctly in the output.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/src/statement/stmt_import.rs",
            "description": "This file implements the formatting logic for Python `import` statements within the `ruff_python_formatter` crate, ensuring they conform to established style guidelines.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_formatter/src/statement/stmt_expr.rs",
            "description": "Formats Python expression statements (`StmtExpr`), including special handling for parenthesizing arithmetic-like expressions and adding trailing semicolons in IPython notebooks.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/src/statement/stmt_assert.rs",
            "description": "This file implements the formatting logic for Python `assert` statements within the Ruff Python formatter. It handles the layout of the assertion condition and an optional message.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_formatter/src/statement/stmt_pass.rs",
            "description": "This file defines the formatting logic for the Python `pass` statement within the `ruff_python_formatter` crate. It ensures that `pass` statements are correctly rendered during code formatting.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/src/statement/stmt_match.rs",
            "description": "This file implements the formatting logic for Python `match` statements within the Ruff formatter. It handles the layout of the `match` keyword, its subject expression, and all associated `case` clauses.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_formatter/src/statement/stmt_return.rs",
            "description": "This file implements the formatting logic for Python `return` statements within the `ruff` formatter, handling the keyword and the optional returned expression.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_formatter/src/statement/stmt_assign.rs",
            "description": "This file is responsible for formatting Python assignment statements (`StmtAssign`), including handling multiple targets, complex expressions, parentheses, and comments. It defines strategies for breaking lines and parenthesizing expressions within assignments to adhere to formatting rules.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_formatter/src/statement/stmt_function_def.rs",
            "description": "This file implements the formatting logic for Python function (`def`) and asynchronous function (`async def`) definitions, including their decorators, headers, parameters, return annotations, and body, while also handling comment placement.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_formatter/src/statement/stmt_import_from.rs",
            "description": "This file implements the formatting logic for Python 'from ... import ...' statements within the Ruff formatter. It handles formatting of relative imports, specific imported names, and associated comments.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_formatter/src/statement/stmt_class_def.rs",
            "description": "This file is responsible for formatting Python `class` definition statements (`StmtClassDef`) within the Ruff formatter. It handles the layout of class decorators, the class header (name, type parameters, arguments), and the class body, including intricate logic for comment placement and empty line management.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_formatter/src/statement/stmt_type_alias.rs",
            "description": "This file defines the formatting logic for Python `type` alias statements (`StmtTypeAlias`) within the Ruff Python formatter. It handles the layout of the type name, optional type parameters, and the assigned value.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_formatter/src/statement/mod.rs",
            "description": "This file serves as the main dispatcher for formatting Python statements (Stmt types) in the Ruff formatter. It delegates the formatting of each specific statement variant to its corresponding module.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_formatter/src/statement/stmt_delete.rs",
            "description": "This file implements the formatting logic for Python `del` statements (`StmtDelete`) within the `ruff_python_formatter` crate, handling single, multiple, and empty target scenarios.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_formatter/src/statement/clause.rs",
            "description": "This file defines the `ClauseHeader` enum, which represents the header portion of various Python compound statements (e.g., `if`, `for`, `class`, `def`). It provides methods for querying properties and ranges of these clause headers for formatting purposes.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/src/statement/stmt_aug_assign.rs",
            "description": "This file implements the formatting logic for Python augmented assignment statements (e.g., `a += 1`) within the Ruff Python formatter. It defines how `StmtAugAssign` nodes should be rendered, handling various formatting considerations like parenthesization.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_formatter/src/statement/stmt_nonlocal.rs",
            "description": "This file implements the formatting logic for Python `nonlocal` statements within the Ruff Python formatter. It defines how `nonlocal` keywords and their associated names are rendered, including handling line breaks and comments.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_formatter/src/statement/stmt_for.rs",
            "description": "This file implements the formatting logic for Python `for` statements, including their `else` clauses and associated comments, within the `ruff_python_formatter` crate.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/src/statement/stmt_global.rs",
            "description": "This file implements the formatting logic for Python 'global' statements within the Ruff Python formatter. It handles the layout of the 'global' keyword and its associated variable names, managing line breaks and comments for optimal readability.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_formatter/src/statement/stmt_raise.rs",
            "description": "This file implements the formatting logic for Python `raise` statements within the `ruff` Python formatter. It handles the `raise` keyword, the exception being raised, and the optional `from` cause.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/src/statement/suite.rs",
            "description": "This file defines how to format a suite (block) of Python statements, handling different contexts like module-level, function bodies, class bodies, and general compound statements. It manages spacing, docstrings, and comments within these suites.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_formatter/src/statement/stmt_with.rs",
            "description": "This file implements the formatting logic for Python `with` statements, handling various layouts for context managers, version-specific syntax (e.g., Python 3.8 vs. 3.9+), and comment placement within the statement.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_formatter/src/statement/stmt_while.rs",
            "description": "This file implements the formatting logic for Python `while` statements, including their condition, body, and optional `else` clauses. It ensures proper indentation and handles associated comments.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/src/statement/stmt_try.rs",
            "description": "This file implements the formatting logic for Python `try` statements, including their `except`, `else`, and `finally` clauses, within the Ruff Python formatter.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_formatter/src/statement/stmt_ann_assign.rs",
            "description": "This file implements the formatting logic for Python annotated assignment statements (`StmtAnnAssign`), handling the arrangement of the target, annotation, and optional assigned value. It includes special considerations for parentheses, comments, and IPython notebook-specific trailing semicolons.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_formatter/src/type_param/type_param_param_spec.rs",
            "description": "This file defines the formatting logic for `ParamSpec` type parameters within Python code, specifically handling the `**P` syntax and its default value.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_formatter/src/type_param/type_param_type_var_tuple.rs",
            "description": "This file defines the formatting logic for `TypeParamTypeVarTuple` nodes within the `ruff` Python formatter. It dictates how type variable tuples, often represented with an asterisk (e.g., `*args`), are rendered in the formatted output.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_formatter/src/type_param/type_param_type_var.rs",
            "description": "Formats Python `TypeVar` type parameters, handling their name, optional bound, and optional default value.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_formatter/src/type_param/mod.rs",
            "description": "This file defines the main formatting logic for Python type parameters, dispatching to specific formatters for `TypeVar`, `TypeVarTuple`, and `ParamSpec` variants.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/src/type_param/type_params.rs",
            "description": "This file defines the formatting logic for Python type parameter lists, specifically handling their layout within square brackets and associated comments.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/ruff/expression/annotated_assign.py",
            "description": "Tests the Ruff formatter's handling of annotated assignments, including multi-line type hints. It serves as a fixture to ensure consistent formatting of type-hinted variables.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/ruff/expression/binary.py",
            "description": "This file serves as a test fixture for the Ruff Python formatter, specifically to test its handling of binary expressions. It includes various scenarios involving line wrapping, parentheses, and comments in binary operations to ensure correct formatting behavior.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_importer/src/insertion.rs",
            "description": "This file defines structures and methods for inserting new statements or code snippets into existing Python code. It provides utilities to determine the correct insertion location and formatting for various contexts, such as the start of a file, after a statement, or within import statements.",
            "spof": false
          }
        ],
        "contributors": [
          {
            "name": "Dylan",
            "percent": 34
          },
          {
            "name": "Micha Reiser",
            "percent": 28
          },
          {
            "name": "Brent Westbrook",
            "percent": 14
          }
        ]
      },
      "Formatter Configuration": {
        "files": [
          {
            "path": "crates/ruff_python_formatter/src/options.rs",
            "description": "Defines the `PyFormatOptions` struct which encapsulates all configuration settings for formatting Python files, including indentation, line width, quote style, and more. It also defines related enums for specific formatting choices.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_formatter/src/preview.rs",
            "description": "This file contains helper functions to check if specific, named preview formatting styles are enabled. These functions are designed to ease the promotion of preview styles to stable features by clearly identifying which checks are tied to which feature.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_formatter/src/db.rs",
            "description": "This file defines the `Db` trait for the `ruff_python_formatter` crate, extending the base Salsa database with methods specific to Python formatting, such as retrieving formatting options for a given file.",
            "spof": true
          },
          {
            "path": "crates/ruff_formatter/src/printer/printer_options/mod.rs",
            "description": "This file defines the `PrinterOptions` struct, which encapsulates various configuration settings for a code printer, such as indentation style, line width, and line ending preferences. It also includes related enums like `LineEnding` and `SourceMapGeneration`.",
            "spof": false
          }
        ],
        "contributors": [
          {
            "name": "Micha Reiser",
            "percent": 32
          },
          {
            "name": "Dylan",
            "percent": 23
          },
          {
            "name": "Brent Westbrook",
            "percent": 17
          }
        ]
      },
      "Comment, String, and Docstring Formatting": {
        "files": [
          {
            "path": "crates/ruff_python_formatter/src/comments/node_key.rs",
            "description": "This file defines `NodeRefEqualityKey`, a wrapper around `AnyNodeRef` used as a map key to store comments per AST node. It implements equality and hashing based on the memory address of the underlying node for efficient identity-based comparisons.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_formatter/src/comments/map.rs",
            "description": "This file implements an optimized multi-map for storing 'leading', 'dangling', and 'trailing' parts (like comments) associated with a key, designed to minimize allocations and improve cache locality when parts are inserted in a specific order.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/src/comments/format.rs",
            "description": "This file provides implementations for formatting leading, trailing, and dangling comments within Python source code. It defines how comments are placed and styled relative to AST nodes and other code elements.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_formatter/src/comments/placement.rs",
            "description": "This file is responsible for correctly placing and associating comments with abstract syntax tree (AST) nodes during Python code formatting, handling complex scenarios where default comment attachment might be incorrect.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_formatter/src/comments/mod.rs",
            "description": "This module defines types and logic for extracting, representing, and associating comments with nodes in a Python abstract syntax tree. It categorizes comments into leading, dangling, and trailing types to facilitate consistent and accurate formatting.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_formatter/src/comments/visitor.rs",
            "description": "This file defines a visitor that traverses a Python Abstract Syntax Tree (AST) to identify and extract all comments, decorating them with contextual information about their surrounding nodes for later formatting or analysis.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_formatter/src/other/bytes_literal.rs",
            "description": "This file defines the formatting logic for Python byte string literals (`BytesLiteral`) within the Ruff Python formatter. It uses a `StringNormalizer` to ensure consistent formatting of these literals.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_formatter/src/other/string_literal.rs",
            "description": "This file defines the formatting logic for Python string literals, distinguishing between regular strings and docstrings. It applies specific quote style rules, especially for docstrings, during the formatting process.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/src/string/docstring.rs",
            "description": "Formats Python docstrings, including trimming whitespace, adjusting indentation, and handling code examples within docstrings.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_formatter/src/string/implicit.rs",
            "description": "This file is responsible for formatting implicitly concatenated Python string literals. It determines whether to join multiple string parts into a single string or to keep them as separate parts, formatting each accordingly.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/src/string/normalize.rs",
            "description": "This file contains the `StringNormalizer` responsible for determining and applying the preferred quote style for string literals in Python code, handling complexities like f-strings, docstrings, and PEP rules.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/src/string/mod.rs",
            "description": "This module provides utilities for formatting Python string literals, including handling prefixes, quote styles, and determining if a string spans multiple lines. It integrates with Ruff's AST and formatting context to ensure correct and consistent string representation.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/ruff/expression/string.py",
            "description": "This file contains a collection of Python string literals, including various quote styles, raw/unicode strings, multiline strings, and string continuation examples. It serves as a test fixture for a Python formatter's handling of string expressions.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/ruff/statement/module_comment.py",
            "description": "Tests how the Ruff Python formatter handles module-level comments, specifically a comment on a line by itself at the start of the file.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/black/cases/comments9.py",
            "description": "This file contains a series of test cases specifically designed to evaluate how a code formatter (like Black) handles comments, focusing on their placement, spacing, and interaction with statements, functions, classes, and decorators.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_formatter/resources/test/fixtures/black/cases/comments6.py",
            "description": "This file serves as a Black-style test fixture for the Ruff Python formatter, specifically to evaluate its handling of various type comments (e.g., `# type: int`, `# type: (...) -> None`) and `type: ignore` comments in different code constructs.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/isort/comments.py",
            "description": "This file serves as a test fixture for an import sorting tool, specifically demonstrating how comments are handled when sorting various types of import statements, including single-line, multi-line, and inline comments.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_literal/src/escape.rs",
            "description": "This file defines traits and structs for escaping and formatting Python string and byte literals, handling character escapes, quote selection, and writing the formatted output.",
            "spof": false
          }
        ],
        "contributors": [
          {
            "name": "Micha Reiser",
            "percent": 55
          },
          {
            "name": "Dylan",
            "percent": 15
          },
          {
            "name": "Brent Westbrook",
            "percent": 5
          }
        ]
      },
      "Formatting IR & Printer": {
        "files": [
          {
            "path": "crates/ruff_formatter/src/diagnostics.rs",
            "description": "This file defines various error types (`FormatError`, `InvalidDocumentError`, `PrintError`) encountered during code formatting within the `ruff_formatter` crate, covering syntax issues, document structure validation, and internal layout problems.",
            "spof": true
          },
          {
            "path": "crates/ruff_formatter/src/macros.rs",
            "description": "This file defines Rust macros (`format_args!`, `write!`, `dbg_write!`, `format!`, `best_fitting!`) for creating, manipulating, and writing formatted code elements to a buffer. It provides tools for structured code formatting, including debugging utilities and intelligent layout selection based on available line width.",
            "spof": true
          },
          {
            "path": "crates/ruff_formatter/src/format_extensions.rs",
            "description": "This file provides utilities for memoizing the output of formatting operations. It introduces a `MemoizeFormat` trait and `Memoized` struct to cache formatted results, preventing redundant and potentially expensive re-formatting of the same object.",
            "spof": false
          },
          {
            "path": "crates/ruff_formatter/src/builders.rs",
            "description": "This file defines primitive formatting elements and builder functions for the `ruff_formatter` crate, such as various line breaks, literal tokens, source map markers, and text elements, which are used to construct the formatted output.",
            "spof": false
          },
          {
            "path": "crates/ruff_formatter/src/formatter.rs",
            "description": "This file defines the `Formatter` struct, which manages the buffer, context, and state for formatting a Concrete Syntax Tree (CST) and provides methods to arrange and combine formatted elements based on user preferences.",
            "spof": true
          },
          {
            "path": "crates/ruff_formatter/src/source_code.rs",
            "description": "This file defines `SourceCode` and `SourceCodeSlice` structs for managing and efficiently accessing parts of the source code text within the Ruff formatter. It allows slicing the source code using `TextRange` and provides debug-time text storage for `SourceCodeSlice`.",
            "spof": true
          },
          {
            "path": "crates/ruff_formatter/src/prelude.rs",
            "description": "This file serves as a prelude for the `ruff_formatter` crate, re-exporting commonly used modules, structs, and traits for convenience. It simplifies imports for other modules within the crate.",
            "spof": true
          },
          {
            "path": "crates/ruff_formatter/src/arguments.rs",
            "description": "This file defines structures (`Argument` and `Arguments`) used to represent individual and sequences of formattable elements. It provides the foundational types for the `format_args!` macro, enabling the unified formatting of diverse components within the Ruff formatter.",
            "spof": false
          },
          {
            "path": "crates/ruff_formatter/src/buffer.rs",
            "description": "This file defines the `Buffer` trait, which provides an interface for writing and managing `FormatElement`s within the Ruff formatter, along with concrete implementations like `VecBuffer` and mechanisms for snapshotting and restoring buffer states.",
            "spof": true
          },
          {
            "path": "crates/ruff_formatter/src/lib.rs",
            "description": "This file provides the core infrastructure for code formatting, defining the intermediate representation for formatted code, essential traits for formatting logic, and configurable options like indent style and line width.",
            "spof": false
          },
          {
            "path": "crates/ruff_formatter/src/group_id.rs",
            "description": "This file defines structures for unique group identifiers (`GroupId`) that vary between debug and release builds, and provides a builder (`UniqueGroupIdBuilder`) to generate these unique IDs.",
            "spof": true
          },
          {
            "path": "crates/ruff_formatter/src/format_element.rs",
            "description": "Defines the core `FormatElement` enum, which serves as a language-agnostic Intermediate Representation (IR) for formatting source code within the `ruff_formatter` crate, along with related types and utilities.",
            "spof": false
          },
          {
            "path": "crates/ruff_formatter/src/printer/line_suffixes.rs",
            "description": "This file defines structures for storing and managing 'line suffixes' and their associated printing arguments, used by a formatter to handle elements that need to be appended at the end of lines.",
            "spof": false
          },
          {
            "path": "crates/ruff_formatter/src/printer/mod.rs",
            "description": "This file defines the `Printer` struct, which is responsible for taking a sequence of format elements and rendering them into a final string, handling indentation, line breaks, grouping, and other layout concerns.",
            "spof": false
          },
          {
            "path": "crates/ruff_formatter/src/printer/call_stack.rs",
            "description": "This file defines the call stack mechanisms used by the formatter to manage and track printing state, such as indentation and print mode, associated with different formatting elements during the document generation process.",
            "spof": false
          },
          {
            "path": "crates/ruff_formatter/src/printer/stack.rs",
            "description": "This file defines a `Stack` trait for basic LIFO operations and implements it for `Vec` and `StackedStack`. The `StackedStack` provides a mechanism to temporarily manipulate a stack's state without altering the original underlying data source.",
            "spof": false
          },
          {
            "path": "crates/ruff_formatter/src/printer/queue.rs",
            "description": "This file defines the `Queue` trait and its concrete implementations (`PrintQueue`, `FitsQueue`) for managing `FormatElement`s in a code formatter. It provides mechanisms for processing formatting elements, including specialized queues for printing and for measuring if content fits on a line.",
            "spof": true
          },
          {
            "path": "crates/ruff_formatter/src/format_element/tag.rs",
            "description": "This file defines the `Tag` enum and associated data structures used to mark start/end points for applying special formatting (like indentation, grouping, and conditional rendering) within the Ruff formatter.",
            "spof": false
          },
          {
            "path": "crates/ruff_formatter/src/format_element/document.rs",
            "description": "This file defines the `Document` struct, which represents a collection of format elements. It includes logic for analyzing formatting constraints, such as group expansion propagation, and provides methods to display the document by formatting its elements.",
            "spof": true
          },
          {
            "path": "crates/ruff_formatter/shared_traits.rs",
            "description": "This file defines traits (`AsFormat`, `IntoFormat`) and an iterator extension (`FormattedIterExt`) for converting objects into their format-ready representations, facilitating their use with the `ruff_formatter` library.",
            "spof": true
          }
        ],
        "contributors": [
          {
            "name": "Micha Reiser",
            "percent": 63
          },
          {
            "name": "Charlie Marsh",
            "percent": 29
          },
          {
            "name": "Victorien",
            "percent": 2
          }
        ]
      }
    },
    "stats": {
      "totalFiles": 521,
      "spofCount": 284
    },
    "busFactor": 2,
    "authorCount": 22
  },
  "Code Linter": {
    "description": "Analyzes Python code to find and fix a wide range of errors, bugs, and stylistic issues at extremely high speed. It helps enforce code quality and maintainability across projects.",
    "functions": {
      "Configuration and Rule Management": {
        "files": [
          {
            "path": "docs/linter.md",
            "description": "This document describes the Ruff linter, its usage, how to select and ignore linting rules, and how to apply and configure automatic fixes for detected issues.",
            "spof": true
          },
          {
            "path": "docs/preview.md",
            "description": "This document explains Ruff's opt-in preview mode, detailing how to enable it for linting and formatting, how to select and manage preview rules, and the behavior of deprecated rules within this mode.",
            "spof": false
          },
          {
            "path": "docs/configuration.md",
            "description": "This document details how to configure the Ruff linter and formatter, including supported configuration file types, default settings, specific examples, and hierarchical configuration discovery rules.",
            "spof": false
          },
          {
            "path": "docs/tutorial.md",
            "description": "This file is a tutorial that guides users through integrating and configuring the Ruff linter and formatter into a Python project. It covers setup, basic usage, configuration options, rule selection, and error suppression.",
            "spof": false
          },
          {
            "path": "crates/ruff/src/commands/show_settings.rs",
            "description": "This file defines a function `show_settings` responsible for resolving and displaying the effective configuration settings for a given Python file, including the path to the configuration file itself.",
            "spof": true
          },
          {
            "path": "crates/ruff/tests/cli/lint.rs",
            "description": "This file contains command-line interface (CLI) tests for the `ruff` linter, specifically verifying how various linting-related configuration options in `ruff.toml` are interpreted and applied, especially regarding the `[lint]` section and its precedence.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/src/lint.rs",
            "description": "This file defines data structures and mechanisms for describing, registering, and managing lint rules within the `ty_python_semantic` crate. It includes metadata for each lint (like severity, status, and documentation) and a registry for their organization and lookup.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/package.rs",
            "description": "Defines the `PackageRoot` enum, which represents different types of Python package root directories (normal or nested) within a repository.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/src/pyproject_toml.rs",
            "description": "This file provides functionality to lint `pyproject.toml` files, specifically checking for parsing errors and generating diagnostics if the file content is invalid.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/src/upstream_categories.rs",
            "description": "This file defines structures and methods to map internal linting rules and linters to their respective 'upstream' categories and prefixes (e.g., Pycodestyle's 'E' for Error or Pylint's 'C' for Convention).",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/src/preview.rs",
            "description": "This file contains helper functions to individually check if specific preview features or behaviors are enabled within the linter settings. This approach aids in tracking and promoting individual preview features to stable status.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/registry.rs",
            "description": "This file defines the `Linter` enum, which enumerates all supported linting tools and their prefixes. It also provides utility functions for parsing rule codes and determining the source of a lint diagnostic within the Ruff linter.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/codes.rs",
            "description": "This module defines and maps linting rules and their categories (e.g., pycodestyle, pyflakes) to specific rule implementations within the Ruff linter, enabling rule selection and categorization.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/src/rule_selector.rs",
            "description": "This file defines the `RuleSelector` enum, which represents various ways to select linting rules in Ruff, such as selecting all rules, an entire linter, a rule code prefix, or a specific rule. It provides parsing, serialization, and iteration functionality for these selectors, handling redirects and rule group filters like preview and deprecated rules.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rule_redirects.rs",
            "description": "This file manages rule code redirects in the Ruff linter, mapping deprecated or renamed rule identifiers to their current equivalents. It provides functions to retrieve the target for a given rule code.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/mod.rs",
            "description": "This file serves as the module index for all linter rules within the `ruff_linter` crate, declaring and making public each individual rule set or linter implementation.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_boolean_trap/settings.rs",
            "description": "This file defines the settings structure for the `flake8-boolean-trap` linter plugin, including configurable options like `extend_allowed_calls`, and provides display formatting for these settings.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_bugbear/settings.rs",
            "description": "This file defines the configuration settings for the `flake8-bugbear` linter plugin within the Ruff project, including options like `extend_immutable_calls`.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_gettext/settings.rs",
            "description": "Defines settings for the `flake8_gettext` rule, including a list of default function names to be recognized as gettext-related functions.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_builtins/settings.rs",
            "description": "This file defines the settings structure and its display implementation for the `flake8-builtins` linter rule within the Ruff linter. It includes options like an ignorelist, allowed modules, and strict checking.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_bandit/settings.rs",
            "description": "This file defines the configuration settings for the `flake8-bandit` linting rules within the Ruff linter. It includes a `Settings` struct, its default values, and display formatting.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_copyright/settings.rs",
            "description": "This file defines the configuration settings, their default values, and display logic for the `flake8-copyright` linting rule within the Ruff linter.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_quotes/settings.rs",
            "description": "This file defines the settings and quote style enum (`Quote`) for the `flake8-quotes` plugin within the Ruff linter. It includes serialization, deserialization, and display implementations for these settings.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_comprehensions/settings.rs",
            "description": "This file defines the configuration settings for the `flake8-comprehensions` linting plugin within the Ruff linter. It includes settings such as whether to allow dictionary calls with keyword arguments.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_errmsg/settings.rs",
            "description": "This file defines the configuration settings for the `flake8-errmsg` plugin within the Ruff linter, including parameters like `max_string_length`.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_self/settings.rs",
            "description": "Defines the `Settings` struct for the `flake8-self` plugin, including default names to ignore and implementations for displaying and initializing these settings.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_implicit_str_concat/settings.rs",
            "description": "This file defines the configuration settings for the `flake8-implicit-str-concat` rule within the Ruff linter, including an option to allow multiline implicit string concatenations.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_unused_arguments/settings.rs",
            "description": "Defines the configuration settings, such as `ignore_variadic_names`, for the `flake8-unused-arguments` linter rule in Ruff, including its display and caching behavior.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/src/rules/mccabe/settings.rs",
            "description": "Defines the settings for the `mccabe` plugin, including the `max_complexity` threshold and its default value. It also implements display and default traits for these settings.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_tidy_imports/settings.rs",
            "description": "This file defines the data structures and settings for the `flake8_tidy_imports` rule within the Ruff linter, including configurations for banning relative imports and specific APIs.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pycodestyle/settings.rs",
            "description": "Defines the settings structure for the `pycodestyle` plugin, including parameters like maximum line length and whether to ignore overlong task comments. It also provides a display implementation for these settings.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/src/rules/pydoclint/settings.rs",
            "description": "Defines the configuration settings for the `pydoclint` rule within the Ruff linter, including options like ignoring one-line docstrings.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/src/rules/pyflakes/settings.rs",
            "description": "This file defines the configuration settings for the `Pyflakes` linter rule within the `ruff_linter` crate. It includes parameters for controlling `Pyflakes`' behavior, such as extending generics and specifying allowed unused imports.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pylint/settings.rs",
            "description": "Defines the configurable settings and related utility types for the `pylint` plugin within the ruff linter. It includes parameters for various code complexity and naming conventions.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/ruff/settings.rs",
            "description": "This file defines the `Settings` struct, which holds configuration options for the `ruff` plugin within the linter. It includes settings like parenthesizing tuples in subscripts and strict empty `__init__.py` modules.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/ruff/rules/test_rules.rs",
            "description": "This file defines a collection of fake rules (e.g., stable, preview, deprecated, removed) used internally for testing the Ruff linter's behavior and its rule management mechanisms.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pydocstyle/settings.rs",
            "description": "This file defines the settings and configuration options for the `pydocstyle` linting rules within the `ruff_linter`, including different docstring conventions (Google, NumPy, PEP257) and associated rule ignorances.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pyupgrade/settings.rs",
            "description": "This file defines the configuration settings for the `pyupgrade` linter plugin, including options like `keep_runtime_typing`.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/src/settings/flags.rs",
            "description": "This file defines enumerations for various operational flags or settings, such as fix mode, NOQA behavior, and caching, used within the Ruff linter's settings.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/settings/mod.rs",
            "description": "This file defines the core settings for the Ruff linter, including rule configurations, file exclusion patterns, target Python versions, and various other operational parameters, optimized for internal usage.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/settings/rule_table.rs",
            "description": "This file defines the `RuleTable` data structure, which manages which linting rules are enabled and whether their violations should be automatically fixed within the Ruff linter.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/settings/fix_safety_table.rs",
            "description": "This file defines the `FixSafetyTable` struct, which manages and resolves the effective fix safety (safe or unsafe) for linter rules, allowing overrides based on user configuration.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/src/settings/types.rs",
            "description": "This file defines various data structures (enums and structs) used for configuring the Ruff linter's settings, such as Python version, preview mode, unsafe fix behavior, and file-based glob patterns for inclusion/exclusion rules.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/registry/rule_set.rs",
            "description": "This file defines the `RuleSet` data structure, which is an optimized bitset for efficiently storing, manipulating, and querying collections of `Rule` enums within the ruff linter.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/project/README.md",
            "description": "This README documents an example multi-package Python project designed to test Ruff's setting resolution, configuration inheritance, and exclusion behaviors. It provides console command examples demonstrating expected linting outcomes under various conditions.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/project/examples/excluded/script.py",
            "description": "This is a simple Python script used as a test case for Ruff's linter, specifically demonstrating a file that should be excluded from analysis.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/package/resources/ignored.py",
            "description": "This file is a test resource designed to be ignored by the linter, specifically to verify that an 'unused import error' is not triggered when ignored.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/filesystem/excluded_file.py",
            "description": "This file serves as a test fixture for the Ruff linter, specifically to test its functionality regarding excluded files. It contains basic Python string operations, including f-strings and string concatenation.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/filesystem/with_excluded_file/other_excluded_file.py",
            "description": "This file serves as a test fixture for the Ruff linter, specifically to verify filesystem exclusion rules. It contains simple Python assignments, including f-strings, and is designed to be ignored during linter scans.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/filesystem/with_excluded_directory/migrations/migration.py",
            "description": "This file serves as a test fixture for the ruff linter, demonstrating simple Python string assignments within a directory structure intended to test directory exclusion rules.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/ruff/pyproject_toml/pep639",
            "description": "This directory contains test fixtures, specifically `pyproject.toml` files, used for testing the Ruff linter's handling and parsing of configurations related to PEP 639 within the linter's test suite. It serves as a collection of example `pyproject.toml` setups relevant to PEP 639 for verification purposes.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/ruff/pyproject_toml/various_invalid",
            "description": "This directory contains test fixtures for the `ruff_linter` crate. It specifically stores various invalid `pyproject.toml` configurations, used to verify the linter's error handling for malformed project settings.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/ruff/pyproject_toml/invalid_author",
            "description": "This directory serves as a test fixture for `ruff_linter`, specifically designed to test the linter's behavior and validation rules when encountering an invalid author configuration within a `pyproject.toml` file. It likely represents a scenario where the author field is malformed or violates expected schema, ensuring `ruff` correctly identifies and reports such issues.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/ruff/pyproject_toml/maturin",
            "description": "This directory serves as a test fixture for the `ruff_linter` crate, specifically providing a `pyproject.toml` configuration scenario related to `maturin`. It likely contains content for testing how Ruff processes or interacts with project metadata when `maturin` is involved.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/ruff/pyproject_toml/bleach",
            "description": "This directory serves as a fixture for testing `ruff_linter`'s handling of `pyproject.toml` configurations. It specifically houses test data relevant to a scenario involving a project named 'bleach'.",
            "spof": false
          },
          {
            "path": "crates/ruff_macros/src/violation_metadata.rs",
            "description": "This file contains a procedural macro that generates `ViolationMetadata` trait implementations for Ruff linter rules. It extracts documentation and rule status (stable, preview, deprecated, removed) from attributes to provide details like explanation and rule group.",
            "spof": true
          },
          {
            "path": "crates/ruff_macros/src/config.rs",
            "description": "This Rust file implements a procedural macro for the `ruff` linter, which derives metadata about configuration options from struct fields annotated with `#[option]` or `#[option_group]`.",
            "spof": true
          },
          {
            "path": "crates/ruff_macros/src/rule_namespace.rs",
            "description": "This file implements a procedural macro that generates `RuleNamespace` trait implementations for enums, associating prefixes, names, and URLs with each enum variant based on custom attributes.",
            "spof": true
          },
          {
            "path": "crates/ruff_macros/src/combine_options.rs",
            "description": "This file implements a procedural macro that derives the `CombinePluginOptions` trait for structs, allowing their fields (specifically `Option` types) to be combined. It generates code to merge two instances of a struct into a single one.",
            "spof": false
          },
          {
            "path": "crates/ruff_macros/src/rule_code_prefix.rs",
            "description": "This Rust file implements a procedural macro helper that generates an enum representing rule code prefixes. It provides implementations for `FromStr`, `From<&#prefix_ident>` to `&'static str`, and `AsRef<str>` for the generated enum, facilitating the handling and lookup of rule prefixes.",
            "spof": false
          },
          {
            "path": "crates/ruff_macros/src/map_codes.rs",
            "description": "This file contains procedural macro logic that parses linter rule definitions and dynamically generates Rust code. It creates enums and helper implementations for managing, mapping, and iterating over linting rules, their codes, and associated linters.",
            "spof": false
          },
          {
            "path": "crates/ruff_workspace/src/pyproject.rs",
            "description": "This file provides utilities for locating, parsing, and extracting configuration from `pyproject.toml` and `ruff.toml` files, specifically for Ruff's settings and Python version requirements.",
            "spof": false
          }
        ],
        "contributors": [
          {
            "name": "Renkai Ge",
            "percent": 39
          },
          {
            "name": "Brent Westbrook",
            "percent": 20
          },
          {
            "name": "Micha Reiser",
            "percent": 19
          }
        ]
      },
      "CLI and Orchestration": {
        "files": [
          {
            "path": "crates/ruff/src/main.rs",
            "description": "This file serves as the main entry point for the `ruff` command-line tool, handling argument parsing, global allocator setup, execution of the core `ruff` logic, and error reporting.",
            "spof": false
          },
          {
            "path": "crates/ruff/src/commands/version.rs",
            "description": "This file provides a function to display the application's version information. It supports outputting the version in both text and JSON formats.",
            "spof": true
          },
          {
            "path": "crates/ruff/src/commands/check_stdin.rs",
            "description": "This file contains the `check_stdin` function, which lints a single file's content read from standard input, applying specified configurations and exclusion rules.",
            "spof": false
          },
          {
            "path": "crates/ruff/src/commands/show_files.rs",
            "description": "This file defines a command to display the list of Python files that Ruff would process, based on the provided paths and current configuration settings.",
            "spof": false
          },
          {
            "path": "crates/ruff/src/commands/mod.rs",
            "description": "This `mod.rs` file serves as the main module for all top-level CLI commands in Ruff, aggregating various functionalities like `check`, `format`, `clean`, and `version` into a single interface.",
            "spof": false
          },
          {
            "path": "crates/ruff/src/commands/linter.rs",
            "description": "This file defines the `linter` command, which lists and describes the available linters in the Ruff linter, outputting the information in either plain text or JSON format.",
            "spof": true
          },
          {
            "path": "crates/ruff/src/commands/rule.rs",
            "description": "This file implements commands to explain individual or all linting rules to the user, providing detailed information in either text or JSON format. It extracts metadata such as rule name, code, linter, fix availability, and explanation for each rule.",
            "spof": false
          },
          {
            "path": "crates/ruff/src/commands/check.rs",
            "description": "This file orchestrates the linting process for a collection of files in the Ruff linter. It handles file discovery, configuration resolution, parallel execution of linting tasks, and aggregates diagnostics.",
            "spof": false
          },
          {
            "path": "crates/ruff/src/commands/snapshots",
            "description": "This directory is intended to store snapshot test data for validating the behavior and output of the `ruff` commands module. It ensures the consistency and correctness of command-line operations through comparison against stored reference snapshots.",
            "spof": false
          },
          {
            "path": "crates/ruff/tests/integration_test.rs",
            "description": "This file contains integration tests for the 'ruff' linter, verifying its command-line interface behavior across various scenarios, including standard input processing, file checking, output formats, and code auto-fixing.",
            "spof": false
          },
          {
            "path": "crates/ruff/tests/resolve_files.rs",
            "description": "This file contains integration tests for Ruff's file resolution logic, verifying how the `ruff check` command identifies and includes/excludes files based on project configurations and direct path arguments. It tests scenarios involving default includes, explicit paths, and subdirectory processing within a project.",
            "spof": false
          },
          {
            "path": "crates/ruff/tests/show_settings.rs",
            "description": "This file contains integration tests for the `ruff` linter, specifically verifying the output of the `--show-settings` command-line option under various project configurations, including default and nested settings.",
            "spof": true
          },
          {
            "path": "crates/ruff/resources/test/fixtures/include-test/subdirectory",
            "description": "This directory contains test fixture files (`c.py`, `d.py`) within a nested structure. It likely serves to test how the `ruff` linter handles file discovery or include paths when processing code in subdirectories during its test suite.",
            "spof": false
          },
          {
            "path": "crates/ruff/resources/test/fixtures/include-test/nested-project",
            "description": "This directory serves as a test fixture within the Ruff linter's test suite. It represents a 'nested-project' scenario specifically designed to test `include-test` functionalities. The `e.py` file likely contains code used to verify Ruff's behavior in such a project structure.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/packaging.rs",
            "description": "This file provides utilities to detect Python package roots and identify Python package directories within a file system, accounting for both regular and namespace packages.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/src/lib.rs",
            "description": "This file is the main library entry point for the Ruff Python linter, defining its core functionalities and public API. It orchestrates the linting process, including rule application, diagnostics, and fixes for Python code.",
            "spof": false
          },
          {
            "path": "crates/ruff_workspace/src/resolver.rs",
            "description": "This file is responsible for discovering Python files and their associated `ruff` settings from the filesystem. It resolves the appropriate settings for a given file path based on a configured `pyproject.toml` discovery strategy and identifies Python package roots.",
            "spof": false
          }
        ],
        "contributors": [
          {
            "name": "Micha Reiser",
            "percent": 25
          },
          {
            "name": "Brent Westbrook",
            "percent": 19
          },
          {
            "name": "Jack O'Connor",
            "percent": 14
          }
        ]
      },
      "Diagnostic, Annotation, and Fixing Engine": {
        "files": [
          {
            "path": "crates/ruff/src/printer.rs",
            "description": "This file defines the `Printer` struct, which is responsible for formatting and emitting diagnostic messages, fix summaries, and statistics from the `ruff` linter to various output streams based on specified output format and log level.",
            "spof": false
          },
          {
            "path": "crates/ruff/src/diagnostics.rs",
            "description": "This file defines structures for collecting and managing diagnostics and their associated fixes within the Ruff linter. It includes functionality for linting various file types, handling source errors, and applying or reporting code modifications.",
            "spof": false
          },
          {
            "path": "crates/ruff/src/commands/add_noqa.rs",
            "description": "This file provides functionality to add `noqa` directives to Python files, suppressing linting errors. It identifies relevant Python files, resolves configurations, and applies the `noqa` comments.",
            "spof": false
          },
          {
            "path": "crates/ruff/src/snapshots",
            "description": "This directory is designated to store snapshot test files for the `ruff` crate. Snapshot tests capture expected outputs or structures, allowing for efficient regression testing by comparing current results against these stored references. Although currently empty, it serves as the intended location for these reference files.",
            "spof": false
          },
          {
            "path": "crates/ruff/tests/snapshots",
            "description": "This directory is intended to store snapshot test fixtures for the `ruff` crate. These snapshots capture expected outputs or states, which are then compared against actual test results to detect regressions or unintended changes. It serves as a reference point for validating the crate's behavior during development and continuous integration.",
            "spof": false
          },
          {
            "path": "crates/ruff_annotate_snippets/README.md",
            "description": "This file documents why the `annotate-snippets` crate was forked: to customize diagnostic message formatting, specifically by adding a `Level::None` variant and maintaining control over future output format changes.",
            "spof": true
          },
          {
            "path": "crates/ruff_annotate_snippets/examples/format.rs",
            "description": "This file is an example demonstrating the usage of the `ruff_annotate_snippets` crate to format and render code snippets with error and warning annotations.",
            "spof": true
          },
          {
            "path": "crates/ruff_annotate_snippets/examples/footer.rs",
            "description": "This file is an example demonstrating the usage of the `ruff_annotate_snippets` library, specifically showcasing how to create and render a structured error message with a footer.",
            "spof": true
          },
          {
            "path": "crates/ruff_annotate_snippets/tests/examples.rs",
            "description": "This file contains integration tests for the `ruff_annotate_snippets` crate, verifying that example command-line outputs (rendered as SVG) match predefined golden files. It uses `snapbox` to compile and execute examples, comparing their stdout against expected SVG content.",
            "spof": true
          },
          {
            "path": "crates/ruff_annotate_snippets/src/renderer/margin.rs",
            "description": "This file defines the `Margin` struct and its methods, which are responsible for calculating the optimal display range (left and right columns) of a code line. It intelligently trims long lines, excessive leading whitespace, and centers relevant spans and labels to fit within a given terminal width for error/warning annotations.",
            "spof": true
          },
          {
            "path": "crates/ruff_annotate_snippets/src/renderer/stylesheet.rs",
            "description": "Defines the `Stylesheet` struct which holds various `anstyle::Style` configurations used for rendering different elements (like error, warning, line numbers) in annotated code snippets or diagnostic output.",
            "spof": true
          },
          {
            "path": "crates/ruff_annotate_snippets/src/renderer/display_list.rs",
            "description": "This file defines the `DisplayList` data structure, which serves as the central output model for rendering structured code snippets with line numbers, annotations, and styling. It handles the layout and formatting logic for displaying diagnostic messages and code context.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/diagnostics/unknown_argument.md",
            "description": "This file describes and demonstrates the 'unknown-argument' diagnostics in Ruff, showing how the linter identifies and reports calls with parameters not defined in the function or method signature. It includes examples for both simple functions and methods, as well as scenarios involving conditional function assignments.",
            "spof": true
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/diagnostics/semantic_syntax_errors.md",
            "description": "This file documents various semantic syntax errors in Python, providing code examples and expected diagnostic messages. It serves as a reference or test suite for a linter or static analysis tool to ensure correct identification of invalid Python syntax across different Python versions.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/src/suppression/unused.rs",
            "description": "This file contains logic to identify and report unused suppression comments (e.g., `# type: ignore` or `# ruff: noqa`) within a source file. It also provides fixes to remove these unused suppressions.",
            "spof": true
          },
          {
            "path": "crates/ruff_db/src/diagnostic/render.rs",
            "description": "This file is responsible for formatting and rendering diagnostic messages in various output formats, such as concise, full, Azure, GitHub, Pylint, and JSON, by implementing `std::fmt::Display` for individual and collections of diagnostics.",
            "spof": false
          },
          {
            "path": "crates/ruff_db/src/diagnostic/render/pylint.rs",
            "description": "This file defines a `PylintRenderer` responsible for formatting diagnostic messages into the Pylint-compatible output format. It takes a list of diagnostics and renders them as strings with path, line number, code, and message.",
            "spof": true
          },
          {
            "path": "crates/ruff_db/src/diagnostic/render/json.rs",
            "description": "This file implements the serialization of Ruff diagnostics into a JSON format, converting diagnostic information, fixes, and code edits into structured JSON objects for output.",
            "spof": true
          },
          {
            "path": "crates/ruff_db/src/diagnostic/render/concise.rs",
            "description": "This file defines the `ConciseRenderer` struct, responsible for formatting and rendering diagnostics in a compact, human-readable format, including file paths, line/column numbers, severity, and messages.",
            "spof": true
          },
          {
            "path": "crates/ruff_db/src/diagnostic/render/json_lines.rs",
            "description": "This file defines a `JsonLinesRenderer` struct responsible for rendering a list of diagnostics as a series of newline-separated JSON objects. It converts each diagnostic into a JSON representation and writes it to a formatter.",
            "spof": true
          },
          {
            "path": "crates/ruff_db/src/diagnostic/render/junit.rs",
            "description": "This file implements a `JunitRenderer` responsible for converting Ruff diagnostics into the JUnit XML report format. It groups diagnostics by filename and maps them to test cases, indicating failures with relevant location and message details.",
            "spof": true
          },
          {
            "path": "crates/ruff_db/src/diagnostic/render/rdjson.rs",
            "description": "This file implements a renderer for Ruff's diagnostics, converting them into the RDJSON (ReviewDog JSON) format. It defines the serialization logic and data structures required to represent diagnostics, locations, codes, and suggested fixes according to the RDJSON specification.",
            "spof": true
          },
          {
            "path": "crates/ruff_db/src/diagnostic/render/snapshots",
            "description": "This directory stores snapshot files used for testing the rendering of diagnostics within the `ruff_db` crate. These snapshots capture expected output formats, ensuring consistency and correctness of diagnostic presentation.",
            "spof": false
          },
          {
            "path": "crates/ruff_diagnostics/src/edit.rs",
            "description": "This file defines the `Edit` struct, which represents a single text modification (insertion, deletion, or replacement) to be applied to a source file, along with methods for creating and inspecting these edits. It also defines an enum `EditOperationKind` to categorize these text operations.",
            "spof": false
          },
          {
            "path": "crates/ruff_diagnostics/src/lib.rs",
            "description": "This file serves as the public interface for the `ruff_diagnostics` crate, re-exporting core modules related to code edits, fixes, and source map utilities.",
            "spof": true
          },
          {
            "path": "crates/ruff_diagnostics/src/source_map.rs",
            "description": "This file defines data structures for creating a lightweight sourcemap, specifically tracking how text positions in original source code map to positions in transformed code after edits are applied.",
            "spof": true
          },
          {
            "path": "crates/ruff_diagnostics/src/fix.rs",
            "description": "This file defines the `Fix` structure, which encapsulates a collection of code edits along with their applicability (safety level) and isolation requirements for diagnostic tools. It provides methods to create and manage these fix objects.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/noqa.rs",
            "description": "This file handles the parsing, interpretation, and application of `noqa` directives (like `# noqa` or `# ruff: noqa`) in Python source code. It determines which linter diagnostics should be suppressed, both for individual lines and entire files, and can generate edits to manage these directives.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/logging.rs",
            "description": "This file defines logging utilities for the `ruff_linter` crate, including macros for unique warnings, an enum for log verbosity levels, and a function to set up structured logging. It also provides a wrapper for `ParseError` to display syntax errors with contextual source location details.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/renamer.rs",
            "description": "This file defines the `Renamer` struct, which provides functionality to rename symbols within a given scope in Python code. It handles various complexities like global/nonlocal declarations, rebinding, references, and specific argument updates, ensuring all occurrences of a symbol are consistently updated.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/violation.rs",
            "description": "This file defines traits and types for representing linting violations within the Ruff linter, including metadata, fix availability, and conversion to diagnostic messages. It provides a structured interface for defining various types of code violations and their associated properties.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/src/suppression.rs",
            "description": "This file defines the data structures and logic for parsing, validating, and applying code suppression comments in the ruff linter, including reporting issues like unused or invalid suppressions.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/src/directives.rs",
            "description": "This file is responsible for extracting and interpreting special comments (directives) from Python source code, such as `# noqa` for linting exclusions, `# isort` for import sorting, and general `# TODO` comments.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/linter.rs",
            "description": "This file contains the core logic for the Ruff linter, coordinating various checks (e.g., AST, tokens, imports) on a source file to generate diagnostics. It also includes functionality for applying fixes and managing 'noqa' directives.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/text_helpers.rs",
            "description": "This file defines utilities to make non-printing ASCII control characters visible in strings by replacing them with symbolic Unicode representations. It provides a `ShowNonprinting` trait and macro for this purpose.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/src/checkers/noqa.rs",
            "description": "This file handles the enforcement and validation of `noqa` directives within source code, suppressing linter diagnostics as specified and identifying unused or invalid `noqa` entries.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_boolean_trap/snapshots",
            "description": "This directory stores snapshot test files for the `flake8_boolean_trap` rule within the `ruff_linter` crate. These snapshots capture the expected output or diagnostics generated by the rule, allowing for robust regression testing. They ensure that changes to the rule's implementation do not inadvertently alter its behavior.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_errmsg/snapshots",
            "description": "This directory stores test snapshots for the `flake8_errmsg` rule within the `ruff_linter` crate. These snapshots are used to verify the expected output or behavior of the linter when applying this specific rule during testing.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_self/snapshots",
            "description": "This directory is intended to store snapshot test files specifically for the `flake8_self` rules within the `ruff_linter` crate. Snapshot tests capture expected output to verify rule behavior and prevent regressions during development. Although currently empty, its purpose is to house these diagnostic or AST snapshots.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_no_pep420/snapshots",
            "description": "This directory stores test snapshots specifically for the `flake8_no_pep420` rule within the `ruff_linter` crate. These snapshots are used to ensure the rule consistently produces expected diagnostic outputs during testing. It helps validate the linter's behavior against a set of predefined cases.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pycodestyle/rules/errors.rs",
            "description": "Defines custom `Violation` types for Ruff linter, specifically `IOError` for unreadable files and a deprecated `SyntaxError`.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pyflakes/fixes.rs",
            "description": "This file provides utility functions for generating code modifications (edits) to fix linting issues, primarily focused on removing unused arguments from string formatting calls and cleaning up exception handler assignments.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/src/rules/tryceratops/snapshots",
            "description": "This directory stores test snapshots for the 'tryceratops' rule within the 'ruff_linter' crate. These snapshots are used in testing to verify the expected behavior and output of the linter rule, ensuring consistency and preventing regressions.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pyupgrade/fixes.rs",
            "description": "This file contains a utility function for `ruff_linter` that removes specified members from a Python `from ... import ...` statement. It's part of the `pyupgrade` rule fixes, designed to modify import statements by removing unwanted imported names.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/message/grouped.rs",
            "description": "This file defines a `GroupedEmitter` responsible for formatting and printing diagnostic messages, grouping them by filename. It includes features for displaying fix statuses, handling applicability, and adjusting line/column reporting for Jupyter notebooks.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/src/message/sarif.rs",
            "description": "This file defines the `SarifEmitter`, which converts Ruff's diagnostic messages into the Static Analysis Results Interchange Format (SARIF) JSON output. It handles the serialization of diagnostic information, including rules, locations, and fixes, into a SARIF 2.1.0-compliant report.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/message/mod.rs",
            "description": "This file defines the core logic for creating, formatting, and emitting diagnostics (e.g., linting errors, panics) within the Ruff linter. It provides functions to construct diagnostic messages and an `Emitter` trait for rendering them in various formats.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/src/message/snapshots",
            "description": "This directory stores snapshot test data for messages generated by the `ruff_linter` crate. These snapshots are used to ensure that linter messages remain consistent and do not change unexpectedly during development, typically compared against generated output during testing.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/fix/snippet.rs",
            "description": "This file defines a `SourceCodeSnippet` struct for managing and formatting source code snippets for user-facing display, particularly in diagnostics. It includes logic to truncate snippets that are too long or contain newlines.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/fix/codemods.rs",
            "description": "This file defines an interface and functions for editing Python code snippets, specifically for modifying import statements, by parsing them with libCST and regenerating the code.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/fix/edits.rs",
            "description": "This file defines an interface for generating various types of code edits (fixes) from higher-level actions, such as deleting statements, removing comments, managing imports, or modifying function arguments. It provides utilities for implementing automatic code transformations and refactorings in Python.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/fix/mod.rs",
            "description": "This file implements the core logic for applying automatic code fixes generated by the linter to a source file. It processes diagnostics, applies their associated edits, and resolves potential conflicts or overlaps to produce a fixed version of the code.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/src/snapshots",
            "description": "This directory is intended to store test snapshots for the `ruff_linter` crate. These snapshots are typically used in 'snapshot testing' to verify the output or state of components against a previously recorded baseline. Its current emptiness suggests snapshots are either generated on demand during testing or have not yet been committed.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_quotes/doubles_noqa.py",
            "description": "This file is a test fixture for the `flake8_quotes` linter, demonstrating that a double-quoted string with a `# noqa` comment is correctly ignored and not flagged as a linting error.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyflakes/F401_7.py",
            "description": "This file serves as a test fixture for verifying the behavior of `noqa` directives on import statements, specifically how they suppress `F401` (unused import) errors and handle nested or overlapping directives.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyflakes/F822_3.py",
            "description": "This file is a test fixture for the `pyflakes` `F822` rule, demonstrating that `ruff_linter` correctly respects `# noqa` directives when applied to `__all__` definitions.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyflakes/F811_21.py",
            "description": "This file is a test fixture for the Ruff linter, specifically designed to test the handling of `F811` (redefinition of unused name) errors when `noqa` directives are used in various configurations within import statements.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pygrep_hooks/PGH004_2.py",
            "description": "This file serves as a test fixture for linters, specifically demonstrating various 'noqa' comments to suppress linting errors on an import statement.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pygrep_hooks/PGH004_3.py",
            "description": "This file is a test fixture for the Ruff linter, specifically designed to evaluate the handling of various `noqa` directives, including a specific one for rule PGH004.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/ruff/RUF100_3.py",
            "description": "This file serves as a test fixture for the Ruff linter, demonstrating various ways to use '# noqa' comments to suppress linting errors, including with and without specific error codes and additional inline comments.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/ruff/RUF100_0.py",
            "description": "This file serves as a test fixture for the Ruff linter, demonstrating various valid and invalid uses of the '# noqa' directive to suppress linting errors, including cases with specific error codes, multiple codes, and different formatting.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/ruff/noqa.py",
            "description": "This file serves as a test fixture to verify the parsing and behavior of `noqa` directives in comments, particularly focusing on different ways of specifying multiple error codes and their separators.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/ruff/flake8_noqa.py",
            "description": "This file is a test fixture for the Ruff linter, demonstrating the 'flake8: noqa' directive. It ensures that Ruff correctly ignores all linting issues within the file, including the unused variable 'x'.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/ruff/RUF101_0.py",
            "description": "This file serves as a test fixture to evaluate how the linter handles various combinations and repetitions of `noqa` directives for RUF940 and RUF950 codes.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/ruff/RUF100_5.py",
            "description": "This file is a test fixture for the Ruff linter, demonstrating various usages of `noqa` comments on imports, dictionary items, and return statements, including cases related to autofixing and specific rule codes.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/ruff/ruff_noqa_all.py",
            "description": "This file serves as a test fixture for the Ruff linter, specifically to verify its handling of the file-wide `# ruff: noqa` directive. It confirms that Ruff correctly ignores all linting issues within a file containing this comment.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/ruff/RUF100_6.py",
            "description": "This file is a test fixture for the Ruff linter, designed to verify its handling of file-level `noqa` directives, specifically for suppressing the F841 unused variable warning. It explicitly declares an intentional `noqa` for testing purposes.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/ruff/RUF100_2.py",
            "description": "This file is a test fixture for the Ruff linter, demonstrating the `noqa: F401` directive to suppress an unused import warning.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/ruff/ruff_noqa_codes.py",
            "description": "This file is a test fixture for ruff, specifically demonstrating and testing the `noqa` directive for ignoring unused import errors (F401). It imports modules 'os' and 'foo' which are not used, and includes a `noqa: F401` comment to suppress the expected linting error.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/ruff/ruff_per_file_ignores.py",
            "description": "This file is a test fixture for the Ruff linter, demonstrating the use of `noqa` comments to ignore specific linting errors (e.g., F401) or all errors within a file.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/ruff/suppressions.py",
            "description": "This file serves as a test fixture for the Ruff linter, demonstrating various scenarios and edge cases related to its inline suppression mechanisms, including `ruff: disable`/`enable` comments and `noqa` directives.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/ruff/RUF102.py",
            "description": "This file serves as a test fixture for the Ruff linter, demonstrating various scenarios of `noqa` comments on import statements, including invalid codes, mixed valid and invalid codes, and multiple invalid codes, to test the linter's handling of these directives.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/ruff/RUF100_1.py",
            "description": "This file serves as a test fixture for the ruff linter, demonstrating various scenarios for `noqa` comments on `from typing import` statements, particularly for ignoring or marking unused import warnings (F401).",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/ruff/RUF100_7.py",
            "description": "This file is a test fixture for the ruff linter, specifically demonstrating the application of `noqa` comments at the file level to suppress `F841` (unused variable) and `F541` (no-placeholder f-string) violations within a function.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/ruff/ruff_noqa_invalid.py",
            "description": "This file serves as a test fixture for Ruff, designed to evaluate how `noqa` comments are handled in potentially invalid or edge-case scenarios.",
            "spof": false
          },
          {
            "path": "crates/ruff_macros/src/lib.rs",
            "description": "This crate defines internal procedural macros used by the `ruff` and `ty` libraries for tasks such as deriving metadata, handling code generation, and utility functions like `kebab_case`.",
            "spof": true
          },
          {
            "path": "crates/ruff_macros/src/derive_message_formats.rs",
            "description": "This procedural macro analyzes a given function's body to extract `format!` macro arguments or string literals used with `to_string`, and then generates a `message_formats` function that returns these collected strings as a static slice.",
            "spof": true
          },
          {
            "path": "crates/ty_project/src/fixes.rs",
            "description": "This file contains logic for applying fixes to source code, primarily focusing on suppressing lint diagnostics by modifying files and writing the changes back to disk. It handles the application of multiple fixes, checks for new syntax errors, and manages file I/O operations.",
            "spof": true
          }
        ],
        "contributors": [
          {
            "name": "Brent Westbrook",
            "percent": 33
          },
          {
            "name": "Amethyst Reese",
            "percent": 25
          },
          {
            "name": "Andrew Gallant",
            "percent": 12
          }
        ]
      },
      "General-Purpose and Style Rule Implementations": {
        "files": [
          {
            "path": "crates/ty_python_semantic/resources/mdtest/diagnostics/invalid_await.md",
            "description": "This file contains a collection of test cases and explanations for the `invalid-await` diagnostic in Python, demonstrating various scenarios where an object is not properly awaitable.",
            "spof": true
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/85_match_invalid.py",
            "description": "This file demonstrates an invalid `match` statement syntax, specifically an assignment expression within a `case` pattern, likely for testing a linter or static analyzer's ability to flag such errors.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/line_width.rs",
            "description": "This file defines structures and utilities for managing and calculating line lengths and widths in code, including tab size considerations and validation, primarily for linting purposes.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/checkers/logical_lines.rs",
            "description": "This file implements the `check_logical_lines` function, which iterates through logical lines of Python code and applies various linting rules related to whitespace, indentation, and operator spacing.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/checkers/tokens.rs",
            "description": "Implements and dispatches various lint rules that operate by traversing the token stream of a Python file, rather than its abstract syntax tree.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/checkers/mod.rs",
            "description": "This file serves as the module entry point for the `checkers` directory, re-exporting various sub-modules related to different aspects of static analysis and linting within the Ruff linter, such as AST, filesystem, imports, and line processing.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/checkers/physical_lines.rs",
            "description": "Checks for lint rules that operate on the physical lines of a source file, such as line length, whitespace issues, and copyright notices.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/src/checkers/filesystem.rs",
            "description": "This file implements linter checks that analyze a source file's path and its surrounding file system context. It applies rules for issues like implicit namespace packages, invalid module names, and standard library module shadowing.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/checkers/ast/analyze/comprehension.rs",
            "description": "This file defines a function to analyze Python comprehension nodes for specific lint rules. It applies rules from `flake8_simplify` and `refurb` modules, such as checking for `key in dict` comprehensions and `readlines` in comprehensions.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/checkers/ast/analyze/parameter.rs",
            "description": "This file defines a function that applies various linting rules, such as `AmbiguousVariableName` and `BuiltinArgumentShadowing`, to a Python `Parameter` AST node.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/checkers/ast/analyze/module.rs",
            "description": "This file defines a function that runs specific lint rules over a Python module's abstract syntax tree, such as checking for f-string docstrings or invalid formatter suppression comments.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/checkers/ast/analyze/deferred_for_loops.rs",
            "description": "This file defines a function to apply various lint rules specifically to `for` loop statements that were deferred during the initial AST analysis phase. It processes these loops to check for issues like unused loop variables, incorrect dictionary iteration, and unnecessary `enumerate`.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/src/checkers/ast/analyze/parameters.rs",
            "description": "This file defines a function that analyzes `Parameters` syntax nodes, applying various lint rules related to function parameters and default arguments, including special handling for stub files.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/src/checkers/ast/analyze/string_like.rs",
            "description": "This file defines a function that dispatches various linting rules related to string-like syntax nodes (e.g., strings, f-strings, byte strings) to the appropriate linter modules based on the enabled rules.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/checkers/ast/analyze/except_handler.rs",
            "description": "This file defines a function that applies various linting rules to Python `except` blocks (exception handlers) within the Ruff linter, checking for common issues and anti-patterns related to exception handling.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/src/checkers/ast/analyze/unresolved_references.rs",
            "description": "This file implements a checker that identifies and reports undefined or unresolved references in Python code, such as names used without prior definition or names from wildcard imports, while accounting for various exceptions and contexts.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/checkers/ast/analyze/statement.rs",
            "description": "This file contains the logic for running various linting rules over Python `Stmt` (statement) syntax nodes. It dispatches to specific rule implementations based on the statement type and configured rules in the linter.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/checkers/ast/analyze/deferred_lambdas.rs",
            "description": "This file defines a function `deferred_lambdas` responsible for analyzing deferred Python lambda expressions. It iterates through these lambdas and applies various lint rules, such as checking for unnecessary lambdas, reimplemented container builtins, and argument shadowing.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/comments/mod.rs",
            "description": "This file serves as the main module for managing comment-related functionalities within the `ruff_linter` crate, specifically importing and exposing the `shebang` module.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_boolean_trap/mod.rs",
            "description": "This file is the main module for the `flake8_boolean_trap` linter rules within Ruff, defining its sub-modules (helpers, rules, settings) and comprehensive tests.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_boolean_trap/helpers.rs",
            "description": "Provides helper functions for the `flake8_boolean_trap` linter rule to determine when the use of boolean arguments is permitted in Python function calls and definitions.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_boolean_trap/rules/boolean_default_value_positional_argument.rs",
            "description": "This file defines a lint rule (FBT002) in Ruff that detects and flags function definitions using boolean positional arguments with default values, which can lead to confusing and less extensible code. It suggests alternatives like enums or keyword-only arguments.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_boolean_trap/rules/mod.rs",
            "description": "This module (`mod.rs`) serves as the entry point for the `flake8_boolean_trap` rules, grouping and re-exporting specific rules related to boolean trap detection in Python code.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_boolean_trap/rules/boolean_positional_value_in_call.rs",
            "description": "This file implements a lint rule for Ruff that detects and reports the use of boolean literals as positional arguments in function calls, a common 'boolean trap' anti-pattern. It defines the `BooleanPositionalValueInCall` violation and the logic to identify such cases.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_boolean_trap/rules/boolean_type_hint_positional_argument.rs",
            "description": "This file defines a linting rule (`FBT001`) that identifies and flags the use of boolean-typed positional arguments in Python function definitions. It provides checks for various exemptions, such as dunder methods, setters, and `@override` methods.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_2020/helpers.rs",
            "description": "This file provides helper functions for the `flake8_2020` rules, specifically containing a utility to check if an expression refers to an attribute of the `sys` module.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_2020/mod.rs",
            "description": "This file serves as the main module for the `flake8-2020` rules within the `ruff_linter`, organizing helper functions, rule implementations, and comprehensive tests for these rules.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_2020/rules/name_or_attribute.rs",
            "description": "This file implements a linter rule (YTT202) for `flake8_2020` in Ruff, detecting and flagging the use of `six.PY3` which can cause issues on Python 4+.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_2020/rules/mod.rs",
            "description": "This `mod.rs` file acts as the main module for the `flake8_2020` rules in the Ruff linter, re-exporting individual rule implementations from its sub-modules to make them publicly accessible within the crate.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_2020/rules/subscript.rs",
            "description": "This file implements linter rules for detecting and reporting unsafe or unreliable access patterns to Python's `sys.version` string for version number extraction, recommending the use of `sys.version_info` instead. It defines specific violations for common problematic slices and indices like `[:3]`, `[2]`, `[0]`, and `[:1]`.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_2020/rules/compare.rs",
            "description": "This file implements several linting rules for Ruff that detect problematic comparisons involving Python's `sys.version` and `sys.version_info`. It aims to identify error-prone version checks that can lead to subtle bugs or become incorrect with future Python versions, recommending more robust comparison methods.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_2020/snapshots",
            "description": "This directory is intended to store snapshot test files for the `flake8_2020` rules within the `ruff_linter` crate. Snapshot tests capture and compare the expected output or state of code, ensuring that changes do not inadvertently alter behavior. An empty directory suggests no snapshot tests are currently implemented or generated for these specific rules.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_bugbear/helpers.rs",
            "description": "This file provides helper functions for the `flake8_bugbear` rule, including identifying infinite iterators and determining if an expression is the last top-level statement in a Jupyter Notebook cell.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_bugbear/mod.rs",
            "description": "This file serves as the main module for integrating and testing the `flake8-bugbear` rules within the Ruff linter. It organizes the rule implementations, helper functions, settings, and comprehensive unit tests for all `flake8-bugbear` diagnostics.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_bugbear/rules/assert_false.rs",
            "description": "Implements a linting rule (`B011`) that identifies and offers to fix `assert False` statements in Python code, replacing them with `raise AssertionError()` to ensure consistent behavior in optimized Python environments.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_bugbear/rules/abstract_base_class.rs",
            "description": "Implements linting rules for `flake8-bugbear` related to abstract base classes, detecting ABCs without abstract methods/properties and empty methods in ABCs missing an `@abstractmethod` decorator.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_bugbear/rules/star_arg_unpacking_after_keyword_arg.rs",
            "description": "Implements a rule (`B026`) that checks for star-argument unpacking occurring after a keyword argument in Python function calls. This pattern is discouraged due to potential confusion and being supported only for backwards compatibility.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_bugbear/rules/jump_statement_in_finally.rs",
            "description": "Implements a lint rule (B012) for Ruff that detects and reports the use of `break`, `continue`, or `return` statements within `finally` blocks in Python code, as these can silently suppress exceptions.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_bugbear/rules/function_uses_loop_variable.rs",
            "description": "This file implements a lint rule (B023) in the Ruff linter that detects when a function or lambda uses a loop variable that isn't bound within its scope, leading to unexpected behavior. It identifies these 'late-binding closures' and suggests solutions like default arguments or `functools.partial`.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_bugbear/rules/useless_contextlib_suppress.rs",
            "description": "This file implements a `ruff` lint rule (B022) that identifies and flags redundant `contextlib.suppress()` calls made without any arguments, as they suppress no exceptions. It defines the `UselessContextlibSuppress` violation and the logic to detect such cases.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_bugbear/rules/assert_raises_exception.rs",
            "description": "This file implements a Ruff lint rule (B017) that detects overly broad exception handling in `unittest.assertRaises` and `pytest.raises` calls. It flags instances where `Exception` or `BaseException` are caught, recommending more specific exception types or regex matching instead.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_bugbear/rules/unused_loop_control_variable.rs",
            "description": "This file implements a linter rule (B007) to detect and flag unused loop control variables in Python code. It identifies variables in `for` loop targets that are not referenced within the loop body and suggests prepending an underscore to them or removing them.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_bugbear/rules/re_sub_positional_args.rs",
            "description": "This file implements a lint rule for `ruff` that flags `re.sub`, `re.subn`, and `re.split` calls where `count`, `maxsplit`, or `flags` are passed as positional arguments instead of keyword arguments.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_bugbear/rules/unary_prefix_increment_decrement.rs",
            "description": "This file implements a linting rule for Ruff that detects and reports the use of non-existent unary prefix increment (`++`) and decrement (`--`) operators in Python code.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_bugbear/rules/static_key_dict_comprehension.rs",
            "description": "This file implements a Ruff lint rule (`B035`, `RUF011`) that detects dictionary comprehensions using a static key, which commonly indicates a programming error resulting in a single-entry dictionary.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_bugbear/rules/except_with_empty_tuple.rs",
            "description": "Implements a lint rule (B029) that identifies and flags `except` clauses attempting to catch an empty tuple, as this is ineffective and indicates a programming error. It detects both `except ():` and `except* ():` cases.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_bugbear/rules/raise_literal.rs",
            "description": "This file implements a lint rule (`B016`) for Ruff that identifies and reports instances where a Python `raise` statement attempts to raise a literal value, which is not a valid exception.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_bugbear/rules/mod.rs",
            "description": "This module aggregates and re-exports all individual rule implementations for the `flake8_bugbear` linter within the `ruff_linter` project. It serves as the entry point for accessing these rules.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_bugbear/rules/redundant_tuple_in_exception_handler.rs",
            "description": "Implements a linting rule for Ruff that detects and fixes redundant single-element tuples in Python `except` clauses, suggesting replacement with the exception type directly.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_bugbear/rules/no_explicit_stacklevel.rs",
            "description": "This file implements a Ruff lint rule (B028) that identifies `warnings.warn` calls missing an explicit `stacklevel` keyword argument. It provides a fix to automatically insert `stacklevel=2`.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_bugbear/rules/except_with_non_exception_classes.rs",
            "description": "Implements a lint rule (B030) for Ruff that detects `except` or `except*` handlers attempting to catch non-exception classes, which would result in a `TypeError`.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_bugbear/rules/useless_expression.rs",
            "description": "This file implements the `B018` rule for Ruff, which detects and reports 'useless expressions' in Python code. It identifies expressions without side effects that are not assigned or used, with special handling for attributes and Jupyter Notebooks.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_bugbear/rules/function_call_in_argument_default.rs",
            "description": "This file implements a linting rule (B008) for Ruff that detects function calls in Python function argument defaults. It flags mutable function calls that could lead to unexpected behavior, while ignoring immutable types or configured exceptions.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_bugbear/rules/mutable_argument_default.rs",
            "description": "This file implements the `MutableArgumentDefault` (B006) lint rule for Ruff, which detects and fixes mutable objects used as default arguments in Python function definitions. It provides an unsafe fix to replace the mutable default with `None` and initialize the object inside the function body.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_bugbear/rules/unintentional_type_annotation.rs",
            "description": "This file implements a lint rule (B032) for the Ruff linter that detects and flags Python code where a colon (:) is likely misused as an assignment operator (=) in subscript or attribute expressions, indicating an unintentional type annotation.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_bugbear/rules/duplicate_value.rs",
            "description": "This file implements the `B033` lint rule for Ruff, which detects and offers to fix duplicate items within Python set literals. It defines the `DuplicateValue` violation and the logic to identify and remove redundant set elements.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_bugbear/rules/class_as_data_structure.rs",
            "description": "Defines a linting rule (B903) that identifies Python classes which solely consist of a simple `__init__` method and no base classes or decorators, suggesting they could be refactored into dataclasses or namedtuples.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_bugbear/rules/f_string_docstring.rs",
            "description": "Implements a lint rule (`B021`) to detect and report instances where f-strings are incorrectly used as docstrings in Python code, as they are not interpreted as actual docstrings by Python.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_bugbear/rules/unreliable_callable_check.rs",
            "description": "Implements a linter rule (B004) for Ruff that detects unreliable checks for callable objects using `hasattr(obj, \"__call__\")` and suggests using `callable(obj)` instead. It also provides an unsafe fix for this pattern.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_bugbear/rules/mutable_contextvar_default.rs",
            "description": "Implements the Ruff lint rule B039, which detects and flags the use of mutable data structures as default values for `ContextVar` objects in Python code. This rule helps prevent unexpected behavior due to shared mutable state across `ContextVar` access.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_bugbear/rules/strip_with_multi_characters.rs",
            "description": "Implements a linter rule (B005) that detects potentially misleading uses of `str.strip()`, `str.lstrip()`, or `str.rstrip()` methods when called with multi-character string arguments containing duplicate characters.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_bugbear/rules/setattr_with_constant.rs",
            "description": "Implements a lint rule (`B010`) that flags `setattr` calls where the attribute name is a constant string, recommending direct attribute assignment instead. It also handles the generation of a fix, considering safety aspects related to Unicode normalization and comments.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_bugbear/rules/loop_variable_overrides_iterator.rs",
            "description": "This file implements a lint rule (B020) for the Ruff linter that detects and reports instances where a loop's control variable shares the same name as the iterable it is iterating over, leading to potential confusion.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_bugbear/rules/duplicate_exceptions.rs",
            "description": "This file implements linter rules (B014 and B025) for detecting duplicate exception handlers or redundant exceptions within a single handler in Python `try-except` blocks, including mechanisms to suggest fixes.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_bugbear/rules/getattr_with_constant.rs",
            "description": "This file implements a Ruff linter rule (`B009`) that detects and suggests fixes for `getattr` calls using constant attribute names, advising replacement with direct attribute access. It includes logic for determining fix safety based on Unicode normalization and comment presence.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_bugbear/rules/loop_iterator_mutation.rs",
            "description": "Implements a linter rule (B909) to detect and report mutations to an iterable collection within the body of the `for` loop that is iterating over it. It identifies various forms of mutations like assignments, deletions, augmented assignments, and specific method calls that modify the collection.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_bugbear/rules/useless_comparison.rs",
            "description": "Implements a lint rule (B015) for the Ruff linter that detects and reports useless comparison expressions in Python code, with special handling for functions and Jupyter Notebooks.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_bugbear/snapshots",
            "description": "This directory stores snapshot test files specifically for the `flake8_bugbear` rules within the `ruff_linter` crate. These snapshots define the expected output or behavior for various test cases. They are used by the testing framework to ensure the linter's consistency by comparing actual outputs against these predefined correct results.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/eradicate/detection.rs",
            "description": "This file implements the core logic for the 'eradicate' rule in Ruff, specifically the `comment_contains_code` function. It determines whether a given comment line in Python code likely contains actual, commented-out Python code using various heuristics and parsing attempts.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/eradicate/mod.rs",
            "description": "This file serves as the module entry point for integrating rules from the `eradicate` project into the `ruff_linter`, organizing its detection logic and rule definitions, and including tests for these rules.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/src/rules/eradicate/rules/mod.rs",
            "description": "This file acts as a module aggregator for the 'eradicate' linter rules, specifically exposing the 'commented_out_code' rule.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/eradicate/snapshots",
            "description": "This directory is intended to store snapshot test data for the 'eradicate' rule within the `ruff_linter` crate. Snapshot tests capture expected output or state, and these snapshots are used to compare against current test run results to detect unexpected changes. Being empty suggests no snapshots have been generated or committed for this rule yet.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_gettext/mod.rs",
            "description": "This file serves as the main module for implementing and testing `flake8-gettext` rules within the Ruff linter. It includes a utility function to identify internationalization function calls relevant to these rules.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_gettext/rules/f_string_in_gettext_func_call.rs",
            "description": "This file implements a lint rule for the `ruff` linter that detects and flags the use of f-strings within `gettext` function calls, recommending an alternative for proper internationalization.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_gettext/rules/mod.rs",
            "description": "This file serves as the module entry point for Flake8-Gettext rules, aggregating and re-exporting individual rules related to detecting string formatting issues within `gettext` function calls.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_gettext/rules/format_in_gettext_func_call.rs",
            "description": "This file implements a lint rule (INT002) that detects and reports `str.format` calls used as arguments to `gettext` functions, which can lead to incorrect internationalization behavior. It provides a diagnostic for this anti-pattern.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_gettext/rules/printf_in_gettext_func_call.rs",
            "description": "Detects and reports the use of printf-style string formatting directly within `gettext` function calls, which can lead to incorrect internationalization behavior. It suggests formatting the return value of `gettext` instead of its argument.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_gettext/snapshots",
            "description": "This directory stores snapshot test data for the `flake8_gettext` linting rule within the `ruff_linter` crate. These snapshots are used to compare current rule outputs against expected outputs during testing, ensuring consistent behavior and preventing regressions.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_builtins/helpers.rs",
            "description": "Provides helper functions for the `flake8_builtins` rule, specifically to determine if a given name shadows a Python builtin.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_builtins/mod.rs",
            "description": "This file defines the module structure and contains extensive unit tests for the `flake8-builtins` rules implemented in the Ruff linter. It verifies the correct identification of built-in and standard library module shadowing under different configurations and Python versions.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_builtins/rules/builtin_lambda_argument_shadowing.rs",
            "description": "This file implements a lint rule for Ruff, `A006 BuiltinLambdaArgumentShadowing`, which detects and reports when lambda arguments in Python code shadow built-in function names. It helps improve code readability and prevent subtle errors by enforcing best practices around naming conventions.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_builtins/rules/builtin_import_shadowing.rs",
            "description": "This file implements a linting rule (A004) that checks for and reports cases where an imported name shadows a Python builtin, aiming to prevent readability issues and potential errors. It defines the `BuiltinImportShadowing` violation and the logic to detect such shadowing.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_builtins/rules/mod.rs",
            "description": "This file serves as a module for the `flake8_builtins` linter rules, re-exporting and organizing various checks related to shadowing of built-in functions, attributes, imports, lambda arguments, and standard library modules.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_builtins/rules/builtin_argument_shadowing.rs",
            "description": "This file implements a linting rule (A002) for `flake8-builtins` that detects when a function argument's name shadows a Python builtin, with specific exceptions for lambda expressions and `@override` or `@overload` decorated functions.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_builtins/rules/stdlib_module_shadowing.rs",
            "description": "Implements a lint rule (A005) that detects Python modules in a project which shadow standard library modules. It helps prevent naming conflicts and improves code readability by flagging modules with conflicting names.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_builtins/rules/builtin_variable_shadowing.rs",
            "description": "This file implements a lint rule for Ruff, specifically `A001: BuiltinVariableShadowing`. It identifies and reports cases where a variable or function in Python code shares a name with a Python built-in, which can lead to confusion and runtime errors.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_builtins/rules/builtin_attribute_shadowing.rs",
            "description": "This file implements a linter rule (A003) that detects and reports when class attributes or methods shadow Python built-in names, especially when these shadowed names are referenced within the class's own scope.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_builtins/snapshots",
            "description": "This directory stores snapshot test files for the `flake8_builtins` rule within the `ruff_linter` crate. These snapshots capture the expected output or behavior of the linter rule for various code samples. They are used by the testing framework to ensure consistent and correct rule enforcement.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_copyright/mod.rs",
            "description": "This file serves as the main module for the `flake8-copyright` rules within the Ruff linter, defining and testing various conditions for valid copyright notices in Python source files.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_copyright/rules/mod.rs",
            "description": "This file serves as the module entry point for the 'flake8_copyright' rules, re-exporting the 'missing_copyright_notice' rule for external use.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_copyright/rules/missing_copyright_notice.rs",
            "description": "This file defines a linting rule (CPY001) that checks for the absence of a copyright notice, and optionally a specific author, at the beginning of source files.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_copyright/snapshots",
            "description": "This directory is intended to store test snapshots for the `flake8_copyright` rule within the `ruff_linter` crate. These snapshots are typically used to verify that the output or behavior of linting rules remains consistent across changes.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_async/mod.rs",
            "description": "This file defines the module for `flake8-async` linter rules within Ruff, importing rule implementations and containing comprehensive unit tests for these asynchronous code-related checks.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_async/helpers.rs",
            "description": "This file defines enums and helper methods to identify and categorize asynchronous Python modules (like `asyncio`, `anyio`, `trio`) and their specific methods, including determining if they are async or timeout-related. It facilitates analysis for `flake8_async` linter rules.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_async/rules/async_busy_wait.rs",
            "description": "This file implements a lint rule for Ruff, specifically `ASYNC110`, which detects and flags `asyncio.sleep` calls inside `while` loops that indicate a busy-waiting pattern, suggesting the use of `asyncio.Event` instead.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_async/rules/blocking_input.rs",
            "description": "This file implements a lint rule (ASYNC250) for Ruff that detects and reports blocking `input()` calls made within asynchronous Python functions. It prevents blocking the event loop in async contexts.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_async/rules/blocking_http_call.rs",
            "description": "This file implements a lint rule to detect and flag blocking HTTP calls within asynchronous Python functions. It aims to prevent performance issues by ensuring that async functions do not use synchronous HTTP libraries like `urllib` or `requests`.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_async/rules/blocking_sleep.rs",
            "description": "This file implements a lint rule for Ruff, specifically `flake8-async` rule `ASYNC251`, which detects and flags `time.sleep` calls within asynchronous Python functions, recommending `asyncio.sleep` instead.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_async/rules/blocking_open_call.rs",
            "description": "This file implements a lint rule for Ruff (ASYNC230) that detects and flags blocking file open calls within asynchronous Python functions. It aims to prevent event loop blocking by enforcing the use of async-compatible file operations.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_async/rules/blocking_http_call_httpx.rs",
            "description": "Implements a lint rule (ASYNC212) for Ruff that detects and reports blocking `httpx.Client` method calls within asynchronous Python functions, recommending the use of `httpx.AsyncClient`.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_async/rules/long_sleep_not_forever.rs",
            "description": "This file implements a lint rule (ASYNC116) that identifies `trio.sleep()` or `anyio.sleep()` calls with a delay exceeding 24 hours and suggests replacing them with `sleep_forever()` for better clarity, providing an unsafe fix.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_async/rules/sync_call.rs",
            "description": "Implements a linting rule (ASYNC105) that identifies and flags unawaited calls to asynchronous `trio` functions, offering an unsafe fix to add the `await` keyword.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_async/rules/blocking_path_methods.rs",
            "description": "Implements the ASYNC240 lint rule, detecting and flagging synchronous `os.path` and `pathlib.Path` I/O operations when used within async functions.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_async/rules/async_zero_sleep.rs",
            "description": "This file implements a `ruff` linter rule (ASYNC115) that detects and suggests replacing `trio.sleep(0)` or `anyio.sleep(0)` calls with `trio.lowlevel.checkpoint()` or `anyio.lowlevel.checkpoint()` respectively, including an automatic fix.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_async/rules/blocking_process_invocation.rs",
            "description": "This file implements linter rules for Ruff, detecting and flagging various blocking process invocation methods (like `os.popen`, `subprocess.run`, `os.waitpid`) when used within asynchronous Python functions to prevent event loop blocking.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_async/rules/cancel_scope_no_checkpoint.rs",
            "description": "This file implements a Ruff linter rule (ASYNC100) that identifies `async with` statements using timeout context managers (e.g., `asyncio.timeout`) which lack any `await` or `yield` expressions within their block, indicating a potentially ineffective timeout. It ensures that asynchronous timeout context managers contain checkpoints necessary for their functionality.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_async/rules/mod.rs",
            "description": "This file serves as the main module for a collection of linting rules related to asynchronous programming, specifically for detecting common issues and anti-patterns in `flake8_async` within the ruff linter.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_async/snapshots",
            "description": "This directory stores snapshot test files for the `flake8_async` linter rules within the `ruff_linter` crate. These snapshots capture the expected diagnostic output and autofix behavior for various code samples, ensuring the rules function as intended during development and refactoring.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_blind_except/mod.rs",
            "description": "This file serves as the module entry point for the `flake8-blind-except` rules in the Ruff linter, defining the module structure and containing unit tests for these rules.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_blind_except/rules/mod.rs",
            "description": "This file serves as the main module for the `flake8_blind_except` rules within `ruff_linter`, re-exporting the blind except rule implementations defined in its sibling module.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_blind_except/rules/blind_except.rs",
            "description": "This file implements a linting rule (BLE001) for the Ruff linter that detects overly broad `except` clauses catching `BaseException` or `Exception` in Python code. It flags these as 'blind excepts' unless the exception is explicitly re-raised or logged with `exc_info`.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_blind_except/snapshots",
            "description": "This directory is intended to store test snapshots for the `flake8_blind_except` linter rule. These snapshots are typically used in unit tests to verify the rule's behavior and output against expected, pre-recorded results, ensuring consistent functionality during development and refactoring.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_quotes/helpers.rs",
            "description": "This file provides helper functions for analyzing and manipulating string literals within the `flake8_quotes` rule in the Ruff linter, including extracting raw content and handling escaped quotes.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_quotes/mod.rs",
            "description": "This file serves as the main module for the `flake8-quotes` rules within the Ruff linter. It defines submodules for helpers, rules, and settings, and includes extensive tests to ensure correct enforcement of quote styles based on configured settings.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_quotes/rules/mod.rs",
            "description": "This file serves as the main module for the `flake8_quotes` rules, aggregating and re-exporting specific linting rules related to string quote usage and escaped quotes.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_quotes/rules/avoidable_escaped_quote.rs",
            "description": "Implements the `Q003` rule for Ruff, which identifies and fixes strings with avoidable escaped quotes by suggesting a change in the string's outer quotation style. It ensures that fixing the quote style does not introduce new issues, especially with f-strings and different Python versions.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_quotes/rules/unnecessary_escaped_quote.rs",
            "description": "This file implements a lint rule (Q004) to detect and fix unnecessary escaped quote characters within string literals. It identifies cases where an escaped quote character does not match the string's outer quote style and can therefore be removed.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_quotes/rules/check_string_quotes.rs",
            "description": "This file implements a linter rule that checks for consistent usage of single or double quotes in Python strings, covering inline strings, multiline strings, and docstrings. It defines violations and provides automatic fixes for quote style inconsistencies based on user-configured preferences.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_quotes/snapshots",
            "description": "This directory is designated to house snapshot test files for the `flake8_quotes` linter rules within the `ruff_linter` crate. Its purpose is to facilitate automated testing by comparing the linter's output against predefined snapshots, ensuring consistent rule enforcement.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_comprehensions/helpers.rs",
            "description": "This file provides helper functions for the `flake8_comprehensions` rule, primarily for identifying and extracting arguments from function calls that match specific names and argument patterns.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_comprehensions/mod.rs",
            "description": "This module integrates and tests the `flake8-comprehensions` rules within the Ruff linter. It defines various test cases to ensure the correct identification and reporting of issues related to unnecessary comprehensions, generators, and collection calls.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_comprehensions/fixes.rs",
            "description": "This file contains functions that implement automatic fixes for `flake8_comprehensions` rules, converting verbose dictionary and collection instantiations into more concise Python literals or comprehensions.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_comprehensions/rules/unnecessary_literal_within_dict_call.rs",
            "description": "Implements a lint rule (C418) for `flake8-comprehensions` that identifies and fixes unnecessary `dict()` calls wrapped around dict literals or comprehensions. It suggests removing the redundant outer `dict()` call.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_comprehensions/rules/unnecessary_call_around_sorted.rs",
            "description": "This file implements a lint rule for the Ruff linter that detects and fixes unnecessary `list()` or `reversed()` calls wrapping a `sorted()` call in Python code.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_comprehensions/rules/unnecessary_comprehension_in_call.rs",
            "description": "This file implements a Ruff rule (`C419`) that identifies and fixes unnecessary list or set comprehensions used as arguments to built-in functions like `any`, `all`, `sum`, `min`, and `max`, promoting the use of generator expressions for improved performance and memory efficiency.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_comprehensions/rules/unnecessary_list_call.rs",
            "description": "This file defines a lint rule (`C411`) for Ruff that identifies and fixes unnecessary `list()` calls wrapping list comprehensions in Python code.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_comprehensions/rules/unnecessary_literal_set.rs",
            "description": "This file implements a Ruff linter rule (`C405`) that identifies and fixes `set()` calls receiving unnecessary list or tuple literals as arguments, suggesting replacement with set literals.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_comprehensions/rules/mod.rs",
            "description": "This `mod.rs` file acts as a central module for the `flake8_comprehensions` rules, re-exporting and declaring various sub-modules that define specific linting rules for identifying unnecessary comprehension-related patterns in Python code.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_comprehensions/rules/unnecessary_literal_within_tuple_call.rs",
            "description": "This file implements a linter rule that detects and fixes unnecessary list or tuple literals, or list comprehensions (in preview mode), passed as arguments to the `tuple()` built-in function.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_comprehensions/rules/unnecessary_literal_dict.rs",
            "description": "This file defines a Ruff linting rule (C406) that identifies and suggests fixing `dict()` calls unnecessarily using list or tuple literals as arguments. It promotes rewriting such expressions as more concise dictionary literals.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_comprehensions/rules/unnecessary_dict_comprehension_for_iterable.rs",
            "description": "Implements a lint rule (C420) that identifies and suggests replacing unnecessary dict comprehensions (e.g., `{a: None for a in iterable}`) with `dict.fromkeys` for improved readability and efficiency.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_comprehensions/rules/unnecessary_double_cast_or_process.rs",
            "description": "This file implements a Ruff linter rule (C414) that identifies and suggests fixes for redundant nested calls to iterable casting or processing functions like `list()`, `set()`, and `sorted()`.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_comprehensions/rules/unnecessary_map.rs",
            "description": "This file implements a linting rule that identifies and flags unnecessary `map()` calls with lambda functions, recommending their replacement with generator expressions or comprehensions for improved performance and readability. It handles various `map()` contexts, including those wrapped in `list()`, `set()`, and `dict()`.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_comprehensions/rules/unnecessary_collection_call.rs",
            "description": "This file implements a lint rule (`C408`) that identifies and fixes unnecessary `dict()`, `list()`, and `tuple()` calls, suggesting they be rewritten as their equivalent literal forms (e.g., `{}` instead of `dict()`). It provides a fix to automatically convert these calls to literals.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_comprehensions/rules/unnecessary_list_comprehension_dict.rs",
            "description": "This file implements a lint rule that identifies and fixes unnecessary list comprehensions used as arguments to the `dict()` constructor, suggesting their conversion to more efficient dictionary comprehensions.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_comprehensions/rules/unnecessary_subscript_reversal.rs",
            "description": "This file defines a linting rule (C415) for Ruff, which detects and flags unnecessary reversal of iterables (e.g., `[::-1]`) when they are immediately passed to functions like `sorted()`, `set()`, or `reversed()`.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_comprehensions/rules/unnecessary_comprehension.rs",
            "description": "Implements the `C416` rule (unnecessary comprehension) for the Flake8-Comprehensions plugin, identifying and suggesting fixes for redundant dictionary, list, and set comprehensions in Python code.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_comprehensions/rules/unnecessary_list_comprehension_set.rs",
            "description": "Implements a linting rule for Ruff that detects and fixes unnecessary list comprehensions passed to the `set()` constructor, converting them into more efficient set comprehensions. It specifically targets patterns like `set([expression for item in iterable])` and suggests rewriting them as `{expression for item in iterable}`.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_comprehensions/rules/unnecessary_literal_within_list_call.rs",
            "description": "This file implements a linting rule (C410) that detects and fixes `list()` calls receiving unnecessary list or tuple literals as arguments. It proposes removing the outer `list()` call for list literals or rewriting tuple literals as list literals within the call.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_comprehensions/snapshots",
            "description": "This directory stores snapshot test data for the `flake8_comprehensions` rules implemented within the `ruff_linter` crate. These snapshots capture expected outputs or AST structures, ensuring that changes to the linter rules do not inadvertently alter their behavior. It's crucial for maintaining the stability and correctness of the linting rules during development.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_datetimez/mod.rs",
            "description": "This file serves as the main module for the `flake8-datetimez` rule set within the Ruff linter, specifically containing the integration tests for all rules in this plugin.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_datetimez/helpers.rs",
            "description": "This file defines utility functions and an enum for detecting specific usage patterns and antipatterns related to `datetime` objects and method chaining (like `.replace()` and `.astimezone()`) in Python code, primarily for linting purposes.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_datetimez/rules/call_datetime_utcfromtimestamp.rs",
            "description": "This file defines a lint rule (DTZ004) that identifies and flags the use of `datetime.datetime.utcfromtimestamp()` because it returns a naive datetime object, recommending `fromtimestamp(ts, tz=...)` instead for timezone-aware objects.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_datetimez/rules/call_date_fromtimestamp.rs",
            "description": "This file implements the `DTZ012` linting rule, which detects and flags the use of `datetime.date.fromtimestamp()` because it produces naive (non-timezone-aware) date objects. It recommends using timezone-aware alternatives like `datetime.datetime.fromtimestamp(ts, tz=...).date()`.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_datetimez/rules/call_date_today.rs",
            "description": "This file implements a linter rule (DTZ011) that identifies and flags the use of `datetime.date.today()` in Python code. It recommends using timezone-aware alternatives to avoid issues with naive date objects.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_datetimez/rules/call_datetime_today.rs",
            "description": "This file implements a Ruff linter rule (`DTZ002`) that flags instances where `datetime.datetime.today()` is called, recommending the use of timezone-aware alternatives like `datetime.datetime.now(tz=...)`.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_datetimez/rules/mod.rs",
            "description": "This module aggregates and re-exports various rules for the `flake8_datetimez` linter, specifically those related to handling `datetime` and `date` objects, particularly concerning timezone awareness.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_datetimez/rules/datetime_min_max.rs",
            "description": "This file implements a linting rule (DTZ901) for Ruff that detects and flags the use of naive `datetime.datetime.min` and `datetime.datetime.max` objects, recommending that they be made timezone-aware to prevent potential errors.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_datetimez/rules/call_datetime_fromtimestamp.rs",
            "description": "This file implements a Ruff linting rule (`DTZ006`) that identifies calls to `datetime.datetime.fromtimestamp()` which do not specify a timezone, or explicitly set `tz=None`, to encourage the use of timezone-aware datetime objects.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_datetimez/rules/call_datetime_utcnow.rs",
            "description": "Implements a lint rule (DTZ003) that detects and flags the use of `datetime.datetime.utcnow()` due to its return of a naive datetime object, recommending timezone-aware alternatives.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_datetimez/snapshots",
            "description": "This directory is intended to store test snapshots for the `flake8_datetimez` rules within the `ruff_linter` project. These snapshots are typically used during testing to verify that rule outputs or diagnostics match expected baselines.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_errmsg/mod.rs",
            "description": "This module integrates and tests the `flake8-errmsg` rules within the Ruff linter. It includes sub-modules for the rules, their settings, and unit tests to verify their functionality.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_errmsg/rules/string_in_exception.rs",
            "description": "This file defines linting rules (EM101, EM102, EM103) for the `flake8_errmsg` plugin to prevent direct use of string literals, f-strings, and `.format()` calls within exception constructors, and provides logic to suggest fixing them by assigning to a variable first. It includes violations for raw strings, f-strings, and `.format` calls in exceptions.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_errmsg/rules/mod.rs",
            "description": "This file acts as a module aggregator for the `flake8_errmsg` rules, primarily re-exporting the `string_in_exception` rule for use within the linter.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_self/mod.rs",
            "description": "This file serves as the main module for the `flake8-self` rule set within the Ruff linter, defining its structure, settings, and containing associated tests for rule `SLF001` (Private Member Access).",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_self/rules/mod.rs",
            "description": "This module aggregates and re-exports rules related to private member access for the flake8-self linter within Ruff.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_self/rules/private_member_access.rs",
            "description": "This file implements a linter rule (SLF001) that detects and flags accesses to 'private' class members (prefixed with underscores) from outside their defining class. It includes various exceptions for valid internal or special-case usages.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_slots/helpers.rs",
            "description": "This file contains a helper function to determine if a list of Rust AST statements includes an assignment to a variable named `__slots__`, likely for use in a linter rule.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_slots/mod.rs",
            "description": "This file serves as the main module for integrating and testing rules from the `flake8-slots` linter within the `ruff` project, ensuring proper detection of `__slots__` usage issues in Python code.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_slots/rules/no_slots_in_namedtuple_subclass.rs",
            "description": "This file implements a Ruff lint rule (`SLOT002`) that identifies Python classes subclassing `collections.namedtuple` or `typing.NamedTuple` that fail to define `__slots__`, promoting memory efficiency.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_slots/rules/no_slots_in_str_subclass.rs",
            "description": "This file implements a linting rule for Ruff that checks if Python classes subclassing `str` define `__slots__` to optimize memory usage, reporting a violation if `__slots__` is missing.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_slots/rules/no_slots_in_tuple_subclass.rs",
            "description": "Implements a linting rule that flags Python classes subclassing `tuple` if they do not define `__slots__`, to encourage memory optimization. It identifies and reports instances where `__slots__` are missing in such classes.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_slots/snapshots",
            "description": "This directory stores snapshot test files for the `flake8_slots` rule within the `ruff_linter` crate. These snapshots are used to compare current test output against expected output, ensuring consistent behavior for the linting rule.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_no_pep420/mod.rs",
            "description": "This file implements and tests the `flake8-no-pep420` rules within the Ruff linter. It includes test cases for identifying and handling implicit namespace packages as defined by PEP 420.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_no_pep420/rules/mod.rs",
            "description": "This file serves as the module entry point for the `flake8_no_pep420` rule, re-exporting the `implicit_namespace_package` rule implementation.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_no_pep420/rules/implicit_namespace_package.rs",
            "description": "This file defines the `INP001` lint rule, `ImplicitNamespacePackage`, which identifies Python packages that are missing an `__init__.py` file, indicating an unintended implicit namespace package.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_implicit_str_concat/mod.rs",
            "description": "This file is the main module for the `flake8-implicit-str-concat` linter rules, defining its sub-modules for rules and settings. It also includes comprehensive unit tests for various implicit string concatenation scenarios and rule configurations.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_implicit_str_concat/rules/collection_literal.rs",
            "description": "This file implements a linting rule for Ruff that detects unparenthesized implicit string concatenations within collection literals (e.g., lists, tuples, sets) and provides a fix to wrap them in parentheses.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_implicit_str_concat/rules/mod.rs",
            "description": "This `mod.rs` file serves as an aggregate module for the `flake8_implicit_str_concat` rules, re-exporting sub-modules that likely contain specific implementations for different implicit string concatenation scenarios.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_implicit_str_concat/rules/implicit.rs",
            "description": "This file implements rules for detecting and fixing implicitly concatenated string literals in Python, distinguishing between single-line and multi-line occurrences. It provides diagnostics and a mechanism to combine single-line concatenated strings into a single literal.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_implicit_str_concat/rules/explicit.rs",
            "description": "Implements a Ruff linting rule (ISC003) that identifies and suggests fixes for explicitly concatenated string literals using the `+` operator, favoring implicit concatenation for improved readability, especially across multiple lines.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_implicit_str_concat/snapshots",
            "description": "This directory is designated to store snapshots for testing the `flake8_implicit_str_concat` rule within the `ruff_linter` crate. These snapshots help ensure the rule's consistent behavior and output during development and refactoring.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_fixme/mod.rs",
            "description": "This file contains the test suite for the `flake8_fixme` rules within the `ruff_linter` crate, verifying the detection of various \"fixme\"-style comments.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_fixme/rules/mod.rs",
            "description": "This file acts as a module declaration for the `flake8_fixme` rules, specifically re-exporting and defining rule implementations from the `todos` submodule.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_fixme/rules/todos.rs",
            "description": "This file defines and implements linter rules for identifying and reporting various types of 'TODO-style' comments (e.g., TODO, FIXME, XXX, HACK) within source code. It marks these comments as violations, encouraging their resolution.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_fixme/snapshots",
            "description": "This directory stores snapshot test files specifically for the `flake8_fixme` rule within the `ruff_linter` crate. These snapshots capture expected linter output or internal state, ensuring that changes to the rule do not inadvertently alter its behavior.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_return/branch.rs",
            "description": "Defines an enum `Branch` to represent 'elif' and 'else' branching constructs, along with its display formatting, likely used within a linter rule to handle control flow branches.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_return/helpers.rs",
            "description": "This file provides helper functions for the `flake8_return` linter rule in Ruff, including checking for non-None return values and determining the logical end of a statement.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_return/mod.rs",
            "description": "This file serves as the main module for integrating and testing the `flake8-return` rules within the Ruff linter. It orchestrates sub-modules for rule implementation and provides unit tests for each `flake8-return` rule.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_return/visitor.rs",
            "description": "This file defines a visitor that traverses a Python abstract syntax tree to collect information relevant to return statements, such as all return statements, assignments preceding returns, elif/else clauses, non-local variables, annotated variables, and whether a function is a generator. This data is used by linting rules to analyze return statement patterns.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_return/rules/mod.rs",
            "description": "This file serves as the module entry point for the `flake8_return` rules, re-exporting all components defined in the `function` submodule to make them accessible from this module.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_return/rules/function.rs",
            "description": "Defines specific linting rules and violations for `flake8-return` related to `return` statements, explicit/implicit `None` returns, unnecessary assignments, and superfluous `else` blocks after control flow statements within functions.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_return/snapshots",
            "description": "This directory is intended to store snapshot test files for the `flake8_return` rules within the `ruff_linter` crate. These snapshots are used by testing frameworks to verify the expected output or behavior of the linter rules during development and continuous integration.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_logging_format/violations.rs",
            "description": "This file defines the `Violation` types for Ruff's `flake8_logging_format` rule, flagging different incorrect methods of formatting logging messages in Python (e.g., `str.format`, `%`, string concatenation, f-strings) and advocating for more efficient alternatives like `extra` arguments.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_logging_format/mod.rs",
            "description": "This file is the module entry point for the `flake8-logging-format` linting rules in Ruff, defining its sub-modules (`rules` and `violations`) and containing comprehensive test cases for all associated rules.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_logging_format/rules/mod.rs",
            "description": "This module (`mod.rs`) serves as the entry point for rules related to Flake8 logging format, re-exporting and organizing the `logging_call` module.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_logging_format/rules/logging_call.rs",
            "description": "Implements linting rules for `flake8-logging-format` to detect and fix common misuses and formatting issues in Python logging calls, such as f-strings, percent formatting, string concatenation, and attribute clashes.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_logging_format/snapshots",
            "description": "This directory stores snapshot test data for the `flake8_logging_format` rule within the `ruff_linter` crate. These snapshots are used to ensure that the linter's output for this specific rule remains consistent across code changes, preventing regressions.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_print/mod.rs",
            "description": "This file serves as the module definition for the `flake8-print` rules within the `ruff_linter` crate, including its sub-modules and tests for these rules.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_print/rules/mod.rs",
            "description": "This file acts as the module entry point for the `flake8_print` rules, re-exporting the `print_call` rule implementation. It organizes and exposes the logic for detecting `print` function calls.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_print/rules/print_call.rs",
            "description": "This file defines linting rules (`T201`, `T203`) to detect `print()` and `pprint.pprint()` calls in Python code, providing automatic fixes to remove them from the source.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_print/snapshots",
            "description": "This directory is intended to store snapshot test files for the `flake8_print` linter rule within the `ruff_linter` crate. These snapshots capture expected output or behavior, allowing for efficient regression testing of the rule's functionality.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_logging/helpers.rs",
            "description": "This file provides helper functions for `flake8_logging` rules, including checking if a given text offset is outside of exception handlers and identifying common logger method names.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_logging/mod.rs",
            "description": "This file serves as the main module for integrating and organizing the `flake8-logging` rules within the Ruff linter. It defines the structure for helpers, rule implementations, and tests related to logging-specific linting.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_logging/rules/direct_logger_instantiation.rs",
            "description": "This file implements a linting rule (LOG001) that detects and flags direct instantiations of `logging.Logger` in Python code, recommending the use of `logging.getLogger()` instead.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_logging/rules/invalid_get_logger_argument.rs",
            "description": "This file implements a Ruff lint rule (LOG002) that detects incorrect usage of `__file__` or `__cached__` as arguments to `logging.getLogger()`, recommending `__name__` instead. It provides a fix to replace the argument with `__name__`.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_logging/rules/undocumented_warn.rs",
            "description": "Implements a linter rule that detects the use of the undocumented `logging.WARN` constant and provides a fix to replace it with `logging.WARNING`.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_logging/rules/mod.rs",
            "description": "This file serves as the module entry point for the `flake8_logging` rules in the Ruff linter, aggregating and re-exporting various specific logging-related linting rules. It makes individual rule implementations accessible within the crate.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_logging/rules/root_logger_call.rs",
            "description": "This file implements a linting rule (`LOG015`) for the `flake8_logging` plugin that identifies and flags direct calls to top-level `logging` functions, which use the root logger and lack source information.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_logging/snapshots",
            "description": "This directory stores snapshot test files for the `flake8_logging` rules within the `ruff_linter` crate. These snapshots are used to verify that the linter's output for logging-related issues remains consistent across changes. They act as a reference for expected diagnostics or code transformations.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_pie/mod.rs",
            "description": "This file serves as the main module for the `flake8-pie` rules within the ruff linter, containing the module declaration for the rules and their associated unit tests.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_pie/rules/unnecessary_range_start.rs",
            "description": "This file implements a `ruff` linting rule (PIE808) that identifies and fixes unnecessary `start` arguments of `0` in `range()` calls, converting `range(0, x)` to `range(x)`.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_pie/rules/reimplemented_container_builtin.rs",
            "description": "This file implements a lint rule (PIE807) in Ruff that detects and suggests replacing redundant lambda expressions (e.g., `lambda: []`, `lambda: {}`) with their direct container built-in equivalents (`list`, `dict`).",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_pie/rules/mod.rs",
            "description": "This file serves as a module aggregator for the `flake8_pie` rules, declaring and re-exporting individual linting rules defined in separate files within the same directory.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_pie/rules/duplicate_class_field_definition.rs",
            "description": "This file implements a rule for the Ruff linter that detects and reports duplicate field definitions within Python class bodies. It also provides an unsafe fix to remove the redundant field definition.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_pie/rules/unnecessary_spread.rs",
            "description": "This file implements a linter rule to detect and fix unnecessary dictionary unpacking (`**`) when the unpacked element is a dictionary literal, simplifying expressions like `{**foo, **{'C': 3}}` to `{**foo, 'C': 3}`.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_pie/rules/multiple_starts_ends_with.rs",
            "description": "This file implements a linting rule (PIE810) that identifies and merges multiple `startswith` or `endswith` calls on the same object, connected by `or` operators, into a single call with a tuple argument. Its purpose is to improve code efficiency and readability by consolidating these string operations.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_pie/rules/non_unique_enums.rs",
            "description": "This file defines a linter rule for Ruff (PIE796) that detects and reports non-unique values within Python `enum.Enum` classes. It identifies assignments in enum bodies and checks for duplicate assigned values, excluding `enum.auto()` and unknown values in stub files.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_pie/rules/unnecessary_placeholder.rs",
            "description": "This file implements a linting rule (PIE790) that detects and suggests removing unnecessary `pass` statements or ellipsis literals (`...`) in Python code blocks. It provides a fix, noting potential unsafety if a string literal would become a docstring upon removal.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_pie/rules/unnecessary_dict_kwargs.rs",
            "description": "Implements a linting rule to identify and fix unnecessary dictionary unpacking for keyword arguments in Python function calls, converting `func(**{\"key\": value})` to `func(key=value)` when appropriate. It checks for valid identifiers and handles potential duplicate keyword arguments and fix safety concerns regarding comments.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_pie/snapshots",
            "description": "This directory is used to store snapshots for testing the `flake8_pie` linter rules within the `ruff_linter` crate. These snapshots serve as reference outputs for snapshot tests, ensuring the linter rules produce expected results and preventing regressions.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_unused_arguments/mod.rs",
            "description": "This file serves as the module entry point for the `flake8-unused-arguments` rule set within the `ruff_linter`, defining the submodules and containing unit tests for these argument-related rules.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_unused_arguments/rules/mod.rs",
            "description": "This `mod.rs` file serves as a module entry point, re-exporting rules related to 'unused arguments' from its `unused_arguments` submodule, making them accessible within the `flake8_unused_arguments` crate.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_unused_arguments/rules/unused_arguments.rs",
            "description": "This file defines the rules and implementation for detecting and reporting unused arguments in various Python constructs (functions, methods, lambdas) as part of the `flake8-unused-arguments` linter in Ruff.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_unused_arguments/snapshots",
            "description": "This directory contains test snapshots for the `flake8_unused_arguments` rule within the `ruff_linter` crate. These snapshots are used by testing frameworks to ensure the rule's output or behavior remains consistent across code changes, preventing regressions.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_executable/helpers.rs",
            "description": "This file provides a helper function, `is_executable`, which checks if a given file path has executable permissions on Unix-like operating systems.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_executable/mod.rs",
            "description": "This module implements and tests linting rules derived from flake8-executable, specifically addressing issues with shebangs in executable files.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_executable/rules/shebang_not_executable.rs",
            "description": "Defines a lint rule (`EXE001`) that checks if a file containing a shebang directive is executable, reporting a violation if it is not. This rule is specific to Unix-like systems.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_executable/rules/shebang_missing_python.rs",
            "description": "This file defines a lint rule (EXE003) for Ruff that checks if a Python file's shebang line explicitly specifies a Python interpreter or related execution command, reporting a violation if it doesn't.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_executable/rules/shebang_missing_executable_file.rs",
            "description": "This file implements a lint rule (EXE002) that detects executable Python files on Unix-like systems that are missing a shebang. It reports a diagnostic when such files are found, encouraging users to add a shebang or remove the executable bit.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_executable/rules/shebang_leading_whitespace.rs",
            "description": "This file implements a linter rule (EXE004) that detects and automatically fixes leading whitespace before a shebang directive in Python source code. It ensures the shebang is at the very beginning of the file to be correctly interpreted.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_executable/rules/mod.rs",
            "description": "This file serves as the main entry point for linting various aspects of shebang directives in Python files, dispatching checks for issues like missing Python interpreter, executability, leading whitespace, and incorrect placement. It aggregates and orchestrates several shebang-related rule checks within the `flake8_executable` linter.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_executable/rules/shebang_not_first_line.rs",
            "description": "This file implements a lint rule (EXE005) that detects and reports shebang directives in Python files that are not located on the very first line, which would cause them to be ignored by the system.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_executable/snapshots",
            "description": "This directory is intended to store snapshot test data for the `flake8_executable` linter rule within the `ruff_linter` crate. These snapshots would typically verify the expected output or behavior of the rule's diagnostics or fixes. Its current empty state indicates that no snapshots are presently defined or generated for this specific rule.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_commas/mod.rs",
            "description": "This module integrates and organizes rules from the `flake8-commas` plugin into ruff_linter, specifically providing the main module definition and test cases for these comma-related linting rules.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_commas/rules/mod.rs",
            "description": "This file serves as the module entry point for the `flake8_commas` rules, primarily re-exporting the `trailing_commas` rule implementation.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_commas/rules/trailing_commas.rs",
            "description": "This file implements the `flake8-commas` rules for the Ruff linter, detecting and fixing issues related to trailing commas in Python code. It checks for missing trailing commas, prohibits them in bare tuples, and flags other unnecessary trailing commas based on context.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_commas/snapshots",
            "description": "This directory stores test snapshots specifically for the `flake8_commas` rule within the `ruff_linter` crate. These snapshots are crucial for regression testing, ensuring that the rule's output and behavior remain consistent across development cycles.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_raise/mod.rs",
            "description": "This file serves as the main module for integrating `flake8-raise` rules into the `ruff_linter`, containing test cases for these rules.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_raise/rules/unnecessary_paren_on_raise_exception.rs",
            "description": "This Rust file defines a lint rule within the `ruff_linter` crate that detects and fixes unnecessary parentheses when raising exceptions without arguments, such as `raise TypeError()` instead of `raise TypeError`.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_raise/rules/mod.rs",
            "description": "This file serves as the module entry point for the `flake8_raise` rules, specifically re-exporting and organizing the `unnecessary_paren_on_raise_exception` rule.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_raise/snapshots",
            "description": "This directory is intended to store snapshot test files for the `flake8_raise` rule within the `ruff_linter` crate. These snapshots capture expected code transformations or diagnostic outputs, ensuring consistent behavior of the linter rule over time.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_simplify/mod.rs",
            "description": "This module integrates and organizes the rules from the `flake8-simplify` linter into Ruff, including their implementation in the `rules` submodule and comprehensive test cases.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_simplify/rules/mod.rs",
            "description": "This file serves as the main module for the `flake8_simplify` rules in the Ruff linter, re-exporting individual rule implementations from its submodules. It aggregates and exposes various simplification rules for Python code.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_simplify/rules/collapsible_if.rs",
            "description": "This file implements the Ruff linter rule `SIM102` (CollapsibleIf), which identifies and provides a fix for nested `if` statements that can be combined into a single `if` statement using an `and` operator to improve readability.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_simplify/rules/yoda_conditions.rs",
            "description": "This file implements a linter rule to detect and fix 'Yoda conditions' in Python code, where a constant appears on the left side of a comparison operator. It includes logic to determine the 'constant likelihood' of expressions and provides a fix to reverse the comparison for improved readability.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_simplify/rules/ast_with.rs",
            "description": "This file implements a Ruff lint rule (SIM117) that detects unnecessarily nested Python `with` statements. It suggests combining them into a single `with` statement to improve readability and reduce indentation, while exempting specific context managers.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_simplify/rules/enumerate_for_loop.rs",
            "description": "Implements a lint rule (SIM113) that detects `for` loops where an index variable is manually incremented and suggests using Python's `enumerate()` function instead. It includes checks for various conditions like variable initialization, scope, and usage.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_simplify/rules/ast_ifexp.rs",
            "description": "This file defines and implements lint rules for simplifying `if` expressions in Python code, such as replacing `True if x else False` with `bool(x)` or `False if x else True` with `not x`, and reordering 'twisted' conditional arms.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_simplify/rules/ast_expr.rs",
            "description": "This file implements two linting rules for the `flake8_simplify` category in Ruff: one for ensuring environment variables are capitalized (SIM112) and another for removing redundant `None` defaults in `dict.get()` calls (SIM910).",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_simplify/rules/key_in_dict.rs",
            "description": "This file implements the `SIM118` lint rule, which identifies and fixes inefficient key-existence checks like `key in dict.keys()` by suggesting `key in dict`. It handles various contexts such as comparisons, `for` loops, and comprehensions, with fix safety depending on type inference.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_simplify/rules/if_else_block_instead_of_dict_get.rs",
            "description": "This file implements a linter rule (SIM401) that identifies and suggests replacing `if/else` statements or `if/else` expressions with more concise `dict.get()` calls for dictionary key lookups.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_simplify/rules/zip_dict_keys_and_values.rs",
            "description": "This file implements a Ruff lint rule (SIM911) that detects and fixes the use of `zip(dict.keys(), dict.values())`. It recommends replacing this pattern with the more efficient `dict.items()`.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_simplify/rules/suppressible_exception.rs",
            "description": "Implements a Ruff linting rule (SIM105) that identifies `try`-`except`-`pass` blocks and suggests replacing them with the `contextlib.suppress` context manager for improved conciseness.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_simplify/rules/fix_with.rs",
            "description": "This file implements a fix for the `SIM117` rule, converting nested `with` statements (e.g., `with a: with b:`) into a single, combined `with` statement (`with a, b:`).",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_simplify/rules/reimplemented_builtin.rs",
            "description": "This file implements a linting rule that identifies and refactors `for` loops which can be replaced by Python's built-in `any()` or `all()` functions for improved conciseness and readability.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_simplify/rules/if_else_block_instead_of_if_exp.rs",
            "description": "This file implements a lint rule (SIM108) for the Ruff linter, which detects and suggests refactoring `if-else` blocks that assign a value to a variable in both branches into more concise ternary or binary conditional expressions in Python code.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_simplify/rules/if_with_same_arms.rs",
            "description": "This file implements a linting rule (SIM114) that identifies `if` and `elif` branches with identical code bodies. It provides a fix to merge these branches by combining their conditions using a logical `or` operator to improve code readability and conciseness.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_simplify/rules/open_file_with_context_handler.rs",
            "description": "Implements a linter rule (SIM115) that checks for instances where files or other I/O resources are opened without using a context manager, promoting resource safety.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_simplify/rules/needless_bool.rs",
            "description": "This file implements the `NeedlessBool` (SIM103) rule for the Ruff linter, which identifies and suggests refactoring `if` statements that explicitly return `True` or `False` based on a condition, recommending a direct return of the condition's boolean value instead.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_simplify/rules/return_in_try_except_finally.rs",
            "description": "This file implements a linting rule (SIM107) that detects and flags the use of `return` statements within `try`-`except` and `finally` blocks, especially when a `finally` return would override a `try` or `except` return. It helps prevent unexpected behavior due to the `finally` block's execution guarantee.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_simplify/rules/if_else_block_instead_of_dict_lookup.rs",
            "description": "Implements a linter rule (SIM116) that identifies and flags consecutive `if-elif` statements returning values based on a variable's literal comparisons, suggesting they be refactored into a dictionary lookup for simplification.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_simplify/rules/ast_unary_op.rs",
            "description": "This file implements linter rules (SIM201, SIM202, SIM208) for the Ruff linter, focusing on simplifying boolean expressions by replacing negated comparison operators and removing double negations in Python code.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_simplify/rules/split_static_string.rs",
            "description": "This file implements a Ruff linting rule (SIM905) that identifies static `str.split()` and `str.rsplit()` calls. It suggests replacing these calls with more readable and efficient Python list literals, providing a fix where applicable and safe.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_simplify/rules/ast_bool_op.rs",
            "description": "This file defines and implements several linting rules for simplifying Python boolean operations and related expressions, such as `isinstance` calls and equality comparisons, within the `flake8-simplify` family of the Ruff linter.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_simplify/snapshots",
            "description": "This directory is intended to store test snapshots for the `flake8_simplify` rules within the `ruff_linter` crate. These snapshots likely serve as 'golden files' for asserting the expected output or behavior of the linter rules during testing.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/mccabe/mod.rs",
            "description": "This file serves as the main module for the McCabe complexity rules within the ruff linter, defining and organizing its rules, settings, and associated tests.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/src/rules/mccabe/rules/mod.rs",
            "description": "This file serves as the module entry point for McCabe complexity rules, re-exporting the `function_is_too_complex` rule for use within the `ruff_linter` crate.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/mccabe/snapshots",
            "description": "This directory is intended to store snapshot test data for the McCabe complexity rule within the `ruff_linter` crate. It holds expected output or AST representations used for comparison during testing to ensure rule consistency.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_tidy_imports/rules/relative_imports.rs",
            "description": "This file implements a linting rule for the `flake8-tidy-imports` plugin to detect and optionally fix relative imports in Python code. It flags imports that violate configured strictness levels and can convert them to absolute imports.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pycodestyle/helpers.rs",
            "description": "Provides helper functions for linting Python code, specifically for identifying ambiguous names and non-logical tokens.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pycodestyle/overlong.rs",
            "description": "This file defines logic for detecting and representing 'overlong' lines in Python code, particularly for the `pycodestyle` rules within the `ruff` linter. It measures line width, handles tab sizes, and intelligently strips comments or ignores specific line types (like URLs or SPDX headers) before determining if a line exceeds a configured length limit.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/src/rules/pycodestyle/mod.rs",
            "description": "This module serves as the entry point for Ruff's implementation of pycodestyle rules. It defines the module structure for pycodestyle rules, settings, and helpers, and includes extensive test cases for verifying the correct application of these linting rules.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pycodestyle/rules/ambiguous_function_name.rs",
            "description": "This Rust file defines a lint rule (`E743`) for Ruff that identifies and reports ambiguous function names (e.g., 'l', 'O', 'I') in Python code, which can be easily confused with numbers. It provides the violation structure, message formatting, and the checking logic.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/src/rules/pycodestyle/rules/module_import_not_at_top_of_file.rs",
            "description": "This file implements a lint rule (E402) for Ruff that enforces Python imports to be placed at the top of the file or Jupyter notebook cell, in accordance with PEP 8 guidelines. It identifies and reports violations where imports appear after other module-level statements.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pycodestyle/rules/missing_newline_at_end_of_file.rs",
            "description": "This file implements a lint rule (W292) for Ruff that checks for and fixes the absence of a newline character at the end of a file. It defines the `MissingNewlineAtEndOfFile` violation and provides a function to detect and automatically add the missing newline.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pycodestyle/rules/bare_except.rs",
            "description": "This file defines and implements a linting rule (E722) for Ruff that checks for the use of bare `except` statements in Python's `try`-`except` blocks.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pycodestyle/rules/line_too_long.rs",
            "description": "Implements the `E501` 'Line too long' rule for the Ruff linter, checking Python code for lines exceeding a specified character limit while accounting for various exceptions and configuration settings.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pycodestyle/rules/ambiguous_variable_name.rs",
            "description": "This file implements a linter rule that detects and reports the use of ambiguous single-character variable names (specifically 'l', 'O', and 'I') in Python code, except for stub files. These names are considered ambiguous due to their visual similarity to numerals in some fonts.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pycodestyle/rules/too_many_newlines_at_end_of_file.rs",
            "description": "This file implements the `W391` rule, which detects and fixes instances of too many blank lines at the end of a file or a notebook cell. It ensures that files and cells conclude with a single trailing newline.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pycodestyle/rules/whitespace_after_decorator.rs",
            "description": "This file implements a linter rule (E204) to detect and fix whitespace immediately following the '@' symbol in Python decorators, adhering to PEP 8 guidelines.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pycodestyle/rules/ambiguous_class_name.rs",
            "description": "This file defines and implements a linting rule for `pycodestyle` that checks for ambiguous Python class names, specifically single-character names like 'l', 'O', or 'I', which can be confused with numerals.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/src/rules/pycodestyle/rules/mixed_spaces_and_tabs.rs",
            "description": "This file implements a Ruff linter rule (E101) that detects and reports Python code lines with mixed spaces and tabs in their leading indentation.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/src/rules/pycodestyle/rules/mod.rs",
            "description": "This file serves as the module root for Pycodestyle rules within the Ruff linter, aggregating and re-exporting individual rule implementations.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pycodestyle/rules/tab_indentation.rs",
            "description": "This file implements a linter rule (W191) to detect and report instances of tab characters being used for indentation in Python source code, adhering to PEP 8 guidelines.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pycodestyle/rules/multiple_imports_on_one_line.rs",
            "description": "This file implements a linter rule (E401) in Ruff that detects and fixes multiple Python import statements declared on a single line, splitting them into separate lines for better code style according to PEP 8.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pycodestyle/rules/not_tests.rs",
            "description": "This file implements linting rules for Python code, specifically detecting and fixing unidiomatic 'not in' and 'is not' comparisons (e.g., `not X in Y` should be `X not in Y`, and `not X is Y` should be `X is not Y`) to improve readability and conform to PEP8.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pycodestyle/rules/compound_statements.rs",
            "description": "This file defines and implements linting rules for Python compound statements, detecting issues like multiple statements on a single line (separated by colon or semicolon) and unnecessary trailing semicolons, in accordance with PEP 8.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pycodestyle/rules/trailing_whitespace.rs",
            "description": "Implements linter rules to detect and fix trailing whitespace and whitespace on blank lines in Python code, adhering to PEP 8 guidelines.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pycodestyle/rules/blank_lines.rs",
            "description": "Implements a collection of linting rules for enforcing PEP 8 blank line conventions in Python code, including checks for missing, extraneous, or incorrect numbers of blank lines between code elements like methods, functions, and classes.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pycodestyle/rules/invalid_escape_sequence.rs",
            "description": "This file implements a Ruff linter rule (W605) to detect and fix invalid escape sequences in Python string literals, including f-strings and raw strings. It suggests either adding a backslash to the invalid sequence or converting the entire string to a raw string literal.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pycodestyle/rules/lambda_assignment.rs",
            "description": "Implements a linter rule (E731) that identifies and suggests fixes for direct assignment of `lambda` expressions to variables, recommending conversion to `def` statements for improved clarity and debuggability.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pycodestyle/rules/literal_comparisons.rs",
            "description": "This file implements `pycodestyle` rules E711 and E712, which detect and suggest fixes for incorrect or discouraged comparisons of Python expressions with `None`, `True`, or `False` literals using equality operators (`==` or `!=`) instead of identity operators (`is` or `is not`).",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pycodestyle/rules/type_comparison.rs",
            "description": "Implements a linter rule (E721) that flags direct type comparisons using `==` or `!=` instead of `is`, `is not`, or `isinstance()`, with an exception for NumPy `dtype` comparisons.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pycodestyle/rules/logical_lines/whitespace_before_parameters.rs",
            "description": "This file implements a linting rule (E211) that checks for and fixes extraneous whitespace immediately preceding an open parenthesis or bracket in Python code, adhering to PEP 8 guidelines.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pycodestyle/rules/logical_lines/indentation.rs",
            "description": "This file defines and implements several linting rules for Python code and comment indentation, primarily checking for PEP 8 compliance related to indentation levels and multiples.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/src/rules/pycodestyle/rules/logical_lines/extraneous_whitespace.rs",
            "description": "This file implements rules (E201, E202, E203) to detect and fix extraneous whitespace around parentheses, brackets, braces, commas, semicolons, and colons in Python code, adhering to PEP 8 guidelines.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pycodestyle/rules/logical_lines/missing_whitespace.rs",
            "description": "This file implements a linter rule that detects and fixes missing whitespace after commas, semicolons, and colons in Python code, with specific exceptions for contexts like f-strings and slice syntax.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pycodestyle/rules/logical_lines/whitespace_before_comment.rs",
            "description": "This file implements linting rules for Python comments, ensuring correct whitespace formatting before and after `#` characters for both inline and block comments according to PEP 8 standards.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pycodestyle/rules/logical_lines/missing_whitespace_around_operator.rs",
            "description": "This file defines and implements multiple pycodestyle rules (E225, E226, E227, E228) for the Ruff linter, which check for and fix missing whitespace around various types of operators in Python code.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pycodestyle/rules/logical_lines/whitespace_around_keywords.rs",
            "description": "Implements pycodestyle checks for extraneous whitespace (multiple spaces or tabs) around keywords in Python code. It detects these violations and provides autofixes to replace them with a single space.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/src/rules/pycodestyle/rules/logical_lines/missing_whitespace_after_keyword.rs",
            "description": "This file implements a linter rule (E275) for Ruff that identifies and automatically fixes missing whitespace characters immediately following Python keywords, based on pycodestyle guidelines.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pycodestyle/rules/logical_lines/redundant_backslash.rs",
            "description": "Implements the `pycodestyle` rule E502 to detect and fix redundant backslashes used for line continuation within bracketed expressions in Python code, as recommended by PEP 8.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pycodestyle/rules/logical_lines/whitespace_around_named_parameter_equals.rs",
            "description": "This file implements Ruff's pycodestyle rules E251 and E252, which check and fix whitespace around the equals sign in named function parameters according to PEP 8, distinguishing between annotated and unannotated parameters.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/src/rules/pycodestyle/rules/logical_lines/space_around_operator.rs",
            "description": "Implements Ruff linting rules for Pycodestyle (E22x, E24x) to enforce correct spacing around operators and after commas, specifically detecting and fixing extraneous tabs or multiple spaces.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/src/rules/pycodestyle/snapshots",
            "description": "This directory is designated to store snapshot test files for the `pycodestyle` linting rules within the `ruff_linter` crate. These snapshots capture expected outputs or AST representations, used for regression testing to ensure rule changes do not introduce unintended alterations to diagnostic messages or fixes.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flynt/mod.rs",
            "description": "This file defines the `flynt` rules module for the Ruff linter, importing helper functions and the main rule definitions. It also includes the integration tests for these rules, specifically testing `FLY002.py`.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/src/rules/flynt/helpers.rs",
            "description": "This file provides helper functions for the `flynt` rule in Ruff, primarily focused on converting Python Abstract Syntax Tree (AST) expressions into interpolated string elements for f-string formatting. It includes utilities to determine if an expression represents a 'simple' call or callee, ensuring safe conversion to f-string components.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flynt/rules/mod.rs",
            "description": "This file serves as a module aggregator for the 'flynt/rules' directory, re-exporting the `static_join_to_fstring` module to make its contents publicly available within the crate.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flynt/rules/static_join_to_fstring.rs",
            "description": "Implements a linting rule (FLY002) that identifies and suggests replacing `str.join` calls with f-strings for improved readability, providing an automatic fix for such cases.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flynt/snapshots",
            "description": "This directory is intended to store test snapshots for the `flynt` rule within the `ruff_linter` crate. These snapshots capture expected outputs or states, facilitating regression testing by comparing current results against these stored references.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pep8_naming/settings.rs",
            "description": "This file defines the configuration settings and error types for the `pep8-naming` linter plugin, including how to handle ignored naming patterns using glob matching.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/src/rules/pep8_naming/mod.rs",
            "description": "This file is the main module for the `pep8-naming` rules within the Ruff linter, defining and organizing the naming convention checks. It also contains extensive unit tests to validate the implementation of these rules.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pep8_naming/helpers.rs",
            "description": "This file provides helper functions for `ruff_linter`'s `pep8_naming` rules, including utilities for checking Python naming conventions and identifying specific typing-related constructs or common patterns like Django model imports within the AST.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pep8_naming/rules/camelcase_imported_as_acronym.rs",
            "description": "This Rust file defines a lint rule for the Ruff linter, specifically `CamelcaseImportedAsAcronym`, which detects and flags `CamelCase` imports that are aliased as acronyms. It includes logic to ignore names based on user configuration or established import conventions.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pep8_naming/rules/constant_imported_as_non_constant.rs",
            "description": "Implements a lint rule that checks for Python constants imported with an alias that does not follow constant naming conventions, as recommended by PEP 8.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pep8_naming/rules/lowercase_imported_as_non_lowercase.rs",
            "description": "This file implements a linting rule (N812) that detects when a lowercase import is aliased to a non-lowercase name, as this violates PEP 8 naming conventions. It provides the logic to identify and report such naming inconsistencies in Python code.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pep8_naming/rules/mod.rs",
            "description": "This file aggregates and exports individual Rust modules, each defining a specific PEP8 naming convention rule for the `ruff_linter`.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/src/rules/pep8_naming/rules/camelcase_imported_as_lowercase.rs",
            "description": "Implements a linting rule (N813) that detects and flags Python `CamelCase` imports aliased to `lowercase` names, promoting consistent naming conventions as per PEP 8.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pep8_naming/rules/camelcase_imported_as_constant.rs",
            "description": "This file defines a lint rule (N814) for the Ruff linter that detects and flags Python imports where a CamelCase-named object is aliased to a constant-style name, enforcing PEP 8 naming conventions.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pep8_naming/rules/mixed_case_variable_in_global_scope.rs",
            "description": "This file implements a `ruff` linter rule (N816) that checks for global variable names using `mixedCase` convention, flagging them as violations of PEP 8 which recommends `snake_case` for global variables.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pep8_naming/rules/invalid_class_name.rs",
            "description": "This file implements a linting rule (`N801`) for Ruff that checks if Python class names adhere to the `CapWords` (CamelCase) convention as recommended by PEP 8.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pep8_naming/rules/dunder_function_name.rs",
            "description": "This file implements a linter rule (N807) that checks for Python functions with 'dunder' names (e.g., `__my_function__`) that are not explicitly documented or allowed, enforcing PEP 8 guidelines.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pep8_naming/rules/error_suffix_on_exception_name.rs",
            "description": "Defines a lint rule (N818) for Ruff that checks if custom Python exception classes are named with an 'Error' suffix, as recommended by PEP 8.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pep8_naming/rules/invalid_function_name.rs",
            "description": "This file implements a linting rule that checks for Python function names which do not follow the `snake_case` naming convention as recommended by PEP 8, while also handling specific exceptions like `@typing.override` decorated methods or special methods in certain base classes.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pep8_naming/rules/invalid_first_argument_name.rs",
            "description": "This file implements linter rules (N804, N805) to check for incorrect naming of the first argument in Python instance methods (expected `self`) and class methods (expected `cls`) according to PEP 8. It defines violations and provides autofix capabilities for these naming conventions.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pep8_naming/rules/mixed_case_variable_in_class_scope.rs",
            "description": "This file defines a linting rule (N815) that identifies and reports class variable names written in `mixedCase`, recommending the use of `snake_case` as per PEP 8 guidelines.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pep8_naming/rules/invalid_module_name.rs",
            "description": "This file implements a linting rule to detect Python module names that violate PEP 8 naming conventions or are otherwise invalid. It checks module names for adherence to `snake_case` and other identifier rules, with special handling for migration files.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pep8_naming/rules/non_lowercase_variable_in_function.rs",
            "description": "Defines a linting rule (N806) for Ruff that checks for and reports the use of non-lowercase variable names within function scopes, enforcing PEP 8 naming conventions.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pep8_naming/rules/invalid_argument_name.rs",
            "description": "Implements the Ruff rule N803, which checks for argument names in Python functions and lambdas that do not follow the `snake_case` convention as recommended by PEP 8.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pep8_naming/snapshots",
            "description": "This directory stores snapshot test files specifically for the `pep8_naming` rules within the `ruff_linter` crate. These snapshots serve as reference outputs to validate the behavior and correctness of the PEP8 naming convention checks during testing.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_todos/mod.rs",
            "description": "This file serves as the main module for the `flake8_todos` rule set in the Ruff linter. It defines the module structure and includes unit tests for all the specific `flake8_todos` rules, ensuring their correct functionality.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_todos/rules/mod.rs",
            "description": "This file re-exports the rules defined in the `todos` module for the `flake8_todos` linter. It serves as an entry point for accessing the flake8_todos rules.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_todos/rules/todos.rs",
            "description": "This file defines and implements various linting rules for ensuring proper formatting and content of 'TODO' comments in Python code, including checks for tags, authors, links, capitalization, and punctuation. It's part of the `flake8_todos` plugin within the Ruff linter.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_todos/snapshots",
            "description": "This directory stores snapshot test files for the `flake8_todos` linting rule within the `ruff_linter` crate. These snapshots define the expected output or behavior of the rule, used for regression testing to ensure consistent linting results.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_use_pathlib/mod.rs",
            "description": "This file serves as the main module for the `flake8-use-pathlib` rules within the Ruff linter. It defines the module structure, including submodules for helpers, rules, and violations, and contains extensive test cases for these rules.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_use_pathlib/violations.rs",
            "description": "This file defines a series of linter violations for the `flake8_use_pathlib` rule in Ruff, encouraging the use of Python's `pathlib` module for path manipulation over legacy `os` module functions or the `py.path` library.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_use_pathlib/helpers.rs",
            "description": "Provides helper functions for Ruff's `flake8_use_pathlib` rules, primarily for identifying `pathlib.Path` objects, checking argument properties, and transforming `os.path` calls into `pathlib` equivalents.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_use_pathlib/rules/glob_rule.rs",
            "description": "This file defines a linter rule (`Glob`) for the `flake8_use_pathlib` plugin, which detects and flags the use of `glob.glob()` and `glob.iglob()` functions, suggesting their replacement with `Path.glob()` or `Path.rglob()` for improved code readability and adherence to `pathlib` conventions.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_use_pathlib/rules/os_path_abspath.rs",
            "description": "This file implements a Ruff lint rule (PTH100) that flags the use of `os.path.abspath()` in Python code, recommending its replacement with `pathlib.Path.resolve()` for better path manipulation. It includes detailed explanations for the rule's rationale, examples, and the safety implications of the suggested fix.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_use_pathlib/rules/os_path_getctime.rs",
            "description": "This Rust file implements a lint rule for Ruff, specifically `PTH205`, which identifies uses of `os.path.getctime` and suggests replacing them with `Path.stat().st_ctime` for improved readability and adherence to `pathlib` conventions.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_use_pathlib/rules/os_path_basename.rs",
            "description": "Implements a linting rule for Ruff that identifies and suggests replacing `os.path.basename()` calls with `pathlib.Path.name`. It also provides an unsafe fix for this refactoring.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_use_pathlib/rules/os_path_exists.rs",
            "description": "This file implements a linting rule that identifies and suggests replacing `os.path.exists()` calls with `pathlib.Path(...).exists()` for improved code readability and consistency.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_use_pathlib/rules/builtin_open.rs",
            "description": "This file implements a linting rule (PTH123) in Ruff that detects uses of the built-in `open()` function and suggests replacing them with `Path.open()` from the `pathlib` module for improved readability and consistency. It includes logic to generate fixes, handle import statements, and determine fix applicability.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_use_pathlib/rules/os_path_expanduser.rs",
            "description": "This file implements a lint rule (PTH111) for the `ruff` linter that identifies and suggests replacing `os.path.expanduser()` calls with `pathlib.Path.expanduser()`. It includes diagnostic messages, fix suggestions, and details on potential issues and fix safety.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_use_pathlib/rules/os_path_getsize.rs",
            "description": "Implements a linter rule (PTH202) that identifies and suggests replacements for `os.path.getsize` calls with `pathlib`'s `Path.stat().st_size` equivalent.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_use_pathlib/rules/mod.rs",
            "description": "This module serves as a central entry point for all `flake8_use_pathlib` linting rules, re-exporting individual rule implementations that encourage the use of `pathlib` over the `os` module for path manipulations.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_use_pathlib/rules/os_getcwd.rs",
            "description": "This file implements a linter rule that flags uses of `os.getcwd()` and `os.getcwdb()` and suggests replacing them with `Path.cwd()` for improved readability and `pathlib` integration. It also provides an automatic fix, considering safety implications like type changes and comment preservation.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_use_pathlib/rules/os_rmdir.rs",
            "description": "This file implements a Ruff linting rule (PTH106) that detects and suggests replacing `os.rmdir()` calls with their `pathlib.Path.rmdir()` equivalents for improved readability and consistency.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_use_pathlib/rules/os_mkdir.rs",
            "description": "Implements a linting rule that flags `os.mkdir()` calls and provides a fix to replace them with `pathlib.Path.mkdir()` for improved readability and Pythonic style.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_use_pathlib/rules/os_path_getmtime.rs",
            "description": "Implements a linting rule (PTH204) for the Ruff linter that detects and suggests replacing `os.path.getmtime` calls with `pathlib.Path().stat().st_mtime` for improved readability and consistency.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_use_pathlib/rules/os_path_isabs.rs",
            "description": "This file implements a linter rule (PTH117) that identifies and suggests replacing `os.path.isabs()` calls with `Path.is_absolute()` for improved readability and consistency with `pathlib`.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_use_pathlib/rules/os_path_samefile.rs",
            "description": "This file defines a lint rule (PTH121) that identifies and suggests replacing `os.path.samefile()` calls with their `pathlib.Path.samefile()` equivalents for improved readability, offering an automatic fix.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_use_pathlib/rules/os_remove.rs",
            "description": "This file implements a linter rule (PTH107) for `flake8-use-pathlib` that identifies and suggests replacing `os.remove()` calls with `pathlib.Path.unlink()`, considering the `dir_fd` argument for applicability.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_use_pathlib/rules/os_path_isfile.rs",
            "description": "This file defines a lint rule for Ruff (PTH113) that flags `os.path.isfile()` calls, suggesting they be replaced with `pathlib.Path.is_file()` for improved readability and consistency.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_use_pathlib/rules/invalid_pathlib_with_suffix.rs",
            "description": "This file implements a linting rule (PTH210) for Ruff that checks for incorrect usage of `pathlib.Path.with_suffix()` in Python code, specifically when the suffix is missing a leading dot or is a single dot in older Python versions.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_use_pathlib/rules/os_unlink.rs",
            "description": "This file implements a lint rule (PTH108) that detects uses of `os.unlink()` in Python code and suggests replacing them with `Path.unlink()` from the `pathlib` module for improved readability.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_use_pathlib/rules/os_path_dirname.rs",
            "description": "This file implements a linting rule for Ruff that identifies and flags uses of `os.path.dirname`. It suggests replacing these calls with `pathlib.Path.parent` and provides an unsafe fix, noting potential semantic differences and return type changes.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_use_pathlib/rules/path_constructor_current_directory.rs",
            "description": "Implements a lint rule (PTH201) that detects and fixes `pathlib.Path` constructors explicitly passed the current directory (`.`), as this argument is redundant. It suggests removing the explicit argument to `Path()`.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_use_pathlib/rules/os_symlink.rs",
            "description": "This file defines a linting rule for the Ruff linter, specifically `PTH211`, which identifies and offers to fix usages of `os.symlink` by replacing them with the equivalent `pathlib.Path.symlink_to` method.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_use_pathlib/rules/replaceable_by_pathlib.rs",
            "description": "This file implements linter rules to identify code patterns from the `os`, `glob`, and `py.path` modules that can be replaced by more modern and convenient `pathlib` equivalents, reporting diagnostics for such usages.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_use_pathlib/rules/os_readlink.rs",
            "description": "This file implements a linting rule for the `flake8_use_pathlib` plugin, detecting `os.readlink()` calls and suggesting their replacement with `Path.readlink()` from the `pathlib` module. It includes logic for fix applicability and Python version compatibility.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_use_pathlib/rules/os_path_getatime.rs",
            "description": "This file implements a linter rule to detect and fix occurrences of `os.path.getatime` in Python code, suggesting replacement with `Path.stat().st_atime` from the `pathlib` module.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_use_pathlib/rules/os_makedirs.rs",
            "description": "This file implements a lint rule that identifies and automatically fixes `os.makedirs()` calls, replacing them with the equivalent `pathlib.Path.mkdir(parents=True)` method for improved readability and consistency.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_use_pathlib/rules/os_chmod.rs",
            "description": "This file implements a linting rule for the Ruff linter, identifying instances where `os.chmod()` is used and providing a fix to replace it with the `Path.chmod()` method from the `pathlib` module for improved readability and consistency.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_use_pathlib/rules/os_path_isdir.rs",
            "description": "Defines a linting rule for the Ruff linter that identifies and suggests replacing `os.path.isdir()` calls with the `pathlib.Path.is_dir()` method, including a suggested fix.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_use_pathlib/rules/os_sep_split.rs",
            "description": "This file defines a lint rule (PTH206) that flags the use of `.split(os.sep)` for path manipulation, recommending replacement with `pathlib.Path.parts` for improved code clarity and standard library usage.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_use_pathlib/rules/os_rename.rs",
            "description": "Implements a linting rule for Ruff that identifies and suggests replacing `os.rename()` calls with `pathlib.Path.rename()` for improved readability and consistency with `pathlib` usage.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_use_pathlib/rules/os_path_islink.rs",
            "description": "This file implements a Ruff linter rule that detects usage of `os.path.islink()` and suggests replacing it with the `Path.is_symlink()` method from the `pathlib` module for improved readability and consistency.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_use_pathlib/rules/os_replace.rs",
            "description": "Implements a linting rule for Ruff that detects uses of `os.replace()` and suggests replacing them with `Path.replace()` for improved readability and `pathlib` integration.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_use_pathlib/snapshots",
            "description": "This directory is intended to store snapshot test files for the `flake8_use_pathlib` rule within the `ruff_linter` crate. These snapshots capture expected output or behavior, enabling efficient regression testing. Its current emptiness suggests that no snapshots have been generated or committed yet for this specific rule.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pyflakes/mod.rs",
            "description": "This file serves as the main module for integrating Pyflakes rules into the Ruff linter. It defines sub-modules for various Pyflakes rule categories, their fixes, and settings, and includes extensive test cases for these rules.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pyflakes/cformat.rs",
            "description": "This file defines `CFormatSummary` to parse and summarize C-style format strings, extracting information about positional arguments, keyword arguments, and starred (dynamic width/precision) specifications. It helps analyze the argument requirements of such format strings.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/src/rules/pyflakes/format.rs",
            "description": "This file implements helper functions for parsing Python format strings using the vendored `format.rs` module. It defines a `FormatSummary` struct to extract and categorize fields (auto-numbered, indexed, keyword) within a format string, including nested parts.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/src/rules/pyflakes/rules/assert_tuple.rs",
            "description": "This file implements a `ruff` linter rule (F631, `AssertTuple`) that detects `assert` statements using non-empty tuples as their test condition, as such expressions are always `True` and indicate a likely bug.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pyflakes/rules/f_string_missing_placeholders.rs",
            "description": "This file implements a lint rule that identifies f-strings without any placeholder expressions and provides a fix to convert them into regular strings.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pyflakes/rules/unused_annotation.rs",
            "description": "This file defines the `UnusedAnnotation` lint rule (F842) for Ruff, which detects and reports local variables in Python code that are type-annotated but never used.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pyflakes/rules/undefined_export.rs",
            "description": "This file defines a `ruff` linting rule, `UndefinedExport`, which detects and flags names in a Python module's `__all__` variable that are not defined within the module itself.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pyflakes/rules/if_tuple.rs",
            "description": "Implements a linting rule for Ruff that detects `if` statements with non-empty tuple test conditions, which always evaluate to `True` and are likely unintentional. This rule is part of the Pyflakes checks.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pyflakes/rules/invalid_literal_comparisons.rs",
            "description": "This file implements a Ruff rule (F632) that identifies and fixes `is` and `is not` comparisons used with constant literals or mutable iterable initializers in Python code. It promotes the use of `==` and `!=` for value-based comparisons instead of identity comparisons.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pyflakes/rules/default_except_not_last.rs",
            "description": "This file implements a linting rule (F707) that checks for `except` blocks handling all exceptions (`except:`) that are not positioned as the last handler in a `try` statement, which would lead to unreachable code and a `SyntaxError`.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pyflakes/rules/redefined_while_unused.rs",
            "description": "Implements the `F811` (RedefinedWhileUnused) lint rule, which detects and flags variable redefinitions where the original variable was unused. It also provides a fix to remove such redundant definitions.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/src/rules/pyflakes/rules/forward_annotation_syntax_error.rs",
            "description": "This file implements a linting rule to detect and report syntax errors within string-quoted forward type annotations in Python code. It defines the `ForwardAnnotationSyntaxError` violation and its message format.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pyflakes/rules/future_feature_not_defined.rs",
            "description": "Defines a linting rule for Ruff that detects `__future__` imports not supported in the current Python version. It identifies and reports such undefined future features as a violation.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pyflakes/rules/mod.rs",
            "description": "This file serves as the main module for the Pyflakes rules in the Ruff linter, aggregating and re-exporting individual rule implementations defined in separate sub-modules.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pyflakes/rules/repeated_keys.rs",
            "description": "This file implements rules for detecting and reporting repeated keys in Python dictionary literals, distinguishing between literal and variable keys. It identifies cases where dictionary keys are duplicated, causing earlier values to be overwritten, and provides unsafe fixes.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pyflakes/rules/invalid_print_syntax.rs",
            "description": "This file defines a lint rule for Ruff that identifies and flags Python 2-style `print` statements using the `>>` syntax, which is invalid in Python 3. It provides guidance on modern alternatives like the `file` argument or `sys.stderr.write`.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pyflakes/rules/undefined_name.rs",
            "description": "This file defines the `UndefinedName` lint rule for Ruff's Pyflakes linter, which detects and reports uses of undefined names in Python code. It also provides the associated violation message, including a tip for built-in names.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pyflakes/rules/unused_import.rs",
            "description": "This file implements a linter rule for Ruff that detects and suggests fixes for unused import statements in Python code. It handles various contexts, including `__init__.py` files, and offers different fix strategies.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/src/rules/pyflakes/rules/raise_not_implemented.rs",
            "description": "This file implements a Ruff linter rule (`F901`) that detects and fixes instances where `NotImplemented` is raised directly, instead suggesting the use of `NotImplementedError`.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pyflakes/rules/strings.rs",
            "description": "This file defines various linting rules and violations related to `printf`-style string formatting (using the `%` operator) in Python, specifically for the `pyflakes` ruleset within the Ruff linter.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pyflakes/rules/undefined_local.rs",
            "description": "This file implements the `UndefinedLocal` (F823) lint rule, which detects and reports instances where a local variable is referenced before it has been assigned, often involving shadowing of parent scope variables.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pyflakes/rules/starred_expressions.rs",
            "description": "This file defines and implements linting rules for Python, specifically checking for incorrect usage of starred expressions in assignment statements, such as multiple starred expressions or an excessive number of expressions in a starred unpack.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pyflakes/rules/imports.rs",
            "description": "This file implements several linting rules related to Python imports within the Pyflakes category of the Ruff linter, addressing issues such as shadowed imports, incorrect wildcard import usage, and misplaced `__future__` imports.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pyflakes/rules/unused_variable.rs",
            "description": "This file implements a Ruff linter rule (`F841`) to detect and fix unused local variables in Python code, providing suggestions for removing assignments or marking variables with a dummy prefix.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pyflakes/snapshots",
            "description": "This directory contains snapshot files used for testing the `pyflakes` rules within the `ruff_linter` crate. These snapshots capture expected outputs or AST structures to ensure rule behavior remains consistent across changes.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/perflint/mod.rs",
            "description": "This file serves as the main module for the `perflint` rule set in the Ruff linter, importing helper modules and defining the integration tests for these performance-related linting rules.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/perflint/helpers.rs",
            "description": "This file contains helper functions for the `perflint` rules, including utilities for extracting comment strings and calculating the appropriate text range to delete a statement, considering semicolons that might separate multiple statements on a single line.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/src/rules/perflint/rules/try_except_in_loop.rs",
            "description": "This file implements a `perflint` rule (PERF203) for the ruff linter. It identifies and flags `try`-`except` blocks used within loops in Python code (pre-3.11) as a potential performance overhead.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/perflint/rules/mod.rs",
            "description": "This file serves as the main module for the `perflint` rule set in Ruff, re-exporting and organizing individual performance-related linting rules.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/perflint/rules/incorrect_dict_iterator.rs",
            "description": "This file implements a `perflint` rule (`PERF102`) that checks for inefficient dictionary iterations where `dict.items()` is used but only the keys or values are accessed. It suggests replacing `.items()` with `.keys()` or `.values()` for better performance and clarity.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/perflint/rules/manual_list_copy.rs",
            "description": "Implements a lint rule (PERF402) that detects `for` loops used for manually copying a list and suggests using more efficient methods like `list()` or `list.copy()` instead. It identifies patterns where `append` or `insert` is used within a loop to recreate a list, promoting better performance and readability.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/perflint/rules/unnecessary_list_cast.rs",
            "description": "This file implements a `ruff` lint rule (`PERF101: UnnecessaryListCast`) that identifies and fixes inefficient `list()` casts on already-iterable types (like tuples, lists, or sets) used as iterables in `for` loops. It includes logic to avoid applying the fix if the iterable variable is mutated within the loop body.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/perflint/rules/manual_dict_comprehension.rs",
            "description": "Implements a `perflint` rule for the Ruff linter that identifies `for` loops which can be converted into more performant and readable dictionary comprehensions or `dict.update` calls. It provides a fix to automatically refactor these loops.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/perflint/rules/manual_list_comprehension.rs",
            "description": "Implements a linting rule for Ruff that identifies `for` loops appending to a list and suggests replacing them with list comprehensions or `list.extend` for improved performance and readability.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/src/rules/perflint/snapshots",
            "description": "This directory stores snapshot test files for the `perflint` rules within the `ruff_linter` crate. These snapshots capture the expected output or behavior of the performance-related linting rules, ensuring consistency and preventing regressions during development.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/tryceratops/mod.rs",
            "description": "This file serves as the main module for the `tryceratops` rule set within the Ruff linter. It organizes the rule implementations, helper functions, and includes unit tests for these rules.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/tryceratops/helpers.rs",
            "description": "This file defines a visitor (`LoggerCandidateVisitor`) that traverses the Abstract Syntax Tree (AST) to identify and collect calls to logging functions, categorizing them by their respective logging levels. It's used for static analysis to find logging-related expressions within Python code.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/tryceratops/rules/reraise_no_cause.rs",
            "description": "This file defines a removed Ruff linting rule (`TRY200`, ReraiseNoCause) which checked for exceptions re-raised without specifying a cause via the `from` keyword. It has been replaced by rule B904.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/tryceratops/rules/raise_within_try.rs",
            "description": "This file implements the `TRY301` linter rule for Ruff, which identifies and flags `raise` statements within `try` blocks that raise exceptions handled by the same `try` statement, suggesting refactoring for improved code clarity and reusability.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/tryceratops/rules/useless_try_except.rs",
            "description": "This file implements a lint rule (`UselessTryExcept`, code TRY203) that detects and flags redundant `try-except` blocks where an exception handler immediately re-raises the caught exception without performing any other actions. It identifies cases like `except Exception: raise` or `except Exception as e: raise e` as unnecessary.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/src/rules/tryceratops/rules/error_instead_of_exception.rs",
            "description": "Implements the `TRY400` rule for Ruff, which detects and fixes `logging.error` calls used instead of `logging.exception` within exception handlers to ensure proper logging of tracebacks.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/tryceratops/rules/try_consider_else.rs",
            "description": "This file defines a lint rule (TRY300) that identifies `return` statements at the end of `try` blocks, suggesting they be moved to an `else` block for improved code clarity and to prevent unexpected behavior.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/tryceratops/rules/verbose_raise.rs",
            "description": "This file implements the `VerboseRaise` (TRY201) rule, which identifies and fixes redundant exception names in `raise` statements within `except` blocks when an exception is being re-raised.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/tryceratops/rules/mod.rs",
            "description": "This file serves as a module aggregator, re-exporting individual lint rules for the `tryceratops` plugin within the `ruff_linter` crate.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/tryceratops/rules/raise_vanilla_args.rs",
            "description": "Implements a linter rule (TRY003) that detects and flags instances where exception messages are formatted directly at the `raise` call site instead of being encapsulated within the exception class's `__init__` method. It aims to promote consistent exception messages and reusable exception classes.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/tryceratops/rules/verbose_log_message.rs",
            "description": "Implements a linting rule (TRY401) to detect and flag redundant exception objects included in `logging.exception` calls. It ensures that exception objects are not explicitly passed as arguments when `logging.exception` implicitly handles them.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pylint/mod.rs",
            "description": "This file serves as the main module for integrating Pylint rules into the Ruff linter, organizing sub-modules for rule definitions, helpers, and settings. It also contains comprehensive unit tests to validate the implementation of these Pylint-based rules.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pylint/helpers.rs",
            "description": "This file provides helper functions and a visitor for analyzing Python code, primarily for `pylint` rules within the `ruff` linter, focusing on dunder methods and sequence indexing patterns.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pylint/rules/and_or_ternary.rs",
            "description": "Defines a placeholder for the `AndOrTernary` linter rule (PLR1706), which was removed from Ruff. This rule historically flagged pre-Python 2.5 `and`/`or` ternary syntax, recommending modern `if-else` expressions instead.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pylint/rules/bad_open_mode.rs",
            "description": "This file implements a linter rule (PLW1501) that detects and reports invalid file open modes in `open()` calls, including both built-in `open` and `pathlib.Path.open`.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pylint/rules/bad_staticmethod_argument.rs",
            "description": "Implements a Pylint rule (PLW0211) that detects and flags static methods or `__new__` methods that incorrectly use `self` or `cls` as their first argument.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pylint/rules/dict_index_missing_items.rs",
            "description": "Implements a Pylint rule (PLC0206) that detects inefficient or unclear dictionary iterations where values are accessed via explicit indexing instead of the more Pythonic and efficient `.items()` method.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/src/rules/pylint/rules/binary_op_exception.rs",
            "description": "Implements the `PLW0711` (BinaryOpException) lint rule, which detects and flags `except` clauses attempting to catch multiple exceptions using binary operations like `and` or `or`.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pylint/rules/iteration_over_set.rs",
            "description": "This file implements a Pylint rule (`PLC0208`) that detects and fixes inefficient iteration over set literals containing only literal values, suggesting conversion to a more efficient sequence type like a tuple.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pylint/rules/global_at_module_level.rs",
            "description": "Implements a Pylint rule (PLW0604) that flags redundant `global` keyword usage at the module level in Python code, as names are already global by default in that scope.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pylint/rules/dict_iter_missing_items.rs",
            "description": "This file implements a Ruff lint rule (PLE1141) that detects and suggests a fix for dictionary unpacking in `for` loops without calling `.items()`, while also handling cases where dictionary keys are two-element tuples.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/src/rules/pylint/rules/bidirectional_unicode.rs",
            "description": "This file defines a linter rule to detect and report the presence of Unicode bidirectional control characters in source code. These characters can be used to obfuscate code or introduce security vulnerabilities.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pylint/rules/continue_in_finally.rs",
            "description": "Implements a linter rule (PLE0116) that detects `continue` statements illegally placed inside `finally` blocks in Python code. It reports a violation when such a statement is found.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pylint/rules/collapsible_else_if.rs",
            "description": "This file implements a lint rule (PLR5501) that detects `else` blocks containing a single `if` statement and provides a fix to convert them into `elif` clauses to improve code readability and reduce indentation.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pylint/rules/bad_str_strip_call.rs",
            "description": "This file defines a linting rule (PLE1310) that flags `str.strip`, `str.lstrip`, or `str.rstrip` calls in Python code when the argument contains duplicate characters. It suggests using `str.removeprefix` or `str.removesuffix` for Python 3.9+ as more explicit alternatives for certain cases.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/src/rules/pylint/rules/empty_comment.rs",
            "description": "This file implements a Pylint rule (PLR2044) to detect and fix empty comments in Python code. It identifies lines where a '#' symbol is not followed by any actual comment text, offering a fix to delete such comments.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pylint/rules/bad_dunder_method_name.rs",
            "description": "This file implements a Pylint linting rule (PLW3201) that identifies Python dunder methods which are either misspelled or have no special meaning in Python 3, excluding known or explicitly allowed dunder methods and those marked with `@override`.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pylint/rules/import_self.rs",
            "description": "This file implements a Pylint rule (PLW0406) for the Ruff linter, which detects and reports Python modules that attempt to import themselves. Such self-imports indicate a circular dependency and lead to `ImportError` exceptions.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/src/rules/pylint/rules/compare_to_empty_string.rs",
            "description": "This file defines a linter rule (`PLC1901`) for Ruff that identifies and flags direct comparisons to empty strings (e.g., `x == \"\"`), recommending simplification to truthiness checks (e.g., `not x`).",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pylint/rules/global_statement.rs",
            "description": "Implements a Pylint-style rule that identifies and reports on the discouraged use of `global` statements to update variables within functions. It checks for global variable modifications and generates a diagnostic message.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pylint/rules/global_variable_not_assigned.rs",
            "description": "This file implements a Ruff linter rule (PLW0602) that detects global variables declared with the `global` keyword within a function's scope but are never assigned a new value, flagging them as redundant.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/src/rules/pylint/rules/invalid_bytes_return.rs",
            "description": "Implements a `ruff` linter rule to detect `__bytes__` methods that do not return a `bytes` object, ensuring correct Python special method behavior. It analyzes return statements and infers their types to identify violations.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pylint/rules/invalid_index_return.rs",
            "description": "This file implements a Pylint rule (PLE0305) that checks if Python's `__index__` special method returns an integer value, reporting a diagnostic if it returns a non-integer type or implicitly returns `None`.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pylint/rules/comparison_of_constant.rs",
            "description": "This file defines a linter rule (PLR0133) in Rust that detects and reports comparisons between two constant values in Python code. It flags such comparisons as redundant, suggesting they should be replaced with their evaluated boolean result.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pylint/rules/invalid_length_return.rs",
            "description": "This file implements a lint rule (PLE0303) that checks Python's `__len__` special method to ensure it returns a non-negative integer, flagging incorrect return types or negative integer values.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pylint/rules/assert_on_string_literal.rs",
            "description": "This file implements a Pylint rule (PLW0129) that detects and reports `assert` statements whose test condition is a string, byte, or f-string literal, highlighting potential issues with always-true or always-false assertions.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pylint/rules/load_before_global_declaration.rs",
            "description": "This file implements a Ruff linting rule (`LoadBeforeGlobalDeclaration`) that identifies and flags Python code where a name is used prior to its `global` declaration within the same scope, which is a `SyntaxError`.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/src/rules/pylint/rules/nonlocal_and_global.rs",
            "description": "Implements a Pylint rule (PLE0115) for Ruff that detects and reports Python variables declared as both `nonlocal` and `global` within the same scope, which is a `SyntaxError`.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pylint/rules/literal_membership.rs",
            "description": "This file implements a Ruff rule (PLR6201) that detects and suggests fixing membership tests (`in` or `not in`) involving `list` or `tuple` literals. It recommends converting these to `set` literals for improved performance, while also including checks to prevent unsafe fixes for unhashable types.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pylint/rules/invalid_string_characters.rs",
            "description": "This file implements a Pylint rule to detect and fix unescaped invalid control characters (like backspace, null, and zero-width space) in Python string literals, replacing them with their escape sequences.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pylint/rules/bad_string_format_type.rs",
            "description": "This file implements a Ruff lint rule (PLE1307) that checks for type mismatches when using Python's old-style C-format strings. It ensures that format specifiers like '%d' or '%s' are compatible with the data types of the arguments provided.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pylint/rules/magic_value_comparison.rs",
            "description": "This file implements the Pylint rule `PLR2004`, which detects and flags the use of 'magic' (unnamed) literal values in comparison expressions within Python code. It encourages replacing such values with named constants for better readability and maintainability.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pylint/rules/import_private_name.rs",
            "description": "This file implements a linter rule (PLC2701) in Ruff that detects and reports imports of private names (starting with an underscore) from external modules in Python code, while ignoring certain cases like dunder names or type-checking-only imports.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pylint/rules/manual_import_from.rs",
            "description": "This file implements a Pylint rule (PLR0402) that detects and suggests fixing Python import statements like `import module.submodule as submodule` to the more concise `from module import submodule`.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pylint/rules/bad_string_format_character.rs",
            "description": "This file implements a Ruff linter rule (PLE1300) that detects and reports the use of invalid or unsupported format characters in Python string formatting, covering both `.format()` calls and C-style `%` formatting.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pylint/rules/comparison_with_itself.rs",
            "description": "This file implements a Pylint rule (PLR0124) in the Ruff linter, detecting and reporting instances where a variable or the result of a pure function call with a variable is compared to itself.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pylint/rules/invalid_all_format.rs",
            "description": "Implements a linting rule for Ruff that detects and reports invalid assignments to Python's `__all__` variable, ensuring it is a tuple or list of strings.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/src/rules/pylint/rules/nan_comparison.rs",
            "description": "This file implements a Pylint rule (PLW0177) in Rust for the Ruff linter, detecting and flagging direct comparisons with NaN values in Python code. It suggests using `math.isnan` or `numpy.isnan` instead, as direct comparisons can lead to unexpected results.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pylint/rules/misplaced_bare_raise.rs",
            "description": "This file implements the Pylint rule `PLE0704` for Ruff, which detects bare `raise` statements used outside of an exception handler. It ensures that `raise` without an argument is only used to re-raise an active exception.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pylint/rules/logging.rs",
            "description": "This file implements Pylint rules (PLE1205 and PLE1206) that check for incorrect argument counts in Python `logging` calls. It detects cases where a logging format string has too many or too few positional arguments compared to the provided values.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pylint/rules/missing_maxsplit_arg.rs",
            "description": "This file defines a lint rule for Ruff that identifies inefficient string splitting operations (e.g., `str.split()[0]`) and suggests adding the `maxsplit=1` argument for optimization. It also provides an automatic fix for these cases.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pylint/rules/duplicate_bases.rs",
            "description": "This file implements a linter rule (PLE0241) that identifies and offers a fix for duplicate base classes in Python class definitions. It detects redundant entries in a class's base list, which would otherwise cause a `TypeError` at runtime.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pylint/rules/return_in_init.rs",
            "description": "This file implements a lint rule (`PLE0101`) for the `ruff` linter. It detects and flags `__init__` methods in Python code that explicitly return a value other than `None`, as this leads to a runtime error.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pylint/rules/modified_iterating_set.rs",
            "description": "This file implements a Pylint-related rule (PLE4703) for the Ruff linter, detecting and fixing cases where a Python set is modified while being iterated over within a `for` loop.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pylint/rules/boolean_chained_comparison.rs",
            "description": "This file implements a Pylint rule (`PLR1716`) for the Ruff linter, which detects and fixes chained boolean comparisons (e.g., `a < b and b < c`) that can be simplified into a single comparison expression (e.g., `a < b < c`). It identifies patterns like `A < B and B < C` and provides a fix to refactor them for improved readability.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pylint/rules/redefined_argument_from_local.rs",
            "description": "This file implements a Pylint rule (PLR1704) for the Ruff linter, detecting when a function argument is inadvertently redefined by a local variable within constructs like `for`, `try`, or `with` statements.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/src/rules/pylint/rules/redefined_loop_name.rs",
            "description": "This file implements a Ruff rule (`RedefinedLoopName`) that detects and flags instances where loop variables in `for` or `with` statements are redefined or overwritten within their own body, which can lead to unexpected behavior due to Python's scoping rules.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pylint/rules/repeated_isinstance_calls.rs",
            "description": "This file defines the `RepeatedIsinstanceCalls` rule (PLR1701), which identifies and provides fixes for merging repeated `isinstance` calls on the same object. The rule has since been removed and replaced by SIM101.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pylint/rules/invalid_str_return.rs",
            "description": "This file implements a Pylint rule (PLE0307) that checks Python's `__str__` methods to ensure they correctly return a string type, reporting a violation if a non-string or implicit `None` is returned.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pylint/rules/potential_index_error.rs",
            "description": "Implements a lint rule that detects and reports hard-coded, out-of-bounds index accesses on Python list and tuple literals, which are likely to raise an `IndexError` at runtime.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pylint/rules/nested_min_max.rs",
            "description": "Implements a linter rule (PLW3301) for Ruff that detects and offers to flatten nested `min()` or `max()` function calls in Python code, aiming to improve readability.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pylint/rules/property_with_parameters.rs",
            "description": "This file implements a linting rule (PLR0206) for the Ruff linter that detects and flags Python properties defined with function parameters, as properties cannot accept arguments.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pylint/rules/non_ascii_module_import.rs",
            "description": "This file implements a linter rule (PLC2403) for Ruff that detects and flags import statements containing non-ASCII characters in module names or aliases, to prevent compatibility issues.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pylint/rules/non_augmented_assignment.rs",
            "description": "This file implements a Pylint rule that detects assignments (e.g., `x = x + 1`) that can be rewritten as more concise augmented assignments (e.g., `x += 1`) and provides an unsafe fix for them.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pylint/rules/too_many_positional_arguments.rs",
            "description": "This file implements a Pylint rule (PLR0917) that checks for Python functions with an excessive number of positional arguments. It identifies and flags functions that exceed a configurable limit, while also handling exemptions for overridden or overloaded methods.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pylint/rules/no_self_use.rs",
            "description": "Implements a linter rule (PLR6301) that detects Python methods where the `self` parameter is defined but unused, suggesting they could be static methods, class methods, or regular functions. It includes logic to exempt methods that are overridden, abstract, or already static/class methods.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pylint/rules/mod.rs",
            "description": "This file serves as the module entry point for Pylint-style rules within the Ruff linter, declaring and re-exporting individual linting rule modules for use in the linter.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pylint/rules/unspecified_encoding.rs",
            "description": "This file implements a Pylint rule (PLW1514) in Ruff that detects uses of `open` and similar functions without an explicit `encoding` argument, aiming to prevent non-portable code behavior.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pylint/rules/single_string_slots.rs",
            "description": "This file implements a Pylint rule (PLC0205) in Rust that detects when Python's `__slots__` attribute is assigned a single string instead of a non-string iterable, which can lead to confusion and incorrect behavior. It provides a diagnostic for such cases.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pylint/rules/invalid_bool_return.rs",
            "description": "This file implements a Ruff linter rule (`PLE0304`) that checks Python's `__bool__` methods to ensure they correctly return a boolean value, flagging any return statements that yield non-boolean types or implicitly return `None`.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pylint/rules/too_many_statements.rs",
            "description": "This file implements the Pylint rule `PLR0915` (TooManyStatements) for the Ruff linter, which identifies functions or methods exceeding a configured maximum number of statements by counting them within the Python abstract syntax tree.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pylint/rules/repeated_equality_comparison.rs",
            "description": "Implements a lint rule that identifies and fixes repeated equality comparisons (e.g., `x == 'a' or x == 'b'`) by transforming them into more efficient membership tests (e.g., `x in {'a', 'b'}`). It determines whether to use a set or a tuple based on the hashability of the compared values.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pylint/rules/non_ascii_name.rs",
            "description": "Defines a Pylint rule for the Ruff linter that detects and reports the use of non-ASCII characters in Python identifier names, such as variable, function, or class names. It also provides a suggested fix to rename them using only ASCII characters.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pylint/rules/too_many_locals.rs",
            "description": "This file implements the Pylint rule `PLR0914`, which detects functions containing too many local variables. It reports a diagnostic if the number of local variables exceeds a configurable maximum.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pylint/rules/too_many_branches.rs",
            "description": "This file implements the `TooManyBranches` (`PLR0912`) rule for Ruff's Pylint linter, which identifies functions or methods with excessive branching complexity. It includes the logic for counting branches (like if/else, for loops, try/except, and match statements) and reporting violations.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pylint/rules/invalid_hash_return.rs",
            "description": "This file implements a linting rule for Ruff that checks Python's `__hash__` methods. It flags instances where `__hash__` returns a value that is not an integer, ensuring proper type adherence for hashing operations.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pylint/rules/stop_iteration_return.rs",
            "description": "This file implements a Pylint linter rule (PLR1708) in Rust for Ruff. It detects and flags explicit `raise StopIteration` statements within Python generator functions, suggesting `return` as the correct alternative.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pylint/rules/non_slot_assignment.rs",
            "description": "Implements a Ruff Linter rule (PLE0237) that detects assignments to attributes not declared in a class's `__slots__` within Python code, reporting them as `NonSlotAssignment` violations.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pylint/rules/self_assigning_variable.rs",
            "description": "This file implements a lint rule (PLW0127) in the Ruff linter that detects and reports instances of a variable being assigned to itself, which is considered redundant and a potential error. It handles both simple assignments and annotated assignments, including tuple destructuring, while ignoring assignments within class bodies.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pylint/rules/too_many_boolean_expressions.rs",
            "description": "This file implements a Pylint rule (PLR0916) for the Ruff linter that detects and reports `if` or `elif` statements containing an excessive number of boolean expressions. It helps improve code readability by enforcing a configurable limit on boolean expressions within conditional statements.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pylint/rules/redefined_slots_in_subclass.rs",
            "description": "Implements a linter rule (PLW0244) that detects and flags cases where a Python subclass redefines a `__slots__` member that is already present in one of its base classes, which can lead to inaccessible instance variables.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pylint/rules/singledispatchmethod_function.rs",
            "description": "This file defines a lint rule (`PLE1520`) in the `ruff` linter that identifies and flags the incorrect usage of the `@singledispatchmethod` decorator on non-method functions, suggesting `@singledispatch` as an alternative.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pylint/rules/redeclared_assigned_name.rs",
            "description": "This file implements a Pylint rule (PLW0128) that identifies and flags redundant assignments where the same variable is assigned multiple times within a single Python assignment statement.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pylint/rules/singledispatch_method.rs",
            "description": "Implements a lint rule (`PLE1519`) that detects the incorrect use of `@singledispatch` on methods, suggesting replacement with `@singledispatchmethod` or migration to a standalone function.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pylint/rules/useless_else_on_loop.rs",
            "description": "This file implements a lint rule (PLW0120) that detects and fixes `else` clauses on loops (for, while) that do not contain a `break` statement, as such clauses are redundant. It provides a fix to remove the `else` keyword and dedent its body.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pylint/rules/unnecessary_direct_lambda_call.rs",
            "description": "Implements a lint rule that detects and reports unnecessary direct calls to lambda expressions, recommending inline execution for improved readability.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pylint/rules/yield_from_in_async_function.rs",
            "description": "This file defines a linting rule for Pylint in Ruff, specifically detecting and flagging the invalid use of `yield from` statements within asynchronous Python functions, suggesting `async for` as an alternative.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pylint/rules/unnecessary_lambda.rs",
            "description": "Implements a Ruff lint rule (PLW0108) that detects and suggests fixes for unnecessary Python lambda expressions which simply wrap a function call with identical arguments.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pylint/rules/too_many_return_statements.rs",
            "description": "This file implements the Pylint rule `PLR0911` (TooManyReturnStatements) for the Ruff linter, which identifies and flags Python functions or methods containing more return statements than a configured maximum. It includes a utility to count return statements within a given code block and the logic for reporting violations.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pylint/rules/unexpected_special_method_signature.rs",
            "description": "This file implements a linter rule in Ruff that checks Python special methods (dunder methods) for unexpected or incorrect function signatures, ensuring they adhere to expected parameter counts.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pylint/rules/repeated_keyword_argument.rs",
            "description": "Implements a Pylint rule (PLE1132) to detect and report repeated keyword arguments in Python function calls, including those passed via dictionary unpacking.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pylint/rules/too_many_public_methods.rs",
            "description": "Implements the Pylint rule `PLR0904` to detect Python classes with an excessive number of public methods, reporting a diagnostic if the count exceeds a configured maximum.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pylint/rules/too_many_nested_blocks.rs",
            "description": "This file implements the `PLR1702` Pylint rule for Ruff, which detects and flags functions or methods with an excessive number of nested control flow blocks (e.g., if, while, for, try, with statements) to improve code readability and maintainability. The maximum allowed nesting level is configurable.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pylint/rules/len_test.rs",
            "description": "Implements a lint rule (PLC1802) that detects and suggests fixes for `len()` calls used as boolean conditions on sequence types in Python code. It checks for `len(sequence)` in `if` or `while` statements and proposes to simplify it to just `sequence`.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pylint/rules/no_method_decorator.rs",
            "description": "This file implements Pylint rules (PLR0202, PLR0203) for the Ruff linter, detecting and fixing class methods and static methods defined via assignment rather than using the `@classmethod` or `@staticmethod` decorators. It ensures consistent and readable method declarations in Python code.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pylint/rules/unnecessary_dunder_call.rs",
            "description": "This file implements a lint rule for Ruff to detect and suggest replacements for unnecessary explicit calls to Python dunder methods (e.g., `__add__` or `__str__`) with their equivalent operators or built-in functions.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pylint/rules/useless_with_lock.rs",
            "description": "This file implements a Pylint linter rule (PLW2101) to detect and flag `with` statements in Python code that directly create and use threading lock objects, which is an ineffective practice.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pylint/rules/yield_in_init.rs",
            "description": "This file implements a Pylint rule (PLE0100) that detects `__init__` methods in Python classes that contain `yield` or `yield from` expressions, incorrectly turning them into generators.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pylint/rules/unnecessary_dict_index_lookup.rs",
            "description": "This file implements a Pylint rule (PLR1733) in Ruff that detects and fixes unnecessary dictionary index lookups when iterating over `dict.items()`. It identifies cases where a dictionary value is accessed via its key (`dict[key]`) inside a loop where the value is already available as a separate loop variable.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pylint/rules/unreachable.rs",
            "description": "This file implements a Pylint rule for the Ruff linter that detects and reports unreachable Python code within functions. It analyzes the control flow graph of a function to identify code blocks that can never be executed.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pylint/rules/useless_exception_statement.rs",
            "description": "Implements a lint rule (PLW0133) in Ruff that detects Python statements where an exception is created but not raised, which typically indicates a mistake as the statement has no effect. It offers a fix to add the `raise` keyword.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pylint/rules/useless_import_alias.rs",
            "description": "This file implements the `UselessImportAlias` rule (Pylint PLC0414) for Ruff, detecting and flagging Python import aliases that do not change the original name of the imported module or member. It includes logic to handle `__init__.py` files and `isort` configurations which might make such aliases intentional.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pylint/rules/unnecessary_list_index_lookup.rs",
            "description": "This file implements a Pylint rule (PLR1736) that detects and fixes unnecessary list index lookups within `enumerate` loops or comprehensions in Python code. It suggests using the directly available loop variable instead of re-indexing the sequence.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pylint/rules/sys_exit_alias.rs",
            "description": "This file implements a Ruff linter rule (PLR1722) that identifies and flags direct calls to `exit()` or `quit()`, recommending the use of `sys.exit()` instead. It also provides an unsafe fix to replace these calls.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pylint/rules/too_many_arguments.rs",
            "description": "This file implements the Pylint rule PLR0913, which identifies Python functions with an excessive number of arguments, while accounting for method types and decorator-based exemptions like `@typing.override`.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pylint/rules/self_or_cls_assignment.rs",
            "description": "This file implements a Pylint rule (PLW0642) in Ruff that detects and flags reassignments of the conventional `self` or `cls` parameters within Python instance, class, or `__new__` methods, aiming to improve code readability.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pylint/rules/useless_return.rs",
            "description": "This file implements a Pylint rule (PLR1711) in Ruff that detects and fixes unnecessary `return` or `return None` statements at the end of Python functions, as Python implicitly returns `None`.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pylint/rules/subprocess_popen_preexec_fn.rs",
            "description": "This file implements a Ruff linter rule that detects and flags the use of the `preexec_fn` argument in `subprocess.Popen` calls within Python code, as it is considered unsafe in multithreaded environments and is targeted for deprecation.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pylint/snapshots",
            "description": "This directory stores snapshot test files for the Pylint rules within the `ruff_linter` crate. These snapshots capture the expected output or diagnostic messages generated by the Pylint-compatible linting rules, ensuring consistent behavior during testing and development.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/ruff/helpers.rs",
            "description": "Provides helper functions for the Ruff linter to semantically analyze Python class definitions, including detecting special attributes, various dataclass types, and specific class behaviors.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/ruff/mod.rs",
            "description": "This file serves as the main module for defining and testing Ruff-specific linting rules within the `ruff_linter` crate. It orchestrates the inclusion of various rule implementations and contains comprehensive test cases for each rule.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/ruff/rules/collection_literal_concatenation.rs",
            "description": "This file implements a Ruff rule (RUF005) that identifies and suggests replacing collection concatenations using the `+` operator with more efficient iterable unpacking (e.g., `[*a, *b]`). It includes logic for recursively converting binary operations into a single list or tuple literal with splats.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/ruff/rules/access_annotations_from_class_dict.rs",
            "description": "This file implements a Ruff linting rule (RUF063) that identifies and flags direct access to `__annotations__` via `__dict__.get()` or `__dict__[\"__annotations__\"]`. It suggests using dedicated functions like `annotationlib.get_annotations`, `inspect.get_annotations`, or `typing_extensions.get_annotations` for better compatibility and stability across Python versions.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/src/rules/ruff/rules/asyncio_dangling_task.rs",
            "description": "This file implements a linter rule (RUF006) for Ruff that detects `asyncio.create_task` and `asyncio.ensure_future` calls whose return values are not stored, preventing premature garbage collection of asynchronous tasks.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/ruff/rules/ambiguous_unicode_character.rs",
            "description": "This file defines and implements rules for the `ruff` linter to detect ambiguous Unicode characters in Python strings, docstrings, and comments. It identifies visually similar Unicode characters that could lead to confusion or subtle bugs.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/src/rules/ruff/rules/assert_with_print_message.rs",
            "description": "This file implements a lint rule (RUF030) that identifies and fixes `assert` statements where `print()` is used as the assertion message, which results in an empty `AssertionError`. It extracts the arguments from the `print()` call to form the new assertion message.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/ruff/rules/dataclass_enum.rs",
            "description": "Implements a linting rule (RUF049) for the Ruff linter that detects and flags Python classes incorrectly decorated as both a dataclass and an enum.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/src/rules/ruff/rules/falsy_dict_get_fallback.rs",
            "description": "This file defines a lint rule (RUF056) that detects and fixes `dict.get(key, falsy_value)` calls used in boolean test positions, recommending removal of the redundant falsy fallback as `None` is already falsy. It includes logic to identify such patterns and generate an autofix.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/ruff/rules/decimal_from_float_literal.rs",
            "description": "Implements a linter rule (RUF032) that detects `Decimal()` constructor calls using float literals, which can lead to precision issues. It provides a fix to replace the float literal with its string representation.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/ruff/rules/default_factory_kwarg.rs",
            "description": "This file implements a Ruff linting rule (RUF026) that identifies and suggests fixes for incorrect usage of `default_factory` as a keyword argument when initializing `collections.defaultdict`.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/ruff/rules/invalid_assert_message_literal_argument.rs",
            "description": "This file implements a lint rule (RUF040) that identifies and reports `assert` statements where a non-string literal is used as the assertion message, indicating a likely programming error.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/ruff/rules/if_key_in_dict_del.rs",
            "description": "Implements a linter rule (RUF051) that identifies and fixes the anti-pattern of using `if key in dict: del dict[key]` by suggesting the more concise `dict.pop(key, None)`.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/src/rules/ruff/rules/duplicate_entry_in_dunder_all.rs",
            "description": "Implements a linter rule (RUF068) to detect and fix duplicate entries in Python's `__all__` definitions, covering assignments and `extend` calls. It provides a fix that is marked unsafe if comments are attached to the removed duplicate.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/src/rules/ruff/rules/indented_form_feed.rs",
            "description": "Implements a lint rule (RUF054) to detect and report form feed characters that are preceded by spaces or tabs in Python source code, as these have an undefined effect on indentation.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/ruff/rules/explicit_f_string_type_conversion.rs",
            "description": "This file implements a linter rule for Ruff that detects explicit `str()`, `repr()`, or `ascii()` calls within f-strings and suggests replacing them with more idiomatic f-string conversion flags (e.g., `!s`, `!r`, `!a`). It also provides an automatic fix for this issue.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/src/rules/ruff/rules/invalid_index_type.rs",
            "description": "This file implements the `RUF016` linter rule, which detects invalid index types used for accessing Python sequences (lists, tuples, strings, bytes, and comprehensions) and slices. It ensures that only integers or valid slice components are used as indices.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/ruff/rules/quadratic_list_summation.rs",
            "description": "This file defines a Ruff rule (RUF017) that detects and flags quadratic list summations (e.g., `sum(lists, [])`) in Python code. It provides an unsafe fix to replace these inefficient operations with a `functools.reduce` call for improved performance.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/ruff/rules/map_int_version_parsing.rs",
            "description": "This file implements a Ruff linting rule (`RUF048`) that identifies and flags the use of `map(int, __version__.split(\".\"))` for parsing version strings. It warns against potential `ValueError` exceptions due to non-integer version components and suggests using `packaging.version.parse()` instead.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/src/rules/ruff/rules/static_key_dict_comprehension.rs",
            "description": "This file defines the `RuffStaticKeyDictComprehension` violation, which identifies dictionary comprehensions that use a static key. It details the rule's purpose, why it's considered bad practice, and provides examples.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/ruff/rules/function_call_in_dataclass_default.rs",
            "description": "This file implements a linting rule (RUF009) for Ruff that checks for and flags function calls used as default values in dataclass attribute definitions. It aims to prevent unexpected shared mutable state across dataclass instances.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/ruff/rules/logging_eager_conversion.rs",
            "description": "This file defines a lint rule (RUF065) for Ruff that identifies and flags unnecessary eager string conversions (e.g., `str()`, `repr()`, `hex()`) in arguments to Python `logging` calls, suggesting more efficient formatting alternatives.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/ruff/rules/sort_dunder_all.rs",
            "description": "This file implements a Ruff linter rule that checks for unsorted `__all__` definitions in Python code and provides a fix to sort them in an 'isort-style' order.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/src/rules/ruff/rules/mutable_dataclass_default.rs",
            "description": "This file implements the `MutableDataclassDefault` (RUF008) linting rule for Ruff. It detects and flags mutable default values in Python dataclass attributes, which can lead to unexpected shared state issues.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/ruff/rules/sequence_sorting.rs",
            "description": "This file provides utilities for sorting constant lists of string literals in Python code, such as `__all__` or `__slots__`. It defines different sorting styles (natural and isort-style) and functions to classify and sort sequence elements for autofixing.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/src/rules/ruff/rules/post_init_default.rs",
            "description": "This file implements a linting rule (RUF033) that identifies and fixes `__post_init__` dataclass methods with parameter defaults, suggesting the use of `dataclasses.InitVar` fields instead.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/ruff/rules/missing_fstring_syntax.rs",
            "description": "Implements a lint rule (RUF027) that identifies and suggests fixes for string literals that resemble f-strings but are missing the 'f' prefix, while carefully avoiding false positives like logging format strings or docstrings.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/ruff/rules/incorrectly_parenthesized_tuple_in_subscript.rs",
            "description": "This file defines and implements the RUF031 linting rule, which enforces consistent parenthesization of non-empty tuples used in subscript expressions based on user configuration. It provides autofix capabilities to add or remove parentheses as required.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/ruff/rules/unused_unpacked_variable.rs",
            "description": "This file implements a Ruff lint rule (RUF059) that detects and flags unused variables in unpacked assignments, offering a fix to prefix them with an underscore or a similar dummy variable pattern.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/ruff/rules/invalid_suppression_comment.rs",
            "description": "This file defines the `InvalidSuppressionComment` violation, which is used to identify and report issues with malformed or incorrect `ruff` suppression comments. It provides detailed messages for different types of invalid suppression syntax.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/src/rules/ruff/rules/unnecessary_cast_to_int.rs",
            "description": "This file implements the Ruff rule `RUF046` (UnnecessaryCastToInt), which identifies and fixes redundant `int()` conversions for values that are already integers. It analyzes calls to built-in functions like `len`, `round`, and `math` functions to determine the safety of removing the `int` cast.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/ruff/rules/mod.rs",
            "description": "This file serves as the central module for the `ruff` category of linting rules, declaring and re-exporting all individual rule modules within this group for the Ruff linter.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/ruff/rules/confusables.rs",
            "description": "This file contains a generated lookup table and function for mapping Unicode confusable characters to their more common or ASCII equivalents, used for detecting ambiguous characters in source code. It is part of the ruff linter's rule set.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/src/rules/ruff/rules/assignment_in_assert.rs",
            "description": "This file defines and implements a Ruff linting rule (RUF018) that detects named assignment expressions (walrus operators) within `assert` statements, especially when the assigned variable is used outside of `assert` statements.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/ruff/rules/sort_dunder_slots.rs",
            "description": "This file implements a Ruff rule (RUF023) that checks for and fixes unsorted `__slots__` definitions in Python classes, applying a natural sort order. It handles various collection types (list, tuple, set, dict) and assesses fix safety based on comments or `__slots__` usage.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/src/rules/ruff/rules/unnecessary_round.rs",
            "description": "This file implements a linting rule (RUF057) to detect and fix unnecessary `round()` calls in Python code, specifically when the input value is already an integer. It analyzes `round()` function calls, infers argument types, and generates a fix to remove the redundant call.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/ruff/rules/parenthesize_chained_operators.rs",
            "description": "This file implements a Ruff linter rule (`RUF021`) that identifies and fixes ambiguous chained logical operations (specifically `and` within `or` expressions) by adding parentheses to clarify operator precedence.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/ruff/rules/unmatched_suppression_comment.rs",
            "description": "This file defines a linter rule `UnmatchedSuppressionComment` for Ruff, which detects and flags `#ruff:disable` comments that lack a corresponding `#ruff:enable` comment. It provides metadata, a message format, and documentation for this specific violation within the linter.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/src/rules/ruff/rules/unused_async.rs",
            "description": "This file implements a Ruff lint rule (`RUF029`, `UnusedAsync`) that identifies Python functions declared as `async` but do not utilize `await` or other asynchronous features within their body. It uses a custom AST visitor to detect the presence of async-specific constructs.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/ruff/rules/float_equality_comparison.rs",
            "description": "Implements a Ruff rule (RUF069) to detect and flag unreliable direct equality or inequality comparisons between floating-point numbers. It identifies expressions that resolve to floats or complex numbers and suggests using tolerance-based comparisons instead.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/src/rules/ruff/rules/useless_if_else.rs",
            "description": "Implements a linting rule (RUF034) to detect and report useless `if-else` expressions where both branches have identical outcomes, suggesting direct assignment instead.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/ruff/rules/unnecessary_key_check.rs",
            "description": "This file implements a linter rule (RUF019) that detects unnecessary `in` checks before dictionary access. It provides a fix to replace the `key in dict and dict[key]` pattern with `dict.get(key)`.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/ruff/rules/redirected_noqa.rs",
            "description": "This file implements a Ruff rule (`RUF101`) that detects and fixes `noqa` directives which use deprecated or redirected rule codes, suggesting the use of their canonical replacements.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/src/rules/ruff/rules/invalid_pyproject_toml.rs",
            "description": "This file defines a linter rule (`InvalidPyprojectToml`) for Ruff, which detects and reports issues in `pyproject.toml` files that do not conform to the relevant PEP specifications. It generates a message indicating a parsing failure for such invalid files.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/ruff/rules/in_empty_collection.rs",
            "description": "Implements a lint rule (RUF060) that identifies and reports unnecessary membership tests (`in` or `not in`) where the collection being checked against is always empty. It includes logic to detect various forms of empty collections, such as empty literals or calls to constructors like `set()`.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/src/rules/ruff/rules/invalid_formatter_suppression_comment.rs",
            "description": "This file defines a linter rule (RUF028) that identifies and reports on formatter suppression comments (like `fmt: off` or `fmt: skip`) that are improperly placed or ineffective according to Ruff's formatting rules. It also provides a fix to remove these invalid comments.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/ruff/rules/invalid_rule_code.rs",
            "description": "This file defines a linter rule (RUF102) that identifies and suggests fixes for invalid rule codes used in `# noqa` comments within Python source files. It checks whether specified rule codes are valid or declared as external.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/ruff/rules/mutable_class_default.rs",
            "description": "Implements the RUF012 linting rule for Ruff, which detects and flags mutable default values in Python class attributes to prevent shared state issues. It suggests annotating with `typing.ClassVar` or initializing in `__init__`.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/ruff/rules/non_empty_init_module.rs",
            "description": "This file implements the `NonEmptyInitModule` (RUF067) linting rule for Ruff, which detects and flags non-allowed code within Python's `__init__.py` files. It supports both a strict mode, disallowing all code, and a non-strict mode that permits specific constructs like imports, docstrings, and certain module-level assignments.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/src/rules/ruff/rules/zip_instead_of_pairwise.rs",
            "description": "This file implements a Ruff lint rule that detects and offers to fix Python code using `zip()` to iterate over successive pairs, suggesting `itertools.pairwise()` as a more readable alternative. It includes logic to identify suitable `zip()` calls and generate the corresponding fix.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/ruff/rules/implicit_classvar_in_dataclass.rs",
            "description": "Implements a Ruff rule (RUF045) that detects implicit class variables in Python dataclasses. It flags unannotated assignments within dataclass bodies, suggesting the use of `ClassVar`.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/src/rules/ruff/rules/mutable_fromkeys_value.rs",
            "description": "This file implements a Ruff linting rule (RUF024) that detects the use of mutable objects as the `value` argument in `dict.fromkeys` calls, which can lead to unexpected shared state. It also provides an unsafe fix to replace such calls with a dictionary comprehension.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/ruff/rules/unraw_re_pattern.rs",
            "description": "This file implements a Ruff linting rule (RUF039) that identifies and suggests fixing regular expression patterns passed as non-raw string or bytes literals to functions in Python's `re` and `regex` modules. It aims to prevent double escaping by enforcing the use of raw strings for regex patterns.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/ruff/rules/starmap_zip.rs",
            "description": "Implements a lint rule (RUF058) for the Ruff linter that identifies and suggests replacing `itertools.starmap(func, zip(args))` calls with `map(func, *args)` for improved efficiency. It also handles the generation of an automatic fix, considering Python version compatibility and potential shadowing of the `map` builtin.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/ruff/rules/unnecessary_literal_within_deque_call.rs",
            "description": "Implements a Ruff linter rule (`RUF037`) that flags and fixes `collections.deque` calls where an empty iterable is unnecessarily provided as the first argument. It suggests replacing such calls with `deque()` or `deque(maxlen=...)`.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/ruff/rules/used_dummy_variable.rs",
            "description": "Implements a Ruff linting rule (RUF052) that identifies and suggests fixes for 'dummy variables' (variables starting with underscores) that are unexpectedly used, especially when they might shadow built-ins, keywords, or other variables.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/ruff/rules/needless_else.rs",
            "description": "This file implements a linting rule (RUF047) in the Ruff linter to identify and remove redundant `else` clauses that only contain `pass` or ellipsis statements. It provides logic for detecting such clauses across different control flow statements and handles comment preservation during removal.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/src/rules/ruff/rules/non_octal_permissions.rs",
            "description": "Implements a Ruff lint rule (RUF064) that detects and suggests fixes for non-octal integer literals used as file permission modes in Python standard library functions. It ensures explicit octal notation (e.g., `0o644`) for clarity and correctness.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/src/rules/ruff/rules/unnecessary_iterable_allocation_for_first_element.rs",
            "description": "This file implements a lint rule for Ruff (`RUF015`) that detects inefficient Python patterns for retrieving the first element of an iterable. It suggests replacing eager collection allocations (e.g., `list(...)[0]`) with lazy `next(iter(...))` calls to improve performance.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/ruff/rules/unused_noqa.rs",
            "description": "This file defines the `UnusedNOQA` rule (RUF100) for the Ruff linter, which detects and reports on `noqa` directives that are no longer applicable or correctly configured, allowing for their removal.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/ruff/rules/unnecessary_regular_expression.rs",
            "description": "This file implements a Ruff linting rule that identifies `re` module calls (like `re.sub`, `re.match`, `re.split`) which can be safely replaced by equivalent `str` methods because their patterns are simple string literals without regular expression metacharacters.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/ruff/snapshots",
            "description": "This directory is designated to store test snapshots for the `ruff` rules implemented within the `ruff_linter` crate. These snapshots serve as reference outputs for comparison during testing, ensuring that rule implementations produce consistent and expected results.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/refurb/mod.rs",
            "description": "This file serves as the module entry point for the 'refurb' rules within the ruff linter, primarily containing the test suite to verify the implementation of these rules against various Python code examples.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/refurb/helpers.rs",
            "description": "This file contains helper functions and data structures for detecting, analyzing, and generating fixes for Python file open operations (`open()` and `pathlib.Path.open()`) as part of the `refurb` linter rules, primarily focused on `with` statements.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/refurb/rules/check_and_remove_from_set.rs",
            "description": "This file implements a Ruff rule (FURB132) that identifies and suggests replacing `if element in set: set.remove(element)` patterns with the more idiomatic `set.discard(element)` in Python code.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/refurb/rules/for_loop_set_mutations.rs",
            "description": "This file implements a linting rule (FURB142) that detects and suggests improvements for `for` loops that individually add or remove items from a set. It recommends replacing such loops with more efficient `set.update()` or `set.difference_update()` calls.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/refurb/rules/bit_count.rs",
            "description": "Implements a linting rule that identifies and suggests replacing the `bin(...).count(\"1\")` pattern with the `int.bit_count()` method in Python code for improved efficiency. It also provides a fix for this violation.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/refurb/rules/delete_full_slice.rs",
            "description": "This file implements a `ruff` rule (`FURB131`) that detects `del` statements used to remove the entire slice of a list or dictionary. It recommends replacing these operations with the more efficient `clear()` method.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/refurb/rules/repeated_append.rs",
            "description": "This file implements a Ruff rule (FURB113) that identifies and suggests fixes for inefficient, consecutive calls to `list.append()` by replacing them with a single `list.extend()` call for improved performance.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/refurb/rules/fromisoformat_replace_z.rs",
            "description": "This file implements a linting rule (FURB162) in Ruff that detects and flags unnecessary `datetime.fromisoformat()` calls where a 'Z' (Zulu time) suffix is replaced with a zero-offset timezone for Python 3.11 and later, as `fromisoformat` can handle 'Z' directly. It also provides an unsafe fix to remove these replacements.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/src/rules/refurb/rules/if_expr_min_max.rs",
            "description": "This file implements a lint rule for Ruff that identifies `if` expressions convertible to `min()` or `max()` calls, providing a fix to replace them for conciseness and readability.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/refurb/rules/implicit_cwd.rs",
            "description": "This file implements a `ruff` linter rule (`FURB177`) that detects and suggests replacing `Path().resolve()` with `Path.cwd()` for current-directory lookups to improve explicitness.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/refurb/rules/unnecessary_enumerate.rs",
            "description": "This file implements a Ruff lint rule (FURB148) that detects and suggests fixes for unnecessary uses of `enumerate` where either the index or the value is unused in a `for` loop.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/refurb/rules/hardcoded_string_charset.rs",
            "description": "This file implements a Ruff rule (FURB156) that detects hardcoded string charsets in Python code, such as '0123456789', and provides a fix to replace them with more readable and less error-prone named constants from Python's `string` module (e.g., `string.digits`). It defines a list of known character sets and checks for exact matches within string literals.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/refurb/rules/mod.rs",
            "description": "This file serves as the module aggregation point for the `refurb` linting rules within the `ruff_linter` crate, re-exporting all individual rule modules for external use.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/refurb/rules/subclass_builtin.rs",
            "description": "This file implements a `ruff` rule (FURB189) that flags subclassing of built-in types like `dict`, `list`, or `str`. It recommends using the corresponding `UserDict`, `UserList`, or `UserString` classes from the `collections` module to avoid unexpected behavior.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/refurb/rules/reimplemented_starmap.rs",
            "description": "This file defines a lint rule (FURB140) that identifies generator expressions and comprehensions that can be refactored to use `itertools.starmap` for improved conciseness and efficiency. It also provides a fix to automatically apply this refactoring.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/refurb/rules/type_none_comparison.rs",
            "description": "This file defines a `ruff` linting rule (FURB169) that identifies and suggests replacing `type(obj) is type(None)` comparisons with the more idiomatic and efficient `obj is None` in Python code.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/refurb/rules/write_whole_file.rs",
            "description": "This file implements a lint rule (FURB103) that identifies and suggests replacing `open()` and `write()` calls within `with` statements with more concise `pathlib` methods like `Path.write_text` or `Path.write_bytes`.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/refurb/rules/readlines_in_for.rs",
            "description": "This file implements a `ruff` linter rule that detects and fixes inefficient uses of `readlines()` when iterating over file objects in `for` loops or comprehensions. It promotes direct iteration over the file object for better performance and convenience.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/refurb/rules/reimplemented_operator.rs",
            "description": "Implements a lint rule (FURB118) that identifies and suggests replacing lambda expressions or single-return function definitions with their equivalent functions from Python's `operator` module, noting safety considerations for the suggested fixes.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/refurb/rules/if_exp_instead_of_or_operator.rs",
            "description": "This file implements a lint rule for the Ruff linter that identifies and fixes Python ternary 'if' expressions which can be simplified into 'or' operator expressions. It includes logic for fix safety considerations regarding side effects and comments.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/refurb/rules/sorted_min_max.rs",
            "description": "This file implements a linting rule (FURB192) that identifies and suggests replacing inefficient uses of `sorted()` with `min()` or `max()` to find the minimum or maximum value in a sequence. It also provides an unsafe fix to automatically apply this replacement.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/refurb/rules/repeated_global.rs",
            "description": "This file defines a lint rule (FURB154) that identifies and fixes redundant consecutive `global` or `nonlocal` statements in Python code. It merges multiple such statements into a single, comma-separated declaration to improve conciseness.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/refurb/rules/metaclass_abcmeta.rs",
            "description": "This file implements a `ruff` lint rule (FURB180) that flags and fixes Python code using `metaclass=abc.ABCMeta` for abstract base classes, recommending the more succinct `abc.ABC` inheritance instead. It also determines the safety and applicability of the proposed fix.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/src/rules/refurb/rules/read_whole_file.rs",
            "description": "This file implements a Ruff lint rule (FURB101) that detects and suggests refactoring Python code using `open()` and `read()` to read entire files, replacing them with more concise `pathlib` methods like `Path.read_text()` or `Path.read_bytes()`.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/refurb/rules/hashlib_digest_hex.rs",
            "description": "This file defines a linter rule (FURB181) for Ruff that identifies and offers to fix Python code using `hashlib.digest().hex()` by replacing it with the more concise and readable `hashlib.hexdigest()`.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/refurb/rules/verbose_decimal_constructor.rs",
            "description": "This file implements a linter rule to identify and fix verbose or unnecessary conversions in `Decimal` constructors. It targets cases like integer-like string literals and non-finite float strings that can be simplified for better readability and idiomatic usage.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/refurb/rules/fstring_number_format.rs",
            "description": "This file implements a linter rule that identifies and suggests replacing `bin(...)[2:]`, `hex(...)[2:]`, or `oct(...)[2:]` expressions with more concise f-string formatting (e.g., `f\"{value:b}\"`).",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/refurb/rules/int_on_sliced_str.rs",
            "description": "This file implements a Ruff linter rule (FURB166) that detects and suggests fixes for redundant explicit base arguments in `int()` calls when processing sliced string literals that would otherwise benefit from Python's automatic base detection. It provides a diagnostic and an unsafe fix to replace the sliced string and explicit base with the original string and a base of `0`.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/refurb/rules/redundant_log_base.rs",
            "description": "This file implements a lint rule that identifies and suggests fixes for `math.log` calls in Python code where the base argument is redundant or can be replaced with more specific functions like `math.log2` or `math.log10`.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/refurb/rules/print_empty_string.rs",
            "description": "Implements a lint rule (FURB105) for the Ruff linter that identifies and suggests fixes for `print()` calls containing redundant empty string arguments or unnecessary `sep` keyword arguments.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/refurb/rules/slice_copy.rs",
            "description": "This file implements a linting rule (FURB145) that detects and suggests replacing unbounded slice expressions (e.g., `list[:]`) used for copying lists with the more explicit and readable `list.copy()` method.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/refurb/rules/isinstance_type_none.rs",
            "description": "This file implements a linting rule (FURB168) for the Ruff linter that detects and suggests fixing `isinstance(obj, type(None))` calls to `obj is None` for improved readability and efficiency. It includes logic to identify various patterns that resolve to checking against `None` in `isinstance`'s type argument.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/refurb/rules/regex_flag_alias.rs",
            "description": "This file defines a linting rule (FURB167) that checks for and automatically fixes the use of single-letter aliases for Python's `re` module flags, promoting the use of full, descriptive flag names for better readability.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/refurb/rules/math_constant.rs",
            "description": "This file implements a Ruff lint rule (`FURB152`) that identifies hardcoded floating-point literals resembling mathematical constants (like Pi, E, and Tau) and suggests replacing them with the corresponding `math` module constants for improved precision and readability. It also provides a fix to automatically import and use these constants.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/refurb/rules/unnecessary_from_float.rs",
            "description": "Implements a Ruff lint rule (FURB164) that identifies and suggests fixes for unnecessary `from_float` and `from_decimal` method calls when constructing `Decimal` or `Fraction` objects in Python code.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/refurb/rules/slice_to_remove_prefix_or_suffix.rs",
            "description": "Implements a linting rule for Ruff that identifies and suggests replacing conditional string slicing with `str.removeprefix()` or `str.removesuffix()` for improved readability and efficiency. It handles both expression and statement forms of this pattern.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/refurb/rules/for_loop_writes.rs",
            "description": "This file defines a lint rule (FURB122) that identifies and suggests fixes for inefficient use of `IOBase.write` calls inside `for` loops, recommending the use of `writelines` for batch operations to improve performance and idiomatic style.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/refurb/rules/single_item_membership_test.rs",
            "description": "This file implements a linter rule (FURB171) that flags and suggests fixing membership tests (e.g., `x in [y]`) against single-item containers by converting them to direct equality or inequality comparisons (e.g., `x == y`). The fix is marked as unsafe due to potential behavioral changes in certain edge cases.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/refurb/rules/list_reverse_copy.rs",
            "description": "This file implements a `ruff` linter rule (FURB187) that identifies and suggests replacing patterns like `l = reversed(l)` or `l = l[::-1]` with the more efficient in-place `l.reverse()` method when a list is assigned back to itself. The fix is marked as unsafe due to its mutative nature.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/refurb/snapshots",
            "description": "This directory is designated to store test snapshots for the `refurb` set of linting rules within the `ruff_linter` crate. These snapshots help ensure the consistent behavior and output of the linter rules during development and testing.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pygrep_hooks/rules/deprecated_log_warn.rs",
            "description": "This file defines a linter rule (`DeprecatedLogWarn`) that identifies and flags the use of the deprecated `logging.warn` method in Python code, recommending `logging.warning` instead. It notes that this rule is removed and superseded by `G010`.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pygrep_hooks/rules/mod.rs",
            "description": "This file serves as the module entry point for `pygrep_hooks` rules, re-exporting individual linting rule definitions for use within the `ruff_linter` crate.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pygrep_hooks/rules/blanket_noqa.rs",
            "description": "This file implements a Ruff linter rule (`PGH004`) to detect and fix 'blanket noqa' annotations that suppress all diagnostics or are missing a colon before specified rule codes. It encourages the use of specific rule codes for better clarity and maintainability.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pygrep_hooks/rules/invalid_mock_access.rs",
            "description": "This file implements a linter rule (PGH005) for the Ruff linter, designed to detect common incorrect usages of the Python `mock` module's assertion API, such as uncalled assertion methods or non-existent mock methods.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pygrep_hooks/rules/blanket_type_ignore.rs",
            "description": "Implements a lint rule (PGH003) that detects and flags 'blanket' type ignore comments (e.g., `# type: ignore`) that do not specify particular error codes, encouraging more precise suppression of type checking issues.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pygrep_hooks/snapshots",
            "description": "This directory stores snapshot test data for the `pygrep_hooks` set of linting rules within the `ruff_linter` crate. These snapshots capture the expected output or behavior of the linter for specific code examples, ensuring consistent rule application and reporting during development and refactoring.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pyupgrade/helpers.rs",
            "description": "This file provides helper functions for escaping and unescaping curly braces within strings, particularly for situations like string formatting. It includes functions to double single curly braces while preserving Unicode escapes, and to convert double curly braces back to single ones.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pyupgrade/types.rs",
            "description": "This file defines a `Primitive` enum representing basic Python data types (e.g., bool, str, int) and provides methods to convert Python AST expressions into these primitive types and retrieve their string names.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/src/rules/pyupgrade/mod.rs",
            "description": "This file serves as the main module for the `pyupgrade` rule set in the Ruff linter, organizing sub-modules for fixes, rule definitions, and settings. It also contains extensive test cases for all implemented `pyupgrade` rules.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pyupgrade/rules/deprecated_mock_import.rs",
            "description": "This file implements a `ruff` linter rule (UP026) that identifies and fixes deprecated `mock` module imports and usage, replacing them with `unittest.mock`.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pyupgrade/rules/native_literals.rs",
            "description": "Implements a Ruff linter rule (UP018) that detects and fixes unnecessary calls to native type constructors like `str()`, `int()`, and `bool()` when a literal value can be used instead. It provides automatic fixes to replace these calls with the corresponding literal expressions.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pyupgrade/rules/open_alias.rs",
            "description": "This file defines a lint rule for Ruff (UP020) that identifies and fixes Python code using `io.open` by replacing it with the built-in `open` function. It provides the rule's metadata, message, and a fix implementation.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pyupgrade/rules/datetime_utc_alias.rs",
            "description": "Implements a lint rule (UP017) that checks for and suggests replacing `datetime.timezone.utc` with the `datetime.UTC` alias in Python code for improved readability and consistency.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pyupgrade/rules/replace_universal_newlines.rs",
            "description": "This file implements a lint rule for Ruff (UP021) that detects and fixes the deprecated `universal_newlines` argument in `subprocess.run` calls, suggesting its replacement with `text`.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pyupgrade/rules/unnecessary_default_type_args.rs",
            "description": "This file implements a Ruff rule (UP043) that identifies and fixes unnecessary default type arguments in `Generator` and `AsyncGenerator` type annotations for Python 3.13+.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pyupgrade/rules/unnecessary_builtin_import.rs",
            "description": "This file implements the `UnnecessaryBuiltinImport` rule (UP029) for the Ruff linter. It detects and flags redundant imports of Python built-in functions or types from modules like `builtins` or `six`, offering a fix to remove them.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pyupgrade/rules/redundant_open_modes.rs",
            "description": "This file implements a linter rule (UP015) for Ruff that identifies and fixes redundant 'mode' arguments in Python's `open()` function calls, such as explicitly providing 'r' for read mode. It provides a diagnostic and an automatic fix to remove or simplify these arguments.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pyupgrade/rules/deprecated_import.rs",
            "description": "This file implements a rule for the `ruff` linter that detects and suggests fixes for deprecated Python imports, categorizing them by module, member, and target Python version.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pyupgrade/rules/type_of_primitive.rs",
            "description": "This file implements a linter rule (UP003) that detects and suggests fixes for `type()` calls used on primitive types in Python code. It aims to replace `type(primitive)` with the direct primitive type, like `int` or `str`.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pyupgrade/rules/mod.rs",
            "description": "This file serves as the module entry point for all `pyupgrade` rules within the Ruff linter, aggregating and re-exporting individual rule implementations.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pyupgrade/rules/printf_string_formatting.rs",
            "description": "Implements a lint rule for Ruff to detect and fix `printf`-style string formatting in Python code. It converts old-style string formatting to modern `str.format` calls or f-strings.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pyupgrade/rules/unpacked_list_comprehension.rs",
            "description": "Defines a linting rule (UP027) in Ruff that identifies immediately unpacked list comprehensions and recommends replacing them with generator expressions for efficiency. This rule has been removed since Ruff version 0.8.0.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pyupgrade/rules/replace_str_enum.rs",
            "description": "Implements a linting rule (UP042) in Ruff that identifies Python classes inheriting from both `str` and `enum.Enum` and suggests replacing them with `enum.StrEnum` for Python 3.11+.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pyupgrade/rules/deprecated_c_element_tree.rs",
            "description": "This file implements a `ruff` linter rule (UP023) that identifies and automatically fixes uses of the deprecated `xml.etree.cElementTree` module, replacing it with `xml.etree.ElementTree`.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pyupgrade/rules/unnecessary_coding_comment.rs",
            "description": "This file implements a lint rule (`UP009`) that detects and fixes unnecessary UTF-8 encoding declarations in Python files, as UTF-8 is the default encoding since PEP 3120.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pyupgrade/rules/unicode_kind_prefix.rs",
            "description": "Implements a lint rule (`UP025`) that detects and fixes unnecessary Unicode kind prefixes (e.g., `u\"string\"`) in Python string literals, replacing them with plain strings (e.g., `\"string\"`). It also handles edge cases to prevent syntax errors during the fix.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pyupgrade/rules/quoted_annotation.rs",
            "description": "This file implements a linter rule that detects and fixes unnecessary quoted type annotations in Python code. It removes quotes when `from __future__ import annotations` is active or the annotation is in a typing-only context, improving code readability and consistency.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pyupgrade/rules/useless_class_metaclass_type.rs",
            "description": "Implements a linter rule (UP050) that detects and provides a fix for redundant `metaclass=type` declarations in Python class definitions, which are unnecessary since Python 3.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/src/rules/pyupgrade/rules/convert_typed_dict_functional_to_class.rs",
            "description": "This file implements a linter rule (UP013) that identifies and converts Python `TypedDict` declarations from functional syntax to class-based syntax. It provides the logic for analyzing the `TypedDict` call, extracting field definitions, and generating the corresponding class statement, while handling various edge cases and fix safety considerations.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pyupgrade/rules/deprecated_unittest_alias.rs",
            "description": "This file implements a Ruff rule (UP005) that identifies and corrects deprecated method aliases in Python's `unittest` module, replacing them with their modern counterparts.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pyupgrade/rules/useless_metaclass_type.rs",
            "description": "This file implements a linting rule (UP001) that detects and automatically fixes the redundant use of `__metaclass__ = type` in Python class definitions, as it is implied since Python 3.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pyupgrade/rules/non_pep646_unpack.rs",
            "description": "This file implements a Ruff linting rule (UP044) that identifies and suggests replacing the `Unpack[]` syntax with the newer `*` operator for type unpacking in Python 3.11+ code, in line with PEP 646.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/src/rules/pyupgrade/rules/extraneous_parentheses.rs",
            "description": "This file implements a lint rule for the `ruff` linter that identifies and fixes extraneous parentheses in Python code. It detects redundant parentheses that do not alter semantics, improving code readability.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pyupgrade/rules/typing_text_str_alias.rs",
            "description": "This file implements a lint rule that identifies and fixes the use of the deprecated `typing.Text` (and `typing_extensions.Text` in preview mode) in Python code, suggesting replacement with `str`.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/src/rules/pyupgrade/rules/unnecessary_encode_utf8.rs",
            "description": "This Rust file implements a `ruff` linter rule (UP012) that detects and fixes unnecessary calls to `str.encode()` with UTF-8 encoding in Python code. It suggests either converting ASCII string literals to byte literals or removing redundant `encoding=\"utf-8\"` arguments.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pyupgrade/rules/convert_named_tuple_functional_to_class.rs",
            "description": "This file implements a linter rule (UP014) in Ruff that identifies and converts `NamedTuple` declarations from functional syntax to the preferred class-based syntax in Python. It includes logic to extract field definitions and generate a fix, noting potential unsafety if comments are present.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pyupgrade/rules/unnecessary_class_parentheses.rs",
            "description": "This file implements a lint rule (`UP039`) for Ruff that identifies and fixes unnecessary empty parentheses in Python class definitions. It detects cases like `class Foo():` and suggests `class Foo:`.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/src/rules/pyupgrade/rules/f_strings.rs",
            "description": "Implements a Ruff linting rule to detect and fix `str.format` calls by converting them to f-strings for Python code modernization and improved readability.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pyupgrade/rules/os_error_alias.rs",
            "description": "This file defines a lint rule (UP024) for Ruff that identifies and fixes uses of deprecated `OSError` aliases (like `IOError` or `WindowsError`) in Python code, recommending their replacement with the more modern and idiomatic `OSError`.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pyupgrade/rules/super_call_with_parameters.rs",
            "description": "This file implements a linting rule (UP008) for the Ruff linter, which detects and suggests fixes for redundant `super()` calls that include `__class__` and `self` arguments in Python 3 code.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pyupgrade/rules/yield_in_for_loop.rs",
            "description": "This file implements a lint rule (UP028) that identifies and suggests replacing `for` loops containing a single `yield` statement with the more concise `yield from` expression in Python code. It handles various edge cases, such as `async` contexts, `else` clauses, and global/nonlocal variables, and provides a fix that is marked as `Sometimes` safe.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pyupgrade/rules/unnecessary_future_import.rs",
            "description": "This file implements a Ruff lint rule (UP010) that identifies and suggests the removal of `__future__` imports that are unnecessary for the configured target Python version.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pyupgrade/rules/use_pep604_annotation.rs",
            "description": "This file implements linter rules for Ruff (UP007 and UP045) that detect and fix Python type annotations using `typing.Union` or `typing.Optional` to conform to the more modern PEP 604 `X | Y` syntax. It handles the conversion and considers Python version compatibility and fix safety.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pyupgrade/rules/format_literals.rs",
            "description": "This file implements a Ruff linter rule that detects and fixes `str.format()` calls that use explicit positional indices (e.g., `{0}`) when implicit indices (`{}`) would be sufficient and enhance readability. It also handles reordering arguments if the explicit indices are not sequential.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pyupgrade/rules/use_pep604_isinstance.rs",
            "description": "This file defines a deprecated lint rule that identifies and offers to fix `isinstance` and `issubclass` calls that use type tuples, suggesting the use of PEP 604 union syntax (`X | Y`) instead.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pyupgrade/rules/use_pep585_annotation.rs",
            "description": "Implements a lint rule (UP006) that identifies and suggests replacing deprecated `typing` module generics (e.g., `typing.List`) with their standard library equivalents (e.g., `list`) as per PEP 585. It also provides a fix, noting potential unsafety for older Python versions when runtime type annotations are used.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pyupgrade/rules/pep695/non_pep695_type_alias.rs",
            "description": "This file implements a lint rule (UP040) that identifies and suggests fixes for Python type alias declarations that use `TypeAlias` annotations or `TypeAliasType` assignments, encouraging the use of the newer PEP 695 `type` keyword syntax (Python 3.12+).",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pyupgrade/rules/pep695/mod.rs",
            "description": "This file provides shared data structures and utilities for Ruff rules that identify and refactor Python type variable declarations (TypeVar, TypeVarTuple, ParamSpec) from their older call-based syntax to the newer PEP 695 generic type parameter syntax.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pyupgrade/snapshots",
            "description": "This directory is intended to store snapshot test data specifically for the `pyupgrade` rules within the Ruff linter. These snapshots are used to verify the expected output or behavior of the linter during testing.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/project/examples/.dotfiles/script.py",
            "description": "This Python script, located in a test project's example dotfiles, imports numpy and a local 'app_file', likely serving as a test fixture or an example of a dotfile configuration.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/project/examples/docs/docs/file.py",
            "description": "This file serves as a test or example Python module within the Ruff linter project, likely demonstrating basic imports and function definitions in a documentation-like structure for analysis.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/project/examples/docs/docs/concepts/file.py",
            "description": "This is a simple Python file serving as a test resource or example for the `ruff_linter` project, likely used to demonstrate basic Python syntax and linter processing within documentation concepts.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/project/python_modules/core/core",
            "description": "This directory defines a nested Python package named 'core' within a test project for the `ruff_linter`. It contains Python source files, such as `core_file.py`, which serve as test cases or fixtures for evaluating the linter's behavior.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/package/src/package/app.py",
            "description": "This file serves as the main entry point for a test package, demonstrating how to import and execute a core method named 'method'.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_2020/YTT202.py",
            "description": "This file is a test fixture for the Flake8-2020 linter, specifically designed to trigger or test the YTT202 rule. It demonstrates the use of `six.PY3` for Python 2/3 compatibility checks.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_2020/YTT103.py",
            "description": "This file is a test fixture for the flake8-2020 linter, specifically designed to check warnings related to version comparisons using `sys.version` or `sys.version_info`.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_2020/YTT301.py",
            "description": "This file is a test fixture for the YTT301 rule in `flake8-2020`, demonstrating the use of `sys.version[0]` to access the Python major version.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_2020/YTT102.py",
            "description": "This file serves as a test fixture for the `YTT102` linter rule. It demonstrates accessing `sys.version` string components, which the rule aims to flag as an anti-pattern.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_2020/YTT303.py",
            "description": "This file imports the `sys` module and `version` from `sys`, then prints the first character of both `sys.version` and `version`. It likely serves as a test case for a linter related to version string access.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_2020/YTT302.py",
            "description": "This file is a test fixture for the Ruff linter, specifically for the YTT302 rule within the flake8_2020 plugin. It demonstrates various comparisons of `sys.version` with string literals, likely to test the linter's ability to flag or handle such version checks.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_2020/YTT101.py",
            "description": "This file serves as a test case for a linter, examining its behavior when accessing and slicing `sys.version` using direct calls, aliased imports, and variable slice indices. It checks how the linter flags or handles different ways of referencing Python version information.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_2020/YTT203.py",
            "description": "This file demonstrates checks against Python's minor version using `sys.version_info`. It likely serves as a test fixture for a linter rule (e.g., YTT203) that identifies specific patterns in version comparisons.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_2020/YTT201.py",
            "description": "This file is a test fixture for the `flake8-2020` linter rule YTT201, demonstrating various expressions involving `sys.version_info` for Python version checks.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_2020/YTT204.py",
            "description": "This file serves as a test fixture for the Ruff linter, specifically for the 'flake8-2020' rule YTT204. It demonstrates `sys.version_info.minor` comparisons that are intended to be flagged by the linter.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_async/ASYNC109_0.py",
            "description": "This file is a test fixture for the `flake8_async` linter, specifically for rule `ASYNC109`, demonstrating different asynchronous function definitions that might trigger a specific linting error or warning.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_async/ASYNC251.py",
            "description": "Tests the `flake8-async` linter's ASYNC251 rule, which identifies synchronous `time.sleep` calls within asynchronous functions.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_async/ASYNC250.py",
            "description": "Test fixture for the ASYNC250 linting rule, demonstrating valid and invalid usage of `input()` and `builtins.input()` within synchronous and asynchronous functions.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_async/ASYNC110.py",
            "description": "Test fixtures for the `flake8_async` linter (ASYNC110) demonstrating various uses of `trio.sleep`, `anyio.sleep`, and `asyncio.sleep` functions within async functions, including awaited and non-awaited calls.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_async/ASYNC230.py",
            "description": "This file serves as a test fixture for the `ASYNC230` linting rule, demonstrating cases where synchronous file I/O operations (`open()`, `Path.open()`) are used inappropriately within asynchronous functions.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_async/ASYNC210.py",
            "description": "This file serves as a test fixture for the `ruff_linter`'s `flake8_async` rules, specifically `ASYNC210`. It demonstrates various synchronous HTTP client calls (from `urllib`, `requests`, `httpx`, `urllib3`) made within `async` functions, highlighting which calls should trigger the `ASYNC210` diagnostic.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_async/ASYNC109_1.py",
            "description": "This file serves as a test fixture for the `ruff_linter`, specifically to verify the `ASYNC109` rule of `flake8_async`, which detects redefinition of asynchronous functions.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_async/ASYNC115.py",
            "description": "This file serves as a test fixture for the Ruff linter's ASYNC115 rule, demonstrating various correct and incorrect usages of `trio.sleep(0)` and `anyio.sleep(0)` calls. It includes examples with direct `0` arguments, variables, destructuring, walrus operator, and keyword arguments to test the linter's detection logic.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_async/ASYNC240.py",
            "description": "This file contains test cases for the `ASYNC240` linter rule, demonstrating valid and invalid (blocking) usage of `os.path` and `pathlib.Path` methods within asynchronous functions.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_async/ASYNC116.py",
            "description": "This file serves as a test fixture for the `ASYNC116` linter rule, demonstrating various scenarios where `trio.sleep` and `anyio.sleep` are called with excessively long or infinite delay values, which should trigger a linting error.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_async/ASYNC100.py",
            "description": "This file is a test fixture for the `ASYNC100` linter rule, showcasing various usages of `asyncio`, `trio`, and `anyio` context managers and timeout mechanisms in asynchronous Python code.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/eradicate/ERA001.py",
            "description": "This file serves as a test fixture for the `ERA001` rule in the `ruff_linter`, demonstrating various patterns of commented-out code, `noqa` directives, and structured comment blocks (like 'Script tags') to ensure the linter correctly identifies or ignores them.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_blind_except/BLE.py",
            "description": "This file serves as a test fixture for the `flake8_blind_except` linter rule, demonstrating various patterns of `try-except` blocks to check for overly broad exception handling, especially with `Exception` and `BaseException`, and their interaction with logging functions.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_boolean_trap/FBT.py",
            "description": "This file contains test fixtures for the `flake8-boolean-trap` linter plugin, showcasing various scenarios involving boolean arguments, default values, and methods that should or should not trigger linter warnings.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_commas/COM81_syntax_error.py",
            "description": "This file is a test fixture for `flake8-commas` that includes a syntax error. Its purpose is to verify how the linter handles files containing invalid Python syntax.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_commas/COM81.py",
            "description": "This file contains a comprehensive set of test cases for a linter, demonstrating various good and bad practices related to the placement and omission of trailing commas in Python syntax, including function calls, lists, dictionaries, tuples, and type parameters.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_comprehensions/C410.py",
            "description": "Tests for the `flake8-comprehensions` C410 rule, which flags redundant `list()` calls on list or tuple literals, including cases with comments and multiple arguments.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_comprehensions/C419_1.py",
            "description": "This file contains test cases for the flake8-comprehensions C419 rule, demonstrating unnecessary list comprehensions passed to `sum`, `min`, or `max` and their correct generator expression equivalents.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_comprehensions/C417.py",
            "description": "This file serves as a test fixture for the C417 rule (likely from flake8-comprehensions) in the ruff linter, demonstrating various `map()` calls with `lambda` functions that should and should not trigger a linting error.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_comprehensions/C416.py",
            "description": "This file contains various examples of list, set, and dictionary comprehensions, serving as a test fixture for the `flake8_comprehensions` linter rule C416 to identify redundant or potentially refactorable comprehensions.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_comprehensions/C402.py",
            "description": "This file serves as a test fixture for the Flake8-comprehensions C402 rule in Ruff, demonstrating various usages of `dict()` with generator expressions that could be refactored into dictionary comprehensions. It includes regression tests for specific Ruff issues related to this rule.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_comprehensions/C413.py",
            "description": "This file serves as a test fixture for the 'C413' rule within the 'flake8_comprehensions' linter, demonstrating various uses of `reversed(sorted(...))` and `list(sorted(...))` expressions to ensure correct detection and handling by Ruff.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_comprehensions/C420_1.py",
            "description": "Tests the `flake8_comprehensions` C420 rule, specifically for dictionary comprehensions that use `NotImplemented` as a value. This fixture ensures the linter correctly identifies and flags such cases.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_comprehensions/C419_2.py",
            "description": "Tests that the `flake8-comprehensions` C419 rule does not lint when the built-in `all` function is shadowed.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_comprehensions/C411.py",
            "description": "This file serves as a test fixture for the `flake8_comprehensions` C411 rule, demonstrating redundant `list()` calls around list comprehensions. It includes both examples that should trigger the C411 violation and cases that should be skipped due to additional arguments.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_comprehensions/C420.py",
            "description": "This file contains test cases for the RUF025 rule (from flake8_comprehensions) in the Ruff linter, demonstrating both dictionary comprehensions that should trigger a violation and those that should not.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_comprehensions/C405.py",
            "description": "This file contains test cases for the `flake8-comprehensions` C405 rule, demonstrating various `set([...])` and `set((...))` calls, including those within f-strings, which the linter should flag for simplification to set literals.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_comprehensions/C406.py",
            "description": "Test fixture for the `flake8-comprehensions` C406 rule, demonstrating redundant `dict()` calls around literal tuples and lists.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_comprehensions/C409.py",
            "description": "This file serves as a test fixture for the ruff linter, specifically to check the C409 rule from flake8-comprehensions. It contains various examples of redundant tuple calls, including those around list/set literals and comprehensions.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_comprehensions/C418.py",
            "description": "Test fixture for the `flake8-comprehensions` C418 rule, demonstrating various `dict()` calls that should or should not trigger a linting violation for unnecessary dictionary literals.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_comprehensions/C420_3.py",
            "description": "This file contains test cases for the `flake8_comprehensions` linter (rule C420), specifically demonstrating dictionary comprehensions with side-effecting assignment targets that should *not* raise a C420 error, as per issue #19511.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_comprehensions/C420_2.py",
            "description": "This file is a test fixture for the ruff linter's `flake8_comprehensions` rule C420, specifically to ensure that the auto-fix inserts a leading space correctly for dictionary comprehensions when `or` is used.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_comprehensions/C419.py",
            "description": "This file serves as a test fixture for the `flake8_comprehensions` linter, specifically testing rules related to redundant comprehensions (C419). It includes various examples of `any()`, `all()`, `sum()`, `min()`, and `max()` calls with list and set comprehensions, illustrating cases that should or should not trigger linting errors.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_comprehensions/C400.py",
            "description": "This file serves as a test fixture for the `flake8-comprehensions` rule C400 in Ruff, demonstrating various cases where generator expressions passed to `list()` should or should not be converted into list comprehensions. It includes examples of valid and invalid conversions, as well as edge cases like shadowed `list` functions and trailing commas.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_comprehensions/C403.py",
            "description": "This file serves as a test fixture for the Flake8-comprehensions C403 rule, demonstrating various cases where a set comprehension `set([x for x in ...])` could be refactored for conciseness. It includes examples with f-strings, comments, and different formatting.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_comprehensions/C404.py",
            "description": "Test fixture for the `flake8-comprehensions` C404 rule, demonstrating various uses of `dict()` with list comprehensions that could be simplified to dictionary comprehensions, including f-string and regression test cases.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_comprehensions/C401.py",
            "description": "This file contains test cases for the `flake8-comprehensions` linter rule C401, demonstrating various scenarios and edge cases for converting generator expressions to set comprehensions. It includes examples with f-strings, custom `set` functions, and considerations for code fixes like parentheses stripping and trailing commas.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_comprehensions/C415.py",
            "description": "This file contains test cases for the `C415` flake8-comprehensions rule, specifically demonstrating `set()` calls on various list slices that could potentially be replaced by set comprehensions.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_comprehensions/C408.py",
            "description": "This file contains test cases for the `C408` rule of `flake8-comprehensions` in the `ruff` linter, demonstrating various usages of `dict()`, `list()`, and `tuple()` calls, particularly within f-strings and with comments.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_comprehensions/C414.py",
            "description": "This file serves as a test fixture for the `C414` rule of the `flake8_comprehensions` linter, demonstrating various redundant calls to `list()`, `tuple()`, `set()`, and `sorted()` that should be flagged, along with edge cases that should not.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_comprehensions/C417_1.py",
            "description": "Tests `flake8_comprehensions` rule C417, evaluating `map` function calls within `list`, `set`, and `dict` constructors to determine when they should or should not be flagged as unnecessary, covering scenarios like lambda expressions, shadowed built-ins, and walrus operators.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_builtins/A003.py",
            "description": "This file serves as a test fixture for the 'flake8-builtins' linter, specifically for rule A003. It defines classes and methods that intentionally shadow Python built-in names to verify the linter's detection capabilities.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_builtins/A001.py",
            "description": "This file serves as a test fixture for a linter, demonstrating various redefinitions of Python built-in names (e.g., `sum`, `int`, `print`, `id`) which should trigger a linting violation. It also includes examples of magic variables (`__doc__`, `__name__`) that should explicitly *not* cause violations, as per a referenced GitHub issue.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_builtins/A002.py",
            "description": "This file serves as a test fixture for Ruff's `flake8_builtins` linter, specifically for rule A002. It demonstrates various functions with parameters that shadow Python built-in names.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_builtins/A006.py",
            "description": "This file contains test cases for the `flake8_builtins` linter, specifically demonstrating the `A006` rule for built-in names as lambda parameters and its interaction with `A002` in function parameters.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_builtins/A004.py",
            "description": "This file serves as a test fixture for Ruff's `flake8-builtins` linter rule A004, demonstrating code that shadows Python's built-in names through imports and aliases.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_builtins/A005/modules/logging",
            "description": "This directory serves as a test fixture for the `ruff_linter`, specifically designed to evaluate how the linter handles the `flake8_builtins` rule A005. It simulates a Python package structure that includes a 'logging' module to test built-in name shadowing scenarios during linting.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_builtins/A005/modules/utils",
            "description": "This directory serves as a test fixture for the `ruff_linter` crate, specifically designed to test the `flake8_builtins` rule `A005`. It simulates a nested module structure to verify the linter's ability to detect built-in name shadowing within `modules/utils/logging.py`.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_builtins/A005/modules/package",
            "description": "This directory serves as a test fixture for the `flake8_builtins` linter rule A005 within `ruff_linter`. It represents a Python package structure designed to test scenarios involving module names that might shadow standard library or built-in identifiers.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_builtins/A005/modules/non_builtin",
            "description": "This directory contains non-builtin Python modules used as test fixtures for the `ruff_linter`. It specifically serves to evaluate how the linter's `flake8_builtins` rule (A005) handles modules that are not part of Python's standard built-in set. This helps verify the rule's correct identification of built-in vs. non-built-in names.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_builtins/A005/modules/_abc",
            "description": "This directory contains test fixtures for the `A005` rule of the `flake8_builtins` linter within `ruff`. It specifically provides modules, likely simulating scenarios involving the `abc` module or similar built-ins, to verify the linter's correct behavior.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_builtins/A005/modules/string",
            "description": "This directory contains test fixtures for the `ruff_linter`, specifically for the `flake8_builtins` rule `A005`. It simulates a Python module named 'string' to provide a specific context for testing the linter's behavior related to builtins.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_bugbear/B006_3.py",
            "description": "This file is a test fixture for the flake8-bugbear linter, specifically designed to trigger or test the B006 rule regarding mutable default arguments. It includes a function with an empty docstring and a mutable default dictionary parameter.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_bugbear/B002.py",
            "description": "This file serves as a test fixture for the Ruff linter, specifically designed to verify the detection of the `B002` rule (unary operator repeated) from the `flake8-bugbear` plugin.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_bugbear/B006_7.py",
            "description": "This file is a test fixture for the flake8-bugbear B006 rule, demonstrating a mutable default argument within a function that also contains an import statement.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_bugbear/B009_B010.py",
            "description": "This file serves as a test fixture for `flake8-bugbear` rules B009 (invalid `getattr` usage) and B010 (invalid `setattr` usage), showcasing both valid and intentionally invalid patterns for these functions, including various regression tests.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_bugbear/B011.py",
            "description": "Test fixture for the `flake8-bugbear` B011 rule, demonstrating cases where assertion statements without a custom message should be flagged.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_bugbear/B006_2.py",
            "description": "This file is a regression test fixture for the `flake8_bugbear` B006 rule, specifically addressing an issue related to docstring formatting followed by whitespace when detecting mutable default arguments.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_bugbear/B006_1.py",
            "description": "This file is a test fixture for the `ruff` linter, specifically designed to trigger or test the 'mutable default argument' rule (B006) from `flake8-bugbear`.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_bugbear/B006_4.py",
            "description": "This file is a test case for flake8-bugbear B006, specifically demonstrating an issue where a form feed character causes an indentation bug that surfaces during linting for mutable default arguments.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_bugbear/B005.py",
            "description": "This file serves as a test fixture for the Flake8 Bugbear B005 rule, demonstrating various valid and invalid uses of string strip, lstrip, and rstrip methods to check linter warnings.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_bugbear/B003.py",
            "description": "This file serves as a test fixture for the `B003` flake8-bugbear rule, demonstrating cases where direct modification of `os.environ` should be flagged and other similar-looking but valid assignments.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_bugbear/B029.py",
            "description": "This file is a test fixture for the `B029` linter rule, demonstrating various `try...except` and `try...except*` constructs with empty exception type tuples that should trigger the B029 warning.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_bugbear/B013.py",
            "description": "Test file for `flake8-bugbear` rule B013, demonstrating various ways to define exception types in `except` clauses, including tuple unpacking and comments within tuples.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_bugbear/B016.py",
            "description": "This file is a test fixture for the Ruff linter, specifically designed to trigger the B016 (raise-literal-values) rule by demonstrating `raise` statements with non-exception literals.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_bugbear/B017_1.py",
            "description": "Tests the `B017` linter rule by providing examples of `unittest.TestCase.assertRaises` and `pytest.raises` being used with generic exceptions.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_bugbear/B015.py",
            "description": "This file serves as a test fixture for the flake8-bugbear B015 rule, demonstrating various pointless expressions that should or should not trigger a linting warning.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_bugbear/B025.py",
            "description": "This file is a test fixture for the `ruff_linter` to demonstrate and verify the detection of the `B025` error, which flags duplicate exception types in `try...except` blocks.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_bugbear/B006_B008.py",
            "description": "This file contains test cases for `flake8_bugbear` rules B006 (mutable default arguments) and B008 (function calls as default arguments). It demonstrates both valid and invalid default argument patterns to be flagged or ignored by the linter.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_bugbear/B027.py",
            "description": "This file serves as a test fixture for the Ruff linter, specifically to check the `B027` rule from flake8-bugbear. It defines various abstract and non-abstract methods within abstract classes to test cases where empty method bodies (`...` or `pass`) should or should not trigger the B027 error.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_bugbear/B034.py",
            "description": "This file contains test cases for the B034 linter rule, demonstrating correct and incorrect ways to pass flags and counts to `re.sub`, `re.subn`, and `re.split` functions. It differentiates between positional and keyword arguments for these parameters.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_bugbear/B023.py",
            "description": "This file serves as a test fixture for the 'B023' flake8-bugbear rule, demonstrating various scenarios that should and should not trigger late-binding closure warnings for loop variables.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_bugbear/B039.py",
            "description": "This file serves as a test fixture for the `flake8-bugbear` linter rule B039, demonstrating correct and incorrect usage of `ContextVar` with mutable default arguments.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_bugbear/B014.py",
            "description": "This file serves as a test fixture for the ruff linter, specifically designed to trigger and verify the B014 flake8-bugbear rule. It demonstrates various scenarios where an 'except' clause handles redundant or overly broad exception types.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_bugbear/B020.py",
            "description": "This file serves as a test fixture for the `flake8-bugbear` linter rule B020, demonstrating cases where a loop variable is reassigned in an outer scope. It includes examples that should trigger the B020 warning and cases that should not, such as variables within comprehensions.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_bugbear/B022.py",
            "description": "This file is a test fixture for the ruff linter, specifically designed to trigger and test the `flake8-bugbear` rule B022. It demonstrates various uses of `contextlib.suppress`, including cases where it is called without arguments, which should be flagged by the linter.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_bugbear/B033.py",
            "description": "This file serves as a test fixture for the `B033` rule of the `flake8-bugbear` linter within the Ruff project. It includes examples of sets that should trigger the `B033` error (due to duplicate literal values) and examples that should not.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_bugbear/B019.py",
            "description": "This file is a test fixture for the Ruff linter, demonstrating correct and incorrect applications of caching decorators (`@cache`, `@lru_cache`, `@cached_property`) on various types of methods within a class. It specifically targets the `B019` rule, which identifies instances where these decorators are used inappropriately on instance methods.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_bugbear/B021.py",
            "description": "This file serves as a test fixture for the `flake8-bugbear` linter rule B021, demonstrating various cases of f-string usage within docstrings in functions and classes. It highlights where the linter is expected to emit warnings for f-string docstrings.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_bugbear/B904.py",
            "description": "This file is a test fixture for the Flake8-Bugbear rule B904, demonstrating various scenarios involving re-raising exceptions within `except` blocks, including `except*` (ExceptGroup) cases, to test when a warning about unchained exceptions should or should not be emitted.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_bugbear/B006_9.py",
            "description": "This file contains test cases for the `flake8-bugbear` linter (specifically rule B006) to identify functions defined with mutable default arguments versus immutable ones.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_bugbear/B006_6.py",
            "description": "This file is a test fixture for the `flake8-bugbear` linter, demonstrating the B006 rule violation where a function uses a mutable dictionary as a default argument. It also includes an import statement with trailing whitespace, consistent with other related test cases.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_bugbear/B018.py",
            "description": "This file serves as a test fixture for the `B018` rule (useless expression) of the `flake8_bugbear` linter within the Ruff project, demonstrating various expressions that should and should not trigger a linting error.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_bugbear/B004.py",
            "description": "Tests for the `B004` linter rule, which identifies incorrect uses of `hasattr(obj, '__call__')` or `getattr(obj, '__call__', ...)` instead of `callable(obj)` to determine if an object is callable, including examples of valid and invalid calls to these built-in functions.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_bugbear/B006_8.py",
            "description": "This file contains Python functions demonstrating the `flake8-bugbear` B006 rule by using mutable default arguments (lists and dictionaries) before raising various exceptions. It serves as a test fixture for a linter to detect these patterns.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_bugbear/B017_0.py",
            "description": "This file is a test fixture for the Ruff linter's B017 rule (flake8-bugbear), demonstrating various uses of `assertRaises` and `pytest.raises` that should or should not trigger a linting error when catching generic exceptions like `Exception` or `BaseException`.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_bugbear/B024.py",
            "description": "Test fixture for the `B024` rule from `flake8-bugbear`, which checks for abstract base classes that define concrete methods without abstract decorators. It includes various scenarios to verify correct error detection and suppression.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_bugbear/B007.py",
            "description": "This file serves as a test fixture for the Ruff linter, specifically for the `flake8-bugbear` rule B007, which detects unused loop control variables. It provides various examples demonstrating cases where loop variables are unused, used transitively, or affect fixability.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_bugbear/B028.py",
            "description": "This file serves as a test fixture for the B028 rule within the `flake8_bugbear` linter, specifically demonstrating various `warnings.warn` calls to check for correct diagnostic emissions related to `DeprecationWarning` and argument handling.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_bugbear/B006_extended.py",
            "description": "This file is a test fixture for the `flake8-bugbear` linter, specifically for rule B006 concerning mutable default arguments. It examines how the linter handles mutable defaults in conjunction with type annotations, including imported and custom types.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_bugbear/B901.py",
            "description": "Test fixture for the `B901` flake8-bugbear rule, demonstrating cases where a function inappropriately mixes `return` with a value and `yield` statements, and cases where it does not.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_bugbear/B032.py",
            "description": "Tests the `B032` linter rule by providing examples of incorrect dictionary assignments (e.g., `dct.b: 2`) that should be flagged, alongside correct assignments that should not be flagged.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_bugbear/B039_extended.py",
            "description": "This file serves as a test fixture for the `ruff` linter's `B039` rule, demonstrating `ContextVar` initialization with `fastapi.Query` and `Depends` as default values to check for specific linting issues.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_bugbear/B030.py",
            "description": "This file serves as a test fixture for the `flake8-bugbear` linter's B030 rule, demonstrating various valid and invalid `except` clause structures in Python's `try...except` statements. It specifically checks for issues like catching non-exception types or using incorrect tuple nesting/operations within `except` clauses.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_bugbear/B008_extended.py",
            "description": "This file is a test fixture for the `flake8-bugbear` B008 rule, demonstrating various `okay` and `error` cases related to mutable default arguments in function definitions, including those involving external libraries like `fastapi` and `typing.NewType`.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_bugbear/B026.py",
            "description": "This file serves as a test fixture for the `ruff_linter`'s implementation of `flake8_bugbear` rule `B026`. It demonstrates various function calls designed to trigger the `B026` error, which warns about using star-arg unpacking (`*args`) with keyword arguments in a way that might be problematic or confusing.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_bugbear/class_as_data_structure.py",
            "description": "This file contains test fixtures for the `flake8-bugbear` linter rule B903, which flags classes that are effectively data structures without additional methods. It includes examples that should and should not trigger the B903 warning for testing purposes.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_bugbear/B909.py",
            "description": "This file serves as a test fixture for the flake8-bugbear B909 rule, demonstrating various scenarios of mutating collections (lists, dicts, sets) during iteration. It includes examples that should and should not trigger the B909 linter error.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_bugbear/B006_5.py",
            "description": "This file serves as a test fixture for the `ruff` linter's `flake8-bugbear` rule (B006). It demonstrates various incorrect uses of mutable default arguments in function definitions, particularly in conjunction with the placement of `import` statements within function bodies.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_bugbear/B012.py",
            "description": "This file serves as a test fixture for the `B012` rule of the `flake8-bugbear` linter. It illustrates cases where `return`, `break`, or `continue` statements within `finally` blocks should trigger a warning, and cases where they should not.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_bugbear/B911.py",
            "description": "This file serves as a test fixture for the Ruff linter's `flake8-bugbear` rule B911. It demonstrates various uses of the `itertools.batched` function, categorizing them into examples that should produce linter errors and those that should not.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_bugbear/B912.py",
            "description": "This file contains test cases for the `B912` linter rule from `flake8-bugbear`, which checks for `map()` calls that should use `strict=True` when the function requires multiple arguments. It demonstrates both problematic and acceptable uses of `map()` with varying numbers of iterables and the `strict` keyword.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_bugbear/B031.py",
            "description": "This file serves as a test fixture for the ruff linter's `flake8-bugbear` rule B031, demonstrating various scenarios where `itertools.groupby` objects are iterated over multiple times, which can lead to unexpected behavior.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_bugbear/B905.py",
            "description": "This file contains test cases for the `ruff` linter, specifically for the `flake8-bugbear` rule B905, which identifies potentially problematic uses of the `zip` function, including cases with `strict` argument and finite/infinite iterators.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_bugbear/B035.py",
            "description": "This file contains test cases for the `flake8-bugbear` B035 rule, demonstrating both valid and invalid dictionary comprehensions where the key is constant across iterations, which typically indicates a bug.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_errmsg/EM101_byte_string.py",
            "description": "This file contains test cases demonstrating the use of byte strings in exception messages, likely for validating the `EM101` linter rule from `flake8_errmsg`.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_errmsg/EM.py",
            "description": "This file contains various examples of `raise` statements with different exception message formats (literal, f-string, .format(), multi-line, empty, short) and scenarios involving `typing.cast`. It serves as a test fixture for a linter rule, likely EM101, which analyzes exception messages.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_datetimez/DTZ011.py",
            "description": "This file provides test cases for the `DTZ011` rule of `flake8_datetimez`, demonstrating the detection of naive `date.today()` calls, both qualified and unqualified.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_datetimez/DTZ901.py",
            "description": "This file contains test cases for the `flake8-datetimez` linter rule `DTZ901`, demonstrating expected errors and non-errors when using `datetime.datetime.max` and `datetime.datetime.min` with and without timezone-aware operations.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_datetimez/DTZ005.py",
            "description": "This file serves as a test fixture for the `flake8_datetimez` linter, specifically for rule `DTZ005`. It demonstrates various valid and invalid usages of `datetime.datetime.now()` and its chained methods like `astimezone()` and `replace()`.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_datetimez/DTZ004.py",
            "description": "This file serves as a test fixture for the `flake8-datetimez` linter, specifically for rule `DTZ004`. It demonstrates various uses of `datetime.utcfromtimestamp`, including qualified and unqualified calls, and its combination with `.astimezone()`.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_datetimez/DTZ002.py",
            "description": "This file contains test cases for the `flake8-datetimez` linter's `DTZ002` rule, demonstrating various usages of `datetime.today()` that should be flagged.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_datetimez/DTZ006.py",
            "description": "This file is a test fixture for the `flake8_datetimez` linter rule `DTZ006`. It provides examples of `datetime.fromtimestamp` calls to test timezone-related linting, including cases with no arguments, incorrect keywords, `None` arguments, and subsequent `astimezone` calls.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_datetimez/DTZ001.py",
            "description": "This file is a test fixture for the `DTZ001` rule of `flake8-datetimez`. It illustrates different `datetime` object instantiations, particularly concerning the `tzinfo` argument and the `astimezone` method, to test the linter's detection of naive `datetime` objects.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_datetimez/DTZ012.py",
            "description": "This file is a test fixture for the `ruff_linter`, demonstrating qualified and unqualified calls to `date.fromtimestamp`. It is used to test the `flake8_datetimez` rule `DTZ012`, which likely flags this function for creating naive date objects.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_executable/EXE002_2.py",
            "description": "This file is a test fixture for the Flake8 EXE002 rule, demonstrating a simple Python script intended to be executable when run directly.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_executable/EXE003.py",
            "description": "This file is a test fixture for the `flake8_executable` linter, specifically for rule `EXE003`. It's a simple Python script with a bash shebang, used to test executable file parsing or detection.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_executable/EXE001_3.py",
            "description": "This file is a test fixture for the `flake8_executable` linter, demonstrating a basic executable Python script with a shebang line.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_executable/EXE001_2.py",
            "description": "This file is a simple Python script designed to be executable. It serves as a test fixture for the `flake8_executable` linter rule `EXE001`, demonstrating a basic executable Python file.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_executable/EXE002_3.py",
            "description": "This file serves as a test fixture for Ruff's `flake8_executable` linter, specifically to test the `EXE002` rule. It's a simple executable Python script designed to verify linting behavior for such files.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_executable/EXE002_1.py",
            "description": "This file is a test fixture for the `flake8-executable` linter, specifically for the `EXE002` rule. It demonstrates a basic executable Python script designed to be run directly.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_executable/EXE005_1.py",
            "description": "This file is a test fixture for the `flake8-executable` linter, specifically designed to test the `EXE005` rule. It demonstrates a Python script with a shebang.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_executable/EXE001_1.py",
            "description": "This file is a test fixture for the `flake8_executable` linter, specifically for rule `EXE001`. It's a simple Python script designed to be executable, testing the linter's ability to identify executable files.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_executable/EXE004_2.py",
            "description": "This file is a test fixture for the `flake8_executable` linter rule `EXE004`. It verifies that a shebang-like string appearing within quotes is correctly ignored by the linter and not flagged as a missing or invalid shebang.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_executable/EXE003_uv.py",
            "description": "This is a test fixture for `ruff_linter`'s `EXE003` rule, demonstrating a basic Python script that prints 'hello world' and uses a `uv run` shebang.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_executable/EXE005_2.py",
            "description": "This file is a test fixture for `flake8_executable` rule EXE005, demonstrating Python code placed before the shebang line. It's used to verify the linter correctly identifies this specific code structure.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_executable/EXE004_3.py",
            "description": "This file is a test fixture for the `flake8_executable` linter, demonstrating a `pass` statement followed by a shebang line that should trigger an `EXE004` error.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_executable/EXE004_1.py",
            "description": "This file is a test fixture for the Ruff linter, specifically designed to test the `flake8_executable` rule (EXE004). It contains only a shebang to verify how Ruff processes files marked as executable Python scripts.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_executable/EXE004_4.py",
            "description": "This file is a test fixture for the `flake8_executable` linter rule `EXE004`. It contains only a shebang line, likely to test scenarios involving executable Python scripts.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_executable/EXE003_uv_tool.py",
            "description": "This file is a test fixture for the ruff linter, specifically designed to test the EXE003 rule of the flake8_executable plugin when executed via 'uv tool run'.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_executable/EXE005_3.py",
            "description": "This file is a test fixture for the `flake8_executable` linter, specifically for rule `EXE005`. It contains a shebang line and a multi-line docstring that includes a line resembling commented-out code.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_executable/EXE003_uvx.py",
            "description": "This file is a test fixture for the `ruff` linter, designed to demonstrate and test the detection of the `EXE003` error code. It utilizes a custom `uvx ruff check` shebang to simulate specific linting conditions.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_gettext/INT003.py",
            "description": "This file serves as a test fixture for the `flake8_gettext` linter, specifically for rule INT003. It demonstrates various valid and invalid uses of gettext functions with string formatting, including direct calls, aliased imports, and dynamic assignment to builtins, addressing Ruff issue #19028.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_gettext/INT001.py",
            "description": "This file serves as a test fixture for the `flake8_gettext` linter rule in Ruff, demonstrating various usages of gettext functions (e.g., `_`, `gettext`, `ngettext`) with f-strings, including aliasing, deferred translations, and dynamic assignments, to verify correct linting behavior.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_gettext/INT002.py",
            "description": "This file contains test cases for the `flake8_gettext` linter rule, demonstrating various usages of `gettext`, `ngettext`, and `_` functions with string formatting, aliasing, and dynamic assignments, particularly in scenarios related to Ruff issue #19028.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_fixme/T00.py",
            "description": "This file serves as a test fixture for the ruff linter's `flake8_fixme` rule, containing various 'TODO', 'XXX', 'HACK', and 'FIXME' style comments to test its detection capabilities.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_implicit_str_concat/ISC004.py",
            "description": "This file contains test cases for the `flake8-implicit-str-concat` linter rule, specifically `ISC004`, demonstrating implicit string concatenation errors within tuples, lists, and sets due to missing commas.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_implicit_str_concat/ISC_syntax_error_2.py",
            "description": "This file is a regression test fixture for the `flake8-implicit-str-concat` rule in Ruff, designed to test how the linter handles various malformed or unusual string literal syntaxes that could lead to implicit concatenation issues or syntax errors.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_implicit_str_concat/ISC.py",
            "description": "This file contains various test cases for implicit and explicit string concatenation in Python, designed to evaluate linter rules related to string literal merging or concatenation issues.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_implicit_str_concat/ISC_syntax_error.py",
            "description": "This file serves as a test fixture for the `flake8_implicit_str_concat` linter rule, specifically designed to verify its behavior when encountering syntax errors due to unterminated string literals or f-strings in implicitly concatenated string expressions.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_logging/LOG014_1.py",
            "description": "This file is a test fixture for `flake8_logging` (LOG014) demonstrating the use of `logger.info` with `exc_info=True` after a logger is assigned via an inline expression.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_logging/LOG004_1.py",
            "description": "Tests the `flake8_logging` rule LOG004, likely for incorrect usage of `logger.exception` with an empty message.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_logging/LOG015.py",
            "description": "This file serves as a test fixture for the `flake8-logging` linter, specifically for rule LOG015. It demonstrates cases where direct calls to `logging` module functions are flagged as errors, in contrast to calls made through a `Logger` instance, which are not.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_logging/LOG009.py",
            "description": "This file serves as a test fixture for the `ruff_linter`'s `flake8_logging` rule `LOG009`. It demonstrates and validates the linter's detection of `logging.WARN` while correctly ignoring `logging.WARNING`.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_logging/LOG001.py",
            "description": "This file serves as a test fixture for the Ruff linter, specifically to demonstrate and test the LOG001 rule from the flake8-logging plugin. It contains examples of logging logger instantiations.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_logging/LOG007.py",
            "description": "Test fixture for the `LOG007` rule in `flake8-logging`, specifically checking cases where `exc_info` is explicitly set to `False` or an empty list when using `logging.exception` or similar methods.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_logging/LOG004_0.py",
            "description": "Test fixture for the `flake8-logging` linter, specifically for rule LOG004, which checks for `logging.exception` calls used outside of an `except` block. It includes examples that should raise an error and examples that should not.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_logging/LOG002.py",
            "description": "This file serves as a test fixture for the Ruff linter's `flake8_logging` rule `LOG002`. It showcases examples of `logging.getLogger` calls that should and should not be flagged by the linter, particularly when using module-level dunder attributes as arguments.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_logging/LOG014_0.py",
            "description": "This file is a test fixture for a linter, demonstrating rule LOG014 related to `exc_info=True` in logging calls, especially when not within an `except` block.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_logging_format/G003.py",
            "description": "This file is a test fixture for the 'flake8_logging_format' linter, specifically for rule G003. It demonstrates logging calls using string concatenation, which this rule likely flags.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_logging_format/G002.py",
            "description": "This file is a test fixture for a linter, demonstrating the use of 'old-style' string formatting with the '%' operator in logging calls, both directly and after importing logging functions.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_logging_format/G_simple_ok.py",
            "description": "This file is a test fixture for `ruff_linter`'s `flake8_logging_format` rule, demonstrating a simple and correctly formatted logging call that should pass linting checks.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_logging_format/G101_1.py",
            "description": "This file is a test fixture for the `flake8-logging-format` G101 rule, demonstrating `logging.info` calls with an `extra` dictionary for testing purposes.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_logging_format/G004_arg_order.py",
            "description": "This test fixture checks for `flake8-logging-format` (G004) violations when f-strings are used with positional arguments, specifically testing scenarios with incorrect argument order.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_logging_format/G001.py",
            "description": "This file serves as a test fixture for the `flake8-logging-format` linter, demonstrating various logging calls using `str.format()` with the `logging` module and Flask's logger.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_logging_format/G201.py",
            "description": "This file contains test cases for the `flake8-logging-format` linter rule G201, demonstrating correct and incorrect usage of the `exc_info` argument in `logging.error` calls.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_logging_format/G_extra_ok.py",
            "description": "Tests the flake8-logging-format linter's ability to correctly parse logging calls that use an 'extra' dictionary for formatting arguments.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_logging_format/G004_implicit_concat.py",
            "description": "Tests the `flake8_logging_format` G004 rule for implicit string concatenation within f-string arguments passed to logging functions. It demonstrates various scenarios of implicit concatenation with and without f-strings.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_logging_format/G_extra_str_format_ok.py",
            "description": "This file is a test fixture for `flake8-logging-format`, demonstrating a valid logging call where a placeholder in the message string is populated using the `extra` dictionary with `str.format`.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_logging_format/G004.py",
            "description": "This file serves as a test fixture for a linter rule (likely G004) to evaluate the correct and incorrect usage of f-strings within logging statements in various scenarios.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_logging_format/G101_2.py",
            "description": "Test fixture for `flake8-logging-format` rule G101, demonstrating `logging.info` calls with an `extra` dictionary argument.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_logging_format/G202.py",
            "description": "This file serves as a test fixture for the `G202` rule within the `flake8_logging_format` linter plugin, demonstrating correct and incorrect usage of `logging.exception` with `exc_info` in `except` blocks.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_logging_format/G010.py",
            "description": "This file serves as a test fixture for the `ruff` linter, demonstrating various deprecated logging function calls (e.g., `logging.warn`, `warn`) to ensure proper identification and flagging by the linter's `flake8_logging_format` rule G010.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_logging_format/G_argparse_parser_error_ok.py",
            "description": "This file is a test fixture for `flake8-logging-format`, demonstrating the correct usage of `argparse.ArgumentParser.error()` with an f-string for a runtime error message, which should not trigger a linting warning.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_logging_format/G_warnings_ok.py",
            "description": "This file is a test fixture demonstrating the basic usage of the `warnings` module by emitting a simple warning. It likely serves as a positive test case for a linter, indicating expected behavior.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_pie/PIE794.py",
            "description": "This file serves as a test fixture for the `PIE794` linter rule, demonstrating various cases of duplicate class attribute definitions.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_pie/PIE800.py",
            "description": "This file provides test cases for the `flake8_pie` linter rule PIE800, demonstrating valid and invalid usage of dictionary unpacking in Python.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_pie/PIE808.py",
            "description": "This file is a test fixture for the Ruff linter's `flake8-pie` plugin, specifically designed to test the PIE808 rule's detection of `range()` calls with literal zero as the start argument.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_pie/PIE804.py",
            "description": "This file contains test cases for the `PIE804` (DictLiteral) rule from the `flake8-pie` linter, demonstrating various scenarios involving dictionary unpacking in `**kwargs` that should or should not trigger the rule, including cases where autofixing is unsafe.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_pie/PIE796.py",
            "description": "This file contains test cases for the `flake8-pie` linter rule PIE796, which identifies and flags duplicated values within Python enum definitions. It demonstrates various scenarios where enum values are intentionally duplicated to trigger the linter warning, as well as cases that should not trigger it.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_pie/PIE810.py",
            "description": "This file contains test cases for the `flake8-pie` rule PIE810, which detects redundant `startswith` or `endswith` calls chained with `or` that can be consolidated into a single call using a tuple of prefixes or suffixes.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_pie/PIE807.py",
            "description": "This file serves as a test fixture for the `PIE807` linter rule, demonstrating both incorrect and corrected usages of `lambda` expressions for default factories in `dataclass` fields and other class fields.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_pie/PIE790.py",
            "description": "This file contains a comprehensive set of test cases for the `PIE790` linter rule, demonstrating various scenarios involving empty code blocks (using `pass` or ellipsis `...`) in classes, functions, control flow statements, and how docstrings are handled within them. It tests the linter's ability to identify meaningful vs. meaningless `pass` or `...` statements and correct docstring placement.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_print/T203.py",
            "description": "This file is a test fixture for the `flake8_print` linter, demonstrating violations of the T203 rule related to the direct use of `pprint` functions.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_print/T201.py",
            "description": "This file serves as a test fixture for the `T201` linting rule, demonstrating `print` statements that should be flagged when writing to standard output/error and one that is considered acceptable when writing to a file object.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_raise/RSE102.py",
            "description": "This file contains test cases for the `RSE102` linting rule, demonstrating various valid and invalid uses of `raise` statements, particularly focusing on raising exceptions without arguments.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_quotes/docstring_doubles_mixed_quotes_class_var_1.py",
            "description": "This file is a test fixture for the `flake8_quotes` linter in Ruff. It specifically tests the handling of mixed quotes, such as `\"\"'`, when they are used as empty strings rather than actual docstrings, particularly in class definitions, method arguments, and nested class declarations.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_quotes/docstring_doubles_module_multiline.py",
            "description": "This file is a test fixture for `flake8_quotes` in `ruff_linter`, demonstrating its handling of a multiline module docstring and other non-docstring triple-quoted strings at the module level.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_quotes/docstring_singles.py",
            "description": "This file is a test fixture for the `flake8_quotes` linter, demonstrating various examples of single-quoted multiline strings, including valid docstrings for modules, classes, and functions, as well as string literals that are not docstrings, to ensure correct identification.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_quotes/docstring_singles_module_multiline.py",
            "description": "This file is a test fixture for `ruff_linter`'s `flake8_quotes` rule, specifically designed to test the handling of multiline module docstrings enclosed in single quotes, alongside other single-quoted blocks that should not be identified as docstrings.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_quotes/docstring_doubles_module_singleline.py",
            "description": "This file is a test fixture for the `ruff_linter`'s `flake8_quotes` rule. It demonstrates a single-line module docstring enclosed in double quotes, alongside other non-docstring string literals.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_quotes/singles_escaped.py",
            "description": "This file serves as a test fixture for the `flake8_quotes` linter, demonstrating various string and f-string constructions with escaped quotes to verify correct identification of Q003 violations and non-violations.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_quotes/docstring_doubles_mixed_quotes_module_singleline_var_1.py",
            "description": "This file is a test fixture for the `flake8_quotes` linter. It specifically tests how the linter handles module-level string literals with mixed quote styles, including an initial empty string and subsequent single-quoted strings, and how it differentiates them from a true docstring.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_quotes/doubles_all.py",
            "description": "This file serves as a test fixture for the `flake8_quotes` linter, specifically to check its behavior when all strings, including docstrings, inline, and multiline strings, are defined using double quotes.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_quotes/singles.py",
            "description": "This file serves as a test fixture for the `flake8_quotes` linter in Ruff, demonstrating various string literals including single quotes, f-strings, and type hints for linting purposes.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_quotes/docstring_doubles_mixed_quotes_module_singleline_var_2.py",
            "description": "This file is a test fixture for flake8_quotes, designed to verify its handling of non-docstring strings with mixed quotes and concatenation at the module level, as well as strings that appear after function definitions.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_quotes/docstring_singles_mixed_quotes_module_singleline_var_1.py",
            "description": "This file is a test fixture for the `flake8_quotes` linter. It tests how the linter handles mixed quotes in string literals, including those that might be incorrectly identified as module or function docstrings.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_quotes/doubles.py",
            "description": "Test fixture for the ruff linter's flake8_quotes rule, specifically demonstrating various Python string literals defined using double quotes (plain, unicode, and f-strings).",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_quotes/doubles_wrapped.py",
            "description": "This file contains test cases for the `flake8_quotes` linter, specifically demonstrating string literals where quotes of one type are nested within another. It likely tests that these specific patterns are correctly ignored by the linter.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_quotes/docstring_singles_function.py",
            "description": "This file serves as a test fixture for the `flake8_quotes` linter, demonstrating various single-quoted docstring and string literal scenarios within function definitions.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_quotes/doubles_would_be_triple_quotes.py",
            "description": "Tests how the `flake8_quotes` linter handles string concatenation, especially when an empty string is the first part of the concatenation.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_quotes/doubles_escaped_unnecessary.py",
            "description": "This file contains test cases for the `flake8_quotes` linter rule Q004, demonstrating unnecessary escaping of double quotes within single-quoted strings, including regular and f-string examples.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_quotes/singles_would_be_triple_quotes.py",
            "description": "This file serves as a test fixture for the `flake8_quotes` linter in Ruff, demonstrating scenarios involving concatenated single-quoted strings that might be relevant to triple-quote detection or linting.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_quotes/singles_escaped_unnecessary.py",
            "description": "This file serves as a test fixture for the `ruff_linter`'s `flake8_quotes` rule Q004, demonstrating cases where single quotes are unnecessarily escaped within double-quoted strings, including f-strings, nested f-strings, and byte strings.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_quotes/singles_wrapped.py",
            "description": "This file serves as a test fixture for `flake8_quotes` within the ruff linter, demonstrating how different types of nested quotes (single within double, double within single) are handled or ignored by the linter.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_quotes/doubles_implicit.py",
            "description": "This file provides test cases for implicit and explicit multi-line string concatenation and quote usage within parentheses. It serves as a fixture to test `ruff_linter`'s `flake8_quotes` rules.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_quotes/doubles_escaped.py",
            "description": "This file serves as a test fixture for the `flake8_quotes` linter rule Q003, demonstrating various cases of single-quoted strings that should either raise or not raise a diagnostic when containing single quotes, including f-strings and nested f-strings.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_quotes/docstring_singles_mixed_quotes_module_singleline_var_2.py",
            "description": "This file is a test fixture for the `flake8_quotes` linter, designed to check its behavior with module-level string literals that are not docstrings and use mixed single and double quotes.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_quotes/singles_implicit.py",
            "description": "This file serves as a test fixture for the `flake8-quotes` linter rule, demonstrating various scenarios of implicit string concatenation using single quotes, including those with internal double quotes and line continuations.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_quotes/singles_noqa.py",
            "description": "This file is a test fixture for the Ruff linter, specifically for `flake8_quotes` rules. It demonstrates how a single-quoted string with a `# noqa` comment should not trigger a linting error.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_quotes/doubles_multiline_string.py",
            "description": "This file serves as a test fixture for the `flake8_quotes` linter within the Ruff project. It specifically tests how the linter handles multiline strings with various combinations of single and double quotes, including cases that should and should not trigger linting.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_quotes/singles_multiline_string.py",
            "description": "This file serves as a test fixture for the `flake8-quotes` linter, demonstrating its behavior with multiline strings that use single and double quotes, including cases designed to test specific linting rules or their exceptions.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_return/RET501.py",
            "description": "This file serves as a test fixture for the `flake8-return` linter (specifically RET501), demonstrating various cases of `return None` statements in functions, methods, and properties to check for redundant returns.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_return/RET507.py",
            "description": "This file contains test cases for the `flake8-return` linter rule `RET507`, which identifies redundant `else` branches after `continue` statements in loops. It includes examples that should trigger the error and examples that should not.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_return/RET505.py",
            "description": "This file contains test cases for the `flake8_return` rule `RET505` (no-else-return) in the Ruff linter, demonstrating both triggering and non-triggering scenarios for the rule.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_return/RET504.py",
            "description": "This file is a test fixture for the `flake8-return` linter rule `RET504` in Ruff. It contains code examples demonstrating both expected violations and non-violations of the rule, including specific cases from GitHub issues.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_return/RET506.py",
            "description": "This file contains test cases for the Ruff linter rule RET506 (flake8-return), demonstrating code patterns that should and should not trigger the 'no-else-raise' error.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_return/RET508.py",
            "description": "This file contains test cases for the `flake8-return` (RET508) linter rule, demonstrating Python code structures where an `else` clause unnecessarily contains a `break` statement (errors) and valid patterns where it does not (non-errors).",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_return/RET503.py",
            "description": "This file serves as a test fixture for the `flake8-return` linter rule `RET503`, which detects missing explicit return statements at the end of functions. It includes examples that should trigger the error and examples that should not.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_simplify/SIM101.py",
            "description": "This file serves as a test fixture for the `ruff` linter, specifically for the `flake8_simplify` plugin's `SIM101` rule. It demonstrates various `isinstance` checks that should or should not trigger the SIM101 simplification suggestion.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_simplify/SIM105_2.py",
            "description": "Test fixture for the `flake8_simplify` rule SIM105, demonstrating a `try-except` block that can be simplified, with `contextlib` already imported in the file.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_simplify/SIM107.py",
            "description": "This file contains test fixtures for the `flake8_simplify` linter's SIM107 rule, demonstrating 'bad' and 'good' patterns for handling return values within `try...except...finally` blocks.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_simplify/SIM109.py",
            "description": "This file serves as a test fixture for the `flake8_simplify` linter rule SIM109, demonstrating both violations and non-violations of the rule for 'or' conditions.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_simplify/SIM108.py",
            "description": "This file contains test cases for the `SIM108` rule of the `flake8-simplify` linter, demonstrating when an `if/else` statement can be simplified into a conditional expression and when it should not be. It covers various scenarios including comments, complex expressions, and specific Python constructs.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_simplify/SIM112.py",
            "description": "This file serves as a test fixture for the `flake8-simplify` rule SIM112, demonstrating both 'bad' and 'good' practices related to accessing environment variables using `os.environ` and `os.getenv`.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_simplify/SIM102.py",
            "description": "This file serves as a test fixture for the `flake8-simplify` linter, specifically demonstrating cases for the `SIM102` rule, which identifies redundant nested `if` statements. It includes examples that should trigger the rule, cases that are considered acceptable, and scenarios for auto-fixability.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_simplify/SIM105_0.py",
            "description": "This file serves as a test fixture for the `flake8-simplify` rule `SIM105` in the Ruff linter, demonstrating various `try...except` block patterns that should or should not trigger the `SIM105` diagnostic.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_simplify/SIM222.py",
            "description": "This file contains test cases for the Flake8-Simplify rule SIM222, which identifies and flags redundant `or True` expressions in Python code. It demonstrates various scenarios where the rule should and should not trigger, including regression tests for specific Ruff issues.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_simplify/SIM201.py",
            "description": "This file serves as a test fixture for the `SIM201` rule from flake8-simplify, demonstrating code patterns that should trigger the lint (e.g., `if not a == b:`) and those that should be considered acceptable.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_simplify/SIM105_1.py",
            "description": "This file is a test fixture for the `SIM105` Flake8-simplify rule, demonstrating a `try...except pass` block. It specifically tests how `contextlib.suppress` is inserted when another import already exists.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_simplify/SIM210.py",
            "description": "This file contains test cases for the `SIM210` rule of the `flake8_simplify` linter, demonstrating both code that should trigger the rule and code that should not.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_simplify/SIM117.py",
            "description": "This file contains test cases for the flake8-simplify SIM117 rule, which detects and flags overly nested 'with' statements in Python code. It includes examples of both synchronous and asynchronous 'with' statements, along with their expected linting behavior and fixability.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_simplify/SIM911.py",
            "description": "This file is a test fixture for the `SIM911` rule within the `flake8_simplify` linter, demonstrating correct and incorrect usage patterns for iterating over dictionary keys and values using `zip(dict.keys(), dict.values())`.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_simplify/SIM118.py",
            "description": "This file serves as a test fixture for the `SIM118` linter rule (flake8-simplify), demonstrating various code patterns that should trigger or not trigger the rule when checking for membership or iteration over dictionary keys.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_simplify/SIM208.py",
            "description": "This file contains test cases for the `SIM208` rule from the `flake8_simplify` linter, specifically demonstrating double negation (`not (not x)`) patterns that should or should not trigger the linter warning.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_simplify/SIM105_3.py",
            "description": "This file is a test fixture for the `SIM105` rule from `flake8_simplify`, demonstrating a `try-except` block with an empty `except` clause and a `contextlib` import occurring after the call site.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_simplify/SIM116.py",
            "description": "This file serves as a test fixture for the `flake8_simplify` linter, specifically demonstrating cases that trigger or do not trigger the `SIM116` rule for simplifying if/elif/else statements.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_simplify/SIM211.py",
            "description": "This file provides test cases for the `SIM211` rule from `flake8_simplify` within the Ruff linter. It demonstrates `if/else` statements that can be simplified, triggering the `SIM211` diagnostic.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_simplify/SIM220.py",
            "description": "This file serves as a test fixture for the Ruff linter's `flake8_simplify` rule `SIM220`, demonstrating various `if` conditions, including redundant or contradictory logical expressions, for detection and potential simplification.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_simplify/SIM113.py",
            "description": "This file contains test cases for the `SIM113` flake8-simplify rule, demonstrating scenarios where an index variable incremented in a loop could potentially be replaced by `enumerate`, as well as valid cases where `enumerate` is not applicable.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_simplify/SIM905.py",
            "description": "This file contains test cases for the `SIM905` linter rule in Ruff, specifically evaluating various usages and edge cases of Python's `str.split()` and `str.rsplit()` methods.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_simplify/SIM103.py",
            "description": "This file contains test cases for the `flake8-simplify` rule SIM103, which flags `if/else` statements that can be simplified into a direct boolean return. It includes examples that should trigger the rule and examples that should not.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_simplify/SIM115.py",
            "description": "This file serves as a test fixture for the 'SIM115' linting rule in Ruff, demonstrating correct and incorrect ways to open and close file-like objects using various standard library modules, specifically highlighting cases where file handles are not properly managed with context managers.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_simplify/SIM221.py",
            "description": "This file serves as a test fixture for the `flake8-simplify` linter, specifically for rule SIM221, demonstrating various redundant or tautological conditional expressions.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_simplify/SIM111.py",
            "description": "This file contains test cases for the `flake8_simplify` plugin's `SIM110` and `SIM111` rules within the Ruff linter. It demonstrates various `for` loop patterns that can be simplified using `any()` or `all()`.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_simplify/SIM223.py",
            "description": "This file serves as a test fixture for the `flake8-simplify` linter, specifically for the SIM223 rule concerning redundant boolean expressions involving `False` in `and` chains or specific falsy values. It includes various scenarios to test the linter's detection capabilities.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_simplify/SIM202.py",
            "description": "This file contains test cases for the `SIM202` rule from the `flake8_simplify` linter plugin, specifically demonstrating valid and invalid usages of `if not a != b` expressions.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_simplify/SIM401.py",
            "description": "This file serves as a test fixture for the 'SIM401' rule of the flake8-simplify linter, demonstrating various positive and negative cases for simplifying `if key in dict: ... else: ...` constructs into dictionary `.get()` calls or similar patterns.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_simplify/SIM114.py",
            "description": "Test fixtures for the `SIM114` rule in ruff's `flake8_simplify` plugin, demonstrating `if/elif` statements with identical bodies that can be simplified, as well as cases that should not trigger the rule.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_simplify/SIM110.py",
            "description": "This file contains test cases for the `SIM110` (use `any()` for `True` checks) and `SIM111` (use `all()` for `False` checks) linter rules from `flake8_simplify`, demonstrating various scenarios where these rules apply or are intentionally ignored.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_simplify/SIM105_4.py",
            "description": "This file is a test fixture for the Ruff linter, specifically designed to test how it handles a try-except block that imports built-in functions from '__builtin__' for Python 2/3 compatibility, likely in relation to the SIM105 rule.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_simplify/SIM300.py",
            "description": "This file serves as a test fixture for the Ruff linter, specifically to validate the `SIM300` rule from `flake8-simplify`. It contains examples of 'Yoda conditions' (constant-on-left comparisons) that should trigger the `SIM300` error, as well as examples that should pass without error.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_simplify/SIM910.py",
            "description": "This file serves as a test fixture for the Flake8-simplify rule SIM910, demonstrating various scenarios where `dict.get(key, None)` is considered redundant (SIM910) versus acceptable uses of `dict.get()` (OK).",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_simplify/SIM212.py",
            "description": "This file serves as a test fixture for the `SIM212` rule within the `flake8_simplify` linter, demonstrating cases where conditional assignments can potentially be simplified.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_slots/SLOT000.py",
            "description": "This file serves as a test fixture for the `flake8_slots` linter, specifically demonstrating cases related to the SLOT000 rule concerning the use of `__slots__` in classes inheriting from `str` or `Enum`.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_slots/SLOT002.py",
            "description": "This file is a test fixture for the `SLOT002` linter rule in Ruff, demonstrating cases where subclasses of `namedtuple` or `NamedTuple` either incorrectly omit or correctly define `__slots__`.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_slots/SLOT001.py",
            "description": "This file is a test fixture for the `flake8_slots` linter rule `SLOT001` in Ruff. It demonstrates classes inheriting from `tuple` (or `typing.Tuple`) that either correctly define `__slots__` or incorrectly omit them, triggering the `SLOT001` error.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_self/SLF001.py",
            "description": "This file serves as a test case for the `SLF001` linter rule, demonstrating various scenarios of accessing private members (e.g., `_private`, `__really_private`) within and outside class definitions to trigger expected linter warnings.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_self/SLF001_extended.py",
            "description": "This file serves as a test fixture for the Ruff linter, specifically to validate the SLF001 rule regarding access to \"private\" members (prefixed with an underscore).",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_self/SLF001_1.py",
            "description": "This file serves as a test fixture for the `SLF001` linter rule, demonstrating various scenarios where accessing private-like attributes (prefixed with an underscore) within their own class or metaclass is considered acceptable.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_tidy_imports/TID/my_package/sublib/protocol/UpperCaseModule.py",
            "description": "This file is a test fixture for the `flake8_tidy_imports` rule `TID`, designed to test scenarios involving modules with uppercase names.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_tidy_imports/TID/my_package/sublib/api/application.py",
            "description": "This file serves as a core application module within a sub-library's API, orchestrating various components. It imports protocol definitions, server utilities, and local models, indicating its role in handling communication and application logic.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_use_pathlib/PTH203.py",
            "description": "This file is a test fixture demonstrating various calls to `os.path.getatime`, including different argument types and styles, likely for a linter rule checking pathlib usage or `os.path` functions.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_use_pathlib/py_path_1.py",
            "description": "This file tests the `flake8_use_pathlib` linter rule by demonstrating the use of `py.path.local`.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_use_pathlib/PTH206.py",
            "description": "This file serves as a test fixture for the 'PTH206' rule in the ruff linter, demonstrating various string splitting operations using 'os.sep' that should trigger the linting error, alongside examples that are considered 'OK'.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_use_pathlib/import_as.py",
            "description": "This file is a test fixture demonstrating various uses of `os` and `os.path` functions after importing them with aliases, likely to test a linter's ability to detect these calls.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_use_pathlib/use_pathlib.py",
            "description": "This file is a test fixture for the `flake8_use_pathlib` rule within Ruff, demonstrating a specific usage pattern of `pathlib.Path` for linting purposes.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_use_pathlib/py_path_2.py",
            "description": "This test fixture demonstrates the use of `py.path` for file system operations. It is used to test rules related to replacing `py.path` with `pathlib`.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_use_pathlib/PTH202_2.py",
            "description": "Tests the `ruff` linter's `PTH202` rule by providing examples of `os.path.getsize()` calls that should be flagged for refactoring to use `pathlib`.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_use_pathlib/PTH208.py",
            "description": "This file serves as a test fixture for the `PTH208` linter rule, demonstrating various valid and invalid uses of `os.listdir` with different argument types like strings, bytes, pathlib.Path objects, and integers.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_use_pathlib/import_from_as.py",
            "description": "Tests the `flake8_use_pathlib` linter rule by importing `os` and `os.path` functions with `as` aliases and then calling them. It verifies the linter's detection of these aliased `os` and `os.path` function calls.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_use_pathlib/PTH204.py",
            "description": "This file is a test fixture for the `flake8_use_pathlib` linter, specifically for rule `PTH204`. It demonstrates various calls to `os.path.getmtime` with different argument types to be flagged by the linter.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_use_pathlib/PTH210_1.py",
            "description": "This file serves as a test fixture for the 'flake8_use_pathlib' linter, specifically for rule PTH210. It demonstrates various valid and invalid uses of the `Path.with_suffix()` method across different pathlib classes to verify correct linter behavior regarding suffixes that do not start with a dot.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_use_pathlib/PTH207.py",
            "description": "A test fixture for the `ruff_linter` to demonstrate and verify the `PTH207` diagnostic rule, particularly concerning the use of `glob` functions with and without the `dir_fd` argument.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_use_pathlib/PTH205.py",
            "description": "This file is a test fixture demonstrating various calls to `os.path.getctime` using string, bytes, and `pathlib.Path` objects, likely for a linter rule (PTH205) related to `flake8_use_pathlib`.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_use_pathlib/full_name.py",
            "description": "This file serves as a test fixture for the Ruff linter, demonstrating various uses of `os`, `os.path` functions, and `open()` calls, including edge cases and specific argument combinations, likely for `flake8_use_pathlib` diagnostics.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_use_pathlib/PTH123.py",
            "description": "This file serves as a test fixture for the Ruff linter, specifically to check the `PTH123` rule. It contains various `open()` function calls using string paths to verify that the linter correctly flags them for not using `pathlib.Path` objects.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_use_pathlib/PTH210_2.py",
            "description": "This file is a test fixture for the `ruff` linter, specifically for the `flake8_use_pathlib` rule `PTH210`. It demonstrates valid usage of the `.with_suffix()` method across various `pathlib` types without triggering linter errors.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_use_pathlib/import_from.py",
            "description": "This file is a test fixture for the `flake8_use_pathlib` linter rule, demonstrating various imports and usages of `os` and `os.path` functions, along with tests for `open` built-in function shadowing and complex `rename` calls.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_use_pathlib/PTH211.py",
            "description": "This file provides test cases for the `PTH211` rule within `flake8_use_pathlib`, demonstrating when `os.symlink` calls should or should not be refactored to use `pathlib.Path.symlink_to`.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_use_pathlib/PTH201.py",
            "description": "This file serves as a test fixture for the `flake8-use-pathlib` linter, specifically for rule `PTH201`. It demonstrates various `pathlib.Path` instantiations that should (or should not) trigger the linter rule, including cases with comments and path concatenations.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_use_pathlib/PTH210.py",
            "description": "This file serves as a test fixture for the `flake8-use-pathlib` linter rule `PTH210`, demonstrating correct and incorrect usages of the `Path.with_suffix()` method, particularly regarding the requirement of a leading dot for the suffix argument.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_use_pathlib/PTH202.py",
            "description": "This file is a test fixture demonstrating various invocations of `os.path.getsize` with different argument types (strings, bytes, Path objects, variables) and formatting, likely to test a linter's ability to identify `os.path.getsize` calls for potential refactoring to `pathlib.Path.stat().st_size`.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_todos/TD002.py",
            "description": "This file serves as a test fixture for the `flake8_todos` linter, specifically for rule `TD002`. It demonstrates various accepted and erroneous formats of TODO comments, primarily focusing on the presence or absence of an author.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_todos/TD006.py",
            "description": "This file serves as a test fixture for the Ruff linter, specifically to validate the `TD006` rule for `flake8_todos`. It includes examples of both accepted and rejected TODO comment formats based on capitalization.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_todos/TD007.py",
            "description": "This file serves as a test fixture for the `flake8_todos` linter rule `TD007`, demonstrating scenarios where a space is either present or absent after a colon in `TODO` comments.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_todos/TD001.py",
            "description": "This file serves as a test fixture for the `flake8_todos` linter, specifically for rule TD001. It provides examples of valid and invalid TODO-style comments to test the linter's detection logic.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_todos/TD005.py",
            "description": "This file is a test fixture for the 'flake8_todos' linter, specifically for rule TD005. It demonstrates various forms of TODO and FIXME comments to test how the linter identifies those with and without descriptive text.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_todos/TD004.py",
            "description": "This file serves as a test fixture for the Ruff linter, specifically for the `flake8_todos` rule `TD004`. It contains various TODO and FIXME comments to test the rule's enforcement of colon usage after the tag or author.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_todos/TD003.py",
            "description": "This file serves as a test fixture for the `flake8_todos` linter rule TD003. It demonstrates various valid and invalid `TODO` comment formats, specifically testing the presence or absence of associated links or issue identifiers.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_unused_arguments/ignore_variadic_names.py",
            "description": "This file serves as a test fixture for the 'flake8-unused-arguments' linter rule, specifically to ensure that variadic arguments like '*args' and '**kwargs' are correctly ignored when checking for unused parameters.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_unused_arguments/ARG.py",
            "description": "Test fixture for the `flake8-unused-arguments` linter rule, demonstrating various scenarios of used and unused function arguments in functions, methods, lambdas, and special cases like abstract methods, overrides, and overloads.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/numpy/NPY001.py",
            "description": "This file serves as a test fixture for the Ruff linter, specifically to test the NPY001 rule related to deprecated NumPy scalar types and aliases. It includes various usages of `np.float`, `np.int`, and `np.object` to trigger linting errors.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flynt/FLY002.py",
            "description": "This file serves as a test fixture for the Ruff linter, specifically for the FLY002 rule. It demonstrates various `str.join()` patterns, categorizing them as 'OK' or 'Not OK' to validate the linter's behavior in identifying string concatenations suitable for transformation or flagging.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pep8_naming/N801.py",
            "description": "This file serves as a test fixture for the Ruff linter, demonstrating various class naming conventions to test for PEP 8 (N801) violations where class names are not in CamelCase.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pep8_naming/N812.py",
            "description": "This file is a test fixture for the ruff linter, specifically designed to trigger the N812 PEP8 naming violation for uppercase aliases in import statements.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pep8_naming/N818.py",
            "description": "This file contains various custom exception class definitions, serving as a test fixture for the `N818` PEP 8 naming rule in Ruff, which likely checks naming conventions for exceptions.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pep8_naming/N813.py",
            "description": "This file is a test fixture for PEP8 naming rule N813, demonstrating aliasing of CamelCase module or class imports to snake_case variables.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pep8_naming/N816.py",
            "description": "This file is a test fixture for the Ruff linter's `N816` rule (Constant name does not conform to UPPER_CASE naming style), demonstrating various variable and type naming conventions to be checked or ignored by the linter.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pep8_naming/N811.py",
            "description": "This file is a test fixture for the `N811` PEP8 naming rule, demonstrating how the linter handles aliasing of constants and other names during import statements.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pep8_naming/N807.py",
            "description": "This file serves as a test fixture for the `pep8_naming` linter rule N807, demonstrating examples of function and method names that should or should not trigger a linting violation related to leading/trailing double underscores.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pep8_naming/N804.py",
            "description": "This file serves as a test fixture for the 'pep8_naming' linter rule N804, demonstrating various scenarios of correct and incorrect first argument names (like 'self', 'cls', 'this') in instance, class, and static methods.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pep8_naming/N817.py",
            "description": "This file is a test fixture for the ruff linter's `pep8_naming` rule N817, demonstrating various import alias conventions, including both compliant and non-compliant examples.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pep8_naming/N815.py",
            "description": "This file serves as a test fixture for the `ruff` linter's `pep8_naming` rule `N815`, demonstrating various class attribute naming conventions, including those within `namedtuple` and `TypedDict` definitions.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pep8_naming/N802.py",
            "description": "This file serves as a test fixture for a linter's N802 rule, demonstrating various function and method naming conventions (both compliant and non-compliant) including overrides and specific class method patterns.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pep8_naming/N803.py",
            "description": "This file contains test cases for the `N803` (invalid argument name) rule of the `pep8-naming` linter, demonstrating various argument naming conventions including special cases like `_`, `setUp`, and `typing.override`.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pep8_naming/N805.py",
            "description": "This file serves as a test fixture for the 'pep8-naming' linter rule N805, which identifies methods using incorrect first argument names like 'this' instead of 'self' or 'cls'. It demonstrates various valid and invalid method definitions across different class types and decorators to test the rule's detection capabilities.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pep8_naming/N814.py",
            "description": "Test fixture for the N814 (Bad constant name) PEP8 naming convention rule, specifically for `import ... as ALL_CAPS` aliases from modules with CamelCase names. It demonstrates cases that should trigger the N814 error and cases that should pass.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pep8_naming/N806.py",
            "description": "This file serves as a test fixture for the Ruff linter, specifically demonstrating cases that should or should not trigger the `N806` PEP8 naming convention rule, which typically addresses CamelCase variable names that are not class definitions or constants.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pep8_naming/ignore_names/N801.py",
            "description": "This file contains class definitions with non-PEP8 compliant names, used as test fixtures to verify that specific names are ignored by the N801 rule in the `pep8_naming` linter.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pep8_naming/ignore_names/N804.py",
            "description": "This file provides test cases for the `pep8-naming` linter rule N804, demonstrating class methods that should be ignored due to specific naming patterns or configurations.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pep8_naming/ignore_names/N806.py",
            "description": "Test fixture for PEP8 Naming convention N806, demonstrating variable names that might be ignored or specifically handled for style violations within a test suite.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pep8_naming/ignore_names/N813.py",
            "description": "Tests the N813 linter rule's handling of 'import as' aliases for module-level constants. It specifically checks if aliases with non-conforming names are correctly identified or ignored.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pep8_naming/ignore_names/N817.py",
            "description": "This file is a test fixture for the `pep8_naming` rule N817 (invalid alias name) within Ruff, demonstrating imports with aliasing. It likely tests scenarios where certain alias names might be ignored or flagged by the linter.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pep8_naming/ignore_names/N815.py",
            "description": "This file serves as a test fixture for the `ruff` linter's `N815` rule, demonstrating various class attribute naming conventions, including those that should trigger or be ignored by the rule, in both regular classes and TypedDicts.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pep8_naming/ignore_names/N807.py",
            "description": "Test fixture for the N807 PEP 8 naming rule, specifically examining how it handles dunder-named functions within ignored name patterns.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pep8_naming/ignore_names/N818.py",
            "description": "This file serves as a test fixture for the `ruff` linter's `pep8_naming` rule (N818), containing class definitions with non-PascalCase names. It is used to test the linter's behavior when such names are expected to be ignored.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pep8_naming/ignore_names/N803.py",
            "description": "This file is a test fixture for the ruff linter's PEP8 naming rules, specifically for `N803` (invalid function parameter name). It demonstrates scenarios with intentionally ignored parameter names like `_` and potentially `badAllowed` to verify correct linting behavior.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pep8_naming/ignore_names/N802.py",
            "description": "This file is a test fixture for the `ruff` linter's `pep8_naming` rule `N802`, demonstrating function and method names that violate the snake_case convention. It likely tests how the linter identifies or ignores these specific naming violations.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pep8_naming/ignore_names/N811.py",
            "description": "This file is a test fixture for the Ruff linter, demonstrating PEP8 naming violations (N811) related to aliased imports. It likely tests how the linter handles specific cases of constant names being imported with non-constant aliases.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pep8_naming/ignore_names/N812.py",
            "description": "This file contains Python import statements with aliases that violate PEP8 naming conventions (N812). It serves as a test fixture to verify the linter's behavior when these specific alias names are configured to be ignored by the N812 rule.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pep8_naming/ignore_names/N814.py",
            "description": "This file is a test fixture for the N814 PEP8 naming rule, demonstrating various import aliasing patterns. It tests how the linter handles importing CamelCase names as UPPER_CASE or UPPER_SNAKE_CASE aliases.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pep8_naming/ignore_names/N805.py",
            "description": "This file serves as a test fixture for the `N805` rule (first argument of a method should be 'self') in the Ruff linter. It demonstrates various method definitions using `this` or `cls` as the first argument, including those with `pydantic.validator`, `@classmethod`, and `@abc.abstractclassmethod` decorators, to test the linter's behavior in identifying or ignoring N805 violations in specific contexts.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pep8_naming/ignore_names/N816.py",
            "description": "This file serves as a test fixture for the `pep8_naming` linter, specifically demonstrating variable names that might trigger or be ignored by rule N816 (Constant name not uppercase).",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pep8_naming/ignore_names/N999/badAllowed",
            "description": "This directory provides test fixtures for the `ruff_linter`'s `pep8_naming` checks, particularly for the `N999` rule. It contains examples illustrating how the `ignore_names` configuration behaves when handling names that are considered 'bad' by the linter but are specified to be allowed. These tests ensure the ignore mechanism correctly identifies and processes such exceptions.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pep8_naming/N999/module/no_module",
            "description": "This directory functions as a test fixture for the `ruff_linter`, specifically targeting the `N999` rule within the `pep8_naming` checks. Its emptiness and name 'no_module' indicate it tests the linter's behavior in scenarios where no module files are found, verifying correct handling of such cases.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pep8_naming/N999/module/MODULE",
            "description": "This directory serves as a test fixture for the `N999` PEP8 naming rule within the `ruff_linter` crate. It defines a specific module structure to be analyzed and validated by the linter, ensuring correct identification of naming convention violations or adherence.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pep8_naming/N999/module/mod-with-dashes",
            "description": "This directory serves as a test fixture for the `ruff_linter` crate, specifically targeting the `pep8_naming` rule `N999`. It provides a Python package named `mod-with-dashes` to test scenarios involving module names with hyphens, which typically trigger a linting error.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pep8_naming/N999/module/invalid_name",
            "description": "This directory contains test fixtures for the `ruff_linter`, specifically for the `pep8_naming` rule `N999` related to invalid module names. It provides Python files designed to trigger violations of this naming convention, serving as test cases for the linter.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pep8_naming/N999/module/mod with spaces",
            "description": "This directory serves as a test fixture for the `ruff_linter` to evaluate `pep8_naming` rule `N999`. It simulates a Python module where the directory name contains spaces, testing how the linter handles such naming conventions.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pep8_naming/N999/module/valid_name",
            "description": "This directory serves as a collection of test fixtures for the `ruff_linter`. It contains Python module files designed to represent valid names under the `pep8_naming` rule `N999`, ensuring the linter correctly identifies them as such.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pep8_naming/N999/module/flake9",
            "description": "This directory contains test fixtures for the `ruff_linter`'s `pep8_naming` rule `N999`. It likely provides example code to verify `ruff`'s detection of module-level naming violations, potentially in comparison to how `flake8` handles such cases.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/perflint/PERF203.py",
            "description": "This file serves as a test fixture for the 'PERF203' linter rule, demonstrating both code that violates the rule (a `try-except` block inside a `for` loop) and acceptable alternatives or exceptions to the rule.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/perflint/PERF403.py",
            "description": "This file contains test cases for the `PERF403` rule in the Ruff linter, showcasing various scenarios for dictionary creation within loops, including violations and edge cases, to ensure correct detection and false-negative handling.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/perflint/PERF402.py",
            "description": "This file contains test cases for the `perflint` rule `PERF402` within the Ruff linter, demonstrating code patterns that should and should not trigger this performance-related diagnostic.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/perflint/PERF101.py",
            "description": "This file is a test fixture for the `perflint` linter, specifically designed to test the PERF101 rule. It contains various examples of `list()` calls on different iterable types within `for` loops, demonstrating both expected violations and valid patterns.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/perflint/PERF401.py",
            "description": "This file contains test cases for the Ruff linter's PERF401 rule, which identifies inefficient list appends in loops. It demonstrates various scenarios where list comprehensions could be used, including both violations and non-violations, and covers edge cases like comment preservation, variable scoping, and async functions.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/perflint/PERF102.py",
            "description": "This file contains test cases for the `PERF102` linter rule, demonstrating scenarios where dictionary iteration unpacks items that are partially or fully unused, along with examples that should and should not trigger the diagnostic.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pycodestyle/E21.py",
            "description": "This file serves as a test fixture for the Ruff linter, specifically to test the detection of pycodestyle E21x violations (whitespace around parentheses and brackets) and other code style issues.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pycodestyle/E2_syntax_error.py",
            "description": "This file is a test fixture for the `pycodestyle` linter, specifically designed to trigger an `E2` syntax error due to an incomplete `or` expression within a tuple.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pycodestyle/E24.py",
            "description": "This file serves as a test fixture for the `pycodestyle` linter, specifically designed to test and demonstrate error codes E241 and E242 related to inconsistent spacing around operators and punctuation.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pycodestyle/E101.py",
            "description": "This file serves as a test fixture for the Ruff linter, specifically designed to test the `E101` pycodestyle rule which detects mixed tabs and spaces for indentation.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pycodestyle/E11.py",
            "description": "This file serves as a test fixture for the Ruff linter, providing various Python code snippets designed to trigger and verify the detection of specific pycodestyle E11x indentation and whitespace errors.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pycodestyle/E303_first_line_comment.py",
            "description": "Test fixture for pycodestyle E303, demonstrating a violation with too many blank lines after a leading comment.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pycodestyle/E26.py",
            "description": "This file serves as a test fixture for the `pycodestyle` rules within the `ruff` linter, specifically demonstrating various scenarios related to comment formatting and placement (E26x and W291). It includes examples designed to trigger or pass specific linter checks for comments.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pycodestyle/E30.py",
            "description": "This file contains test fixtures for `pycodestyle` (E30x) errors related to incorrect blank lines around code blocks, functions, and classes. Each section demonstrates either a 'no error' case or a specific E30x violation.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pycodestyle/E20.py",
            "description": "This file contains test cases for the `pycodestyle` linter, specifically for rules E201, E202, and E203, which concern whitespace issues around parentheses, brackets, braces, and colons in Python code. It includes examples that should trigger these errors and examples that should pass ('Okay').",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pycodestyle/E402_1.py",
            "description": "This file is a test fixture for Pycodestyle's E402 rule, demonstrating import statements separated by docstrings to trigger the 'module level import not at top of file' error.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pycodestyle/E303_first_line_statement.py",
            "description": "This file is a test fixture for the Pycodestyle E303 rule. It demonstrates a violation where extra blank lines follow an initial statement on the first line of the file.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pycodestyle/E303_first_line_docstring.py",
            "description": "This file is a test fixture for the pycodestyle E303 rule, specifically designed to check for excessive blank lines after a module-level docstring before a function definition.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pycodestyle/E25.py",
            "description": "This file serves as a test fixture for the Ruff linter, specifically for pycodestyle rules related to whitespace around operators and default parameter values (E251, E252, E271). It includes examples that should trigger these linter warnings and cases that are considered 'Okay'.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pycodestyle/E302_first_line_statement.py",
            "description": "This file is a test fixture for pycodestyle rule E302, demonstrating a violation where a function definition immediately follows a statement on the first line without a blank line in between.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pycodestyle/E40.py",
            "description": "This file serves as a test fixture for the pycodestyle E40 rules within the ruff linter. It demonstrates various import statement patterns, including multiple imports on one line (E401) and imports not at the top of the file (E402), to test linter behavior.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pycodestyle/E501.py",
            "description": "This file serves as a test fixture for the pycodestyle E501 rule (line too long), demonstrating various scenarios including long strings, comments, URLs, and docstrings that trigger or suppress this specific linting error.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pycodestyle/E204.py",
            "description": "This file is a test fixture for the Ruff linter, designed to verify the Pycodestyle E204 rule regarding whitespace after the '@' symbol in decorators. It provides examples of both valid and invalid decorator syntax to test the linter's detection capabilities.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pycodestyle/E711.py",
            "description": "This file serves as a test fixture for the pycodestyle E711 rule within the Ruff linter, demonstrating cases where comparison with 'None' using '==' or '!=' should trigger a warning.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pycodestyle/E30_syntax_error.py",
            "description": "This file is a test fixture designed to trigger and check for Pycodestyle E30 errors, specifically those arising from various syntax errors like unclosed parentheses and malformed blocks.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pycodestyle/E501_4.py",
            "description": "This file is a regression test for Ruff issue #12130, likely testing `pycodestyle` rule E501 (line too long) with unusual characters or line breaks.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pycodestyle/W293.py",
            "description": "This file contains test cases for the `pycodestyle` W293 rule, demonstrating various instances of trailing whitespace that the linter should detect.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pycodestyle/E302_first_line_expression.py",
            "description": "This file is a test fixture for the Pycodestyle E302 rule, demonstrating a violation where a function definition follows an expression on the first line without the required blank lines.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pycodestyle/E302_first_line_docstring.py",
            "description": "This test fixture for `pycodestyle`'s E302 rule verifies the correct handling of blank lines between a module-level docstring and the first function definition.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pycodestyle/E303_first_line_expression.py",
            "description": "This test fixture is designed to trigger a pycodestyle E303 violation (too many blank lines) when the first line of the file contains an expression, specifically a string literal, followed by excessive blank lines before a function definition.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pycodestyle/E741.py",
            "description": "This file contains various examples of variable assignments and uses of the lowercase letter 'l' (and 'I', 'O'), likely serving as a test case for a linter rule (E741) related to ambiguous variable names.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pycodestyle/E742.py",
            "description": "This file contains example classes with ambiguous names (like 'l', 'I', 'O', 'X') to serve as a test fixture for the Pycodestyle E742 error, which flags such naming conventions.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pycodestyle/E501_1.py",
            "description": "This file serves as a test fixture for the Ruff linter, specifically to check how it handles pycodestyle E501 (line length) violations in comments, especially those containing 'TODO' or 'FIXME' tags.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pycodestyle/E402_0.py",
            "description": "This file is a test fixture for the `pycodestyle` E402 rule, demonstrating various import statement placements and styles within a Python module. It is used to verify the linter's behavior with imports that are not at the top of the file.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pycodestyle/E23.py",
            "description": "Test fixtures for the `E231` pycodestyle rule, demonstrating expected and unexpected whitespace after commas in various Python constructs, including collections, f-strings, and PEP 696 type parameter lists.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pycodestyle/E402_2.py",
            "description": "This file tests the `pycodestyle` E402 rule by performing environment variable operations (`os.environ`, `os.putenv`) before a module import (`import torch`). It demonstrates a scenario where an import is not at the very top of the file.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pycodestyle/E501_2.py",
            "description": "This file serves as a test fixture for the `E501` (line too long) rule in the `ruff_linter`, demonstrating its behavior with `noqa` directives.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pycodestyle/E22.py",
            "description": "This file contains test cases for Pycodestyle E22x errors, which relate to incorrect whitespace around operators. It includes examples that should trigger these linter warnings and examples that are considered 'Okay'.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pycodestyle/E743.py",
            "description": "This file is a test fixture for pycodestyle rule E743, demonstrating the use of ambiguous single-character identifiers (like 'l', 'I', 'O') that can be confused with numbers or other characters.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pycodestyle/W291.py",
            "description": "This file serves as a test fixture for `pycodestyle` rule W291, demonstrating various cases of trailing whitespace, including within multiline strings and f-string expressions, to ensure proper detection by the linter.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pycodestyle/constant_literals.py",
            "description": "This file serves as a test fixture for the pycodestyle linter, specifically demonstrating cases that trigger and do not trigger F632 (comparing literals with 'is'), E711 (comparing with None), and E712 (comparing with True/False) errors.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pycodestyle/W292_0.py",
            "description": "Test fixture for pycodestyle W292, demonstrating a Python file without a trailing newline at the end of the file.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pycodestyle/E402_4.py",
            "description": "This Python file serves as a test fixture for the E402 rule in the ruff linter, demonstrating a module-level import that is not at the top of the file due to preceding `sys.path` modifications.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pycodestyle/W391_2.py",
            "description": "This file is a test fixture for the pycodestyle W391 rule, demonstrating a Windows-style file ending with multiple blank lines to be flagged by the linter.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pycodestyle/W391_1.py",
            "description": "This file is a test fixture for the pycodestyle W391 rule, demonstrating a violation related to trailing blank lines at the end of the file before the main execution block.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pycodestyle/W605_0.py",
            "description": "This file contains test cases for the `W605` rule (invalid escape sequence) in Pycodestyle. It includes various string and regex literals, demonstrating both valid and invalid escape sequences to verify linter behavior.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pycodestyle/E721.py",
            "description": "This file serves as a test fixture for the Ruff linter, specifically designed to check the detection of E721 (comparison to type) and E722 (bare except) violations, along with various acceptable type comparison patterns.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pycodestyle/W391_3.py",
            "description": "This file is a test fixture for the `pycodestyle` W391 rule, demonstrating a Python script with extra blank lines at the end of the file. It's used to verify detection of superfluous blank lines at EOF.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pycodestyle/W391_0.py",
            "description": "This file is a test fixture for the Pycodestyle W391 rule, demonstrating a violation with excessive trailing blank lines before the `if __name__` block.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pycodestyle/W29.py",
            "description": "This file serves as a test fixture for the Ruff linter, specifically to check its detection of pycodestyle warnings related to whitespace (W291, W292, W293) and line endings.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pycodestyle/E402_5.py",
            "description": "This file is a test fixture for the Ruff linter, demonstrating an E402 (module level import not at top of file) scenario where `sys.path` is modified before the import, to check linter behavior.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pycodestyle/E713.py",
            "description": "Tests the Ruff linter's ability to detect and flag Pycodestyle E713 violations, specifically the use of 'not X in Y' instead of 'X not in Y'. It includes both error-triggering and correct/okay examples.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pycodestyle/E501_3.py",
            "description": "This file is a test fixture for the Ruff linter, designed to verify its detection of Pycodestyle E501 (line too long) errors. It includes examples demonstrating line length calculations, particularly around `type: ignore` comments.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pycodestyle/W292_2.py",
            "description": "This file is a test fixture for the `pycodestyle` linter, specifically designed to ensure that a newline at the end of the file does not trigger a W292 error.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pycodestyle/E27.py",
            "description": "This file serves as a test fixture for the `ruff` linter, specifically to validate its implementation of pycodestyle's E27 rule family. It includes various code examples demonstrating correct and incorrect spacing around binary operators and after keywords, expecting specific E27x linting errors.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pycodestyle/W605_1.py",
            "description": "This file serves as a test fixture for Ruff's `pycodestyle` W605 rule, specifically demonstrating and testing invalid escape sequences within f-strings and t-strings, including various string literal types and edge cases.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pycodestyle/W505.py",
            "description": "This file serves as a test fixture for the Ruff linter, specifically designed to demonstrate and test the `W505` (line too long) Pycodestyle rule across various code elements like docstrings, comments, and string literals.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pycodestyle/W292_1.py",
            "description": "This file is a test fixture for the Pycodestyle W292 rule, demonstrating a case with no trailing newline, explicitly ignored by a `noqa` comment.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pycodestyle/shebang.py",
            "description": "This file serves as a test fixture for the ruff linter, specifically to test its handling and validation of shebang lines in Python files according to pycodestyle rules.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pycodestyle/W505_utf_8.py",
            "description": "This file is a test fixture for the Pycodestyle W505 rule, designed to check line length violations with various string and comment types that include multi-byte UTF-8 characters.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pycodestyle/E731.py",
            "description": "This file serves as a test fixture for a Python linter, specifically demonstrating cases that should and should not trigger the `E731` (lambda assignment) rule, including various type-hinting and syntax edge cases.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pycodestyle/E722.py",
            "description": "This file serves as a test fixture for the `ruff_linter` to evaluate the `pycodestyle` rule E722, which identifies and flags bare `except` statements. It includes examples of bare `except` blocks expected to trigger the E722 error and valid `except` clauses.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pycodestyle/E712.py",
            "description": "This file serves as a test fixture for the Pycodestyle E712 rule within the Ruff linter, demonstrating various code examples that should and should not trigger the 'comparison to True or False should be avoided' diagnostic.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pycodestyle/W19.py",
            "description": "This file serves as a test fixture for the `pycodestyle` linter, specifically to test and demonstrate various indentation and whitespace-related warnings and errors, including tab usage (W191) and mixed indentation (E101).",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pycodestyle/E70.py",
            "description": "This file serves as a test fixture for the Ruff linter, containing various Python code snippets designed to trigger and verify the detection of specific pycodestyle E70x errors related to multiple statements on a single line, semicolons, and implicit returns.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pycodestyle/E402_3.py",
            "description": "This file is a test fixture for the `pycodestyle` linter, specifically designed to trigger an E402 error for module-level imports not being at the top of the file.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pycodestyle/E714.py",
            "description": "This file contains test cases for the `E714` pycodestyle rule within the Ruff linter, demonstrating both code that should trigger the error (`not X is Y`) and acceptable alternatives (`X is not Y`).",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pycodestyle/E502.py",
            "description": "This file serves as a test fixture for the Ruff linter, demonstrating various valid and potentially redundant line continuation styles in Python, especially in the context of the Pycodestyle E502 rule. It includes examples of line continuations in expressions, data structures, and string literals.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pycodestyle/W391_4.py",
            "description": "This file is a test fixture for the pycodestyle W391 rule, demonstrating a code snippet that should not trigger the W391 warning.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pycodestyle/E302_first_line_function.py",
            "description": "Test fixture for pycodestyle E302, demonstrating multiple function definitions separated by an insufficient number of blank lines.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyflakes/F401_22.py",
            "description": "This file is a test fixture for Pyflakes rule F401, designed to ensure that the linter recursively visits type definitions and lambda functions to detect unused imports within them.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyflakes/F401_3.py",
            "description": "Tests the `F401` Pyflakes rule, specifically how it handles referencing an imported module (`numpy`) through a `TypeAlias` while considering Python version compatibility for `TypeAlias` and future annotations.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyflakes/F401_2.py",
            "description": "This file tests the usage of `TypeAlias` to define a custom type alias referencing imported modules, specifically `numpy` types. It includes conditional import of `TypeAlias` based on Python version.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyflakes/F402.py",
            "description": "Tests linter detection of shadowing built-in module imports like 'os' and 'os.path' with local loop variables.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyflakes/F401_5.py",
            "description": "This file is a test fixture for the ruff linter, demonstrating various multi-segment and aliased import statements to test the F401 (unused import) rule.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyflakes/F401_13.py",
            "description": "Tests that `pyflakes` correctly identifies unused imports (F401) when module bindings are preferred over local bindings for deferred annotations, specifically when a local `TypeAlias` shadows an imported type in a type hint.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyflakes/F401_18.py",
            "description": "Tests how the linter identifies unused `__future__` imports, specifically distinguishing between a bare import and one where an attribute from `__future__` is accessed.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyflakes/F401_30.py",
            "description": "This file is a test fixture for the Pyflakes F401 rule, designed to ensure that unused imports containing characters requiring NFKC normalization are correctly identified and removed.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyflakes/F401_21.py",
            "description": "This file is a test fixture for the Pyflakes F401 rule (unused import), specifically designed to ensure that the linter correctly processes imports used within type definitions and lambdas.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyflakes/F401_31.py",
            "description": "This file serves as a test fixture for the `ruff` linter, specifically for the `F401` (unused imports) rule. It demonstrates how `ruff` should handle various `hvplot.pandas` import statements, including alias imports, distinguishing between allowed and erroneous cases.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyflakes/F401_14.py",
            "description": "This file is a test fixture for Pyflakes F401, demonstrating how module-level bindings are preferred for deferred type annotations, specifically for `datetime.datetime` within a class.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyflakes/F401_34.py",
            "description": "This file contains regression tests for `ruff`'s `F401` (unused import) rule, specifically for `TypeAliasType` definitions that use `Union` in string-based type annotations. It demonstrates various ways to define recursive `TypeAliasType` to ensure `ruff` correctly identifies used imports.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyflakes/F401_23.py",
            "description": "This file is a test fixture for the `ruff` linter, specifically for the `F401` (unused imports) rule. It demonstrates and verifies how `ruff` treats string literal type annotations within `typing.Annotated`.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyflakes/F401_6.py",
            "description": "This file is a test fixture for the Pyflakes F401 rule in the Ruff linter, demonstrating various scenarios of unused imports and explicit re-exports.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyflakes/F401_17.py",
            "description": "This file is a test fixture for Pyflakes F401, demonstrating how runtime typing references are attributed to scoped imports when `TYPE_CHECKING` and inner function imports are present.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyflakes/F401_10.py",
            "description": "This file tests how `ruff`'s linter handles imports that occur within `ModuleNotFoundError` and `ImportError` exception handlers. It specifically checks scenarios related to the `F401` rule concerning unused imports.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyflakes/F401_12.py",
            "description": "Tests how Pyflakes' F401 rule handles deferred annotations (`from __future__ import annotations`) where a module-level import is used within a type hint, specifically when distinguishing between module and local bindings.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyflakes/F401_16.py",
            "description": "Tests how the `pyflakes` linter handles `__all__` declarations when they are defined conditionally and potentially multiple times, specifically regarding the detection of unused imports (F401).",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyflakes/F406.py",
            "description": "This file tests the `pyflakes` F406 rule, which flags 'from module import *' imports inside a function or class scope. It demonstrates these import patterns at the module level, within a function, and within a class.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyflakes/F403.py",
            "description": "This file serves as a test fixture for the Pyflakes F403 rule, demonstrating multiple 'from ... import *' statements and the use of 'noqa' directives to ignore the F403 error.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyflakes/F401_4.py",
            "description": "Tests referencing an imported type via `TypeAlias` using future annotations and string-quoted type hints. It conditionally imports `TypeAlias` based on the Python version.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyflakes/F401_9.py",
            "description": "This file is a test fixture for Ruff's Pyflakes F401 rule, demonstrating a late-binding issue with `__all__` where an imported name (`baz`) is not included in the `__all__` tuple.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyflakes/F407.py",
            "description": "This file is a test fixture for the Pyflakes F407 rule, demonstrating the detection of non-existent '__future__' imports.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyflakes/F401_11.py",
            "description": "This file is a test fixture for Pyflakes F401, designed to test the parsing of nested string type annotations, specifically 'List['Path']', and how imports within them are handled.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyflakes/F401_19.py",
            "description": "This file is a test fixture for Pyflakes F401, verifying that type parameters, including those in `TYPE_CHECKING` blocks and `type` aliases, are correctly identified as used. It ensures that such constructs do not trigger unused import warnings.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyflakes/F503.py",
            "description": "This file contains test cases for the `pyflakes` linter rule `F503` within the `ruff` project. It demonstrates how string formatting with single versus multiple placeholders behaves with various data types, particularly highlighting cases where multiple placeholders are used with a mapping argument, which triggers F503.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyflakes/F602.py",
            "description": "This file serves as a test fixture for the Pyflakes F602 rule, demonstrating various cases of duplicate dictionary keys. It is used to verify that the linter correctly identifies these occurrences.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyflakes/F522.py",
            "description": "This file contains test cases for the Pyflakes `F522` error, which flags unused arguments in string formatting operations. It also includes examples demonstrating edge cases related to side effects in format arguments, particularly concerning a specific Ruff issue (#18806).",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyflakes/F622.py",
            "description": "This file serves as a test fixture for the Pyflakes F622 rule, demonstrating valid and invalid usages of extended unpacking assignments with multiple starred expressions.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyflakes/F404_0.py",
            "description": "This file serves as a test fixture for the Ruff linter, specifically designed to trigger the Pyflakes F404 error for multiple or improperly placed '__future__' imports.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyflakes/F504.py",
            "description": "This file serves as a test fixture for the `ruff_linter`, specifically demonstrating cases related to the F504 rule, which identifies unused keys in dictionary-based string formatting. It includes various examples and edge cases, including those referenced in Ruff GitHub issues.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyflakes/F502.py",
            "description": "This file contains test cases for string formatting using the '%' operator, specifically demonstrating various data types used with dictionary-style format specifiers. It highlights cases that trigger linter warnings (e.g., Pyflakes F202) for incompatible types.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyflakes/F525.py",
            "description": "Test fixtures for Pyflakes rules F525 (and F523) demonstrating incorrect string formatting with `.format()`.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyflakes/F401_35.py",
            "description": "Tests that Pyflakes rule F401 (unused import) does not flag imports that occur within function bodies as errors. It specifically checks various hvplot-related imports inside functions.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyflakes/F401_1.py",
            "description": "Tests the Pyflakes F401 rule by importing a sub-module directly and via an alias of its parent package, demonstrating a redundant import.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyflakes/F541.py",
            "description": "This file serves as a test fixture for the Pyflakes F541 rule, demonstrating various correct and incorrect uses of f-strings to be detected by the linter.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyflakes/F632.py",
            "description": "This file serves as a test fixture for the `F632` Pyflakes rule in the Ruff linter, demonstrating various invalid uses of the `is` and `is not` operators in comparison contexts, including regression tests for specific issues.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyflakes/F521.py",
            "description": "This file serves as a test fixture for linters (like Ruff and Flake8), demonstrating various valid and invalid uses of Python's `str.format()` method, particularly focusing on edge cases and error patterns.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyflakes/F811_23.py",
            "description": "This test fixture is designed to verify that the linter correctly identifies and warns about shadowing an explicit re-export, specifically for Pyflakes F811 errors.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyflakes/F50x.py",
            "description": "This file serves as a test fixture for the `ruff` linter, demonstrating various `pyflakes` F50x string formatting errors and valid use cases. It includes examples of incorrect and correct Python string formatting using the `%` operator to verify linter rule detection.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyflakes/F722_1.py",
            "description": "Test fixture for `pyflakes` rule F722 (invalid type annotations) to verify that `no_type_check` correctly suppresses these errors, both inside and outside classes.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyflakes/F811_0.py",
            "description": "This file is a test fixture for the Ruff linter, specifically designed to trigger a Pyflakes F811 error related to the redefinition of a function, 'bar', after it has been decorated.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyflakes/F811_11.py",
            "description": "This file demonstrates robust importing of a 'mixer' function, attempting imports from different modules ('aa', 'bb', 'cc', 'dd') based on various import exceptions caught.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyflakes/F404_1.py",
            "description": "This file serves as a test fixture for the Ruff linter, specifically to check the Pyflakes F404 rule. It tests for `__future__` imports that are not placed at the very beginning of the file, after the module's docstring.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyflakes/F523.py",
            "description": "This file contains test cases for the `pyflakes` F523 rule, demonstrating various scenarios where arguments passed to `str.format()` are unused. It covers indexed, non-indexed, and `*args` formatting, including cases with side effects.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyflakes/F811_20.py",
            "description": "Tests that shadowing a global variable with a class attribute does not generate a warning. It imports a module, then defines a class with an attribute of the same name as the imported module.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyflakes/F401_0.py",
            "description": "This file serves as a test fixture for a linter, specifically for Pyflakes F401 (unused import) checks. It showcases various import scenarios, including aliased imports, conditional imports, type-checking imports, and nested imports within match statements, to verify the linter's accuracy.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyflakes/F704.py",
            "description": "This file contains test cases for the Pyflakes F704 error, demonstrating various valid and invalid placements of 'yield' and 'await' expressions outside of or within inappropriate scopes (e.g., comprehensions) to check linter behavior.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyflakes/F633.py",
            "description": "This file is a test fixture for the Ruff linter, designed to trigger the `F633` (Pyflakes) error. It demonstrates an old Python 2-style `print` statement redirecting output, which is a syntax error in Python 3.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyflakes/F811_12.py",
            "description": "This file demonstrates conditional importing of the 'mixer' function from different modules ('aa' or 'bb') based on an ImportError, and then calls the imported 'mixer' function.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyflakes/F405.py",
            "description": "This file serves as a test fixture for a linter, demonstrating potential issues arising from wildcard imports and function redefinitions.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyflakes/F701.py",
            "description": "This file serves as a test fixture for the Pyflakes F701 rule, demonstrating various invalid uses of the 'break' statement outside of a loop.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyflakes/F811_19.py",
            "description": "This test fixture demonstrates a specific scenario where an imported name 'bar' is redefined by a class 'bar' that also uses 'bar' as a base class. It is designed to confirm that no F811 (redefinition) warning is emitted for this particular pattern.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyflakes/F706.py",
            "description": "This file is a test fixture designed to trigger the Pyflakes F706 error, which occurs when a 'return' statement is found outside of a function or method. It demonstrates multiple instances of invalid 'return' usage at the module and class levels.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyflakes/F811_26.py",
            "description": "This file is a test fixture for Pyflakes rule F811, demonstrating the redefinition of a method within a class.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyflakes/F811_10.py",
            "description": "This file is a test fixture for the Pyflakes linter (F811), designed to ensure that importing the same module multiple times within nested scopes or an 'except' block does not incorrectly trigger a redefinition warning.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyflakes/F601.py",
            "description": "This file serves as a test fixture for the ruff linter, specifically to test the detection of duplicate dictionary keys (Pyflakes F601 rule). It contains various examples of dictionaries with repeated keys to ensure the linter correctly identifies these issues.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyflakes/F631.py",
            "description": "Test fixture for the Pyflakes linter, demonstrating various assert statements, likely to check rule F631 regarding assertion arguments.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyflakes/F811_8.py",
            "description": "Tests that re-importing the same module twice within a try block raises a `F811` warning, as indicated by the Pyflakes fixture path.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyflakes/F811_15.py",
            "description": "This file is a test fixture for the pyflakes linter, demonstrating the redefinition of an imported name 'fu' (F811 error).",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyflakes/F811_1.py",
            "description": "Test fixture for Pyflakes F811, demonstrating a redefinition of an imported name (FU) within the same scope. This file is used to verify the linter correctly identifies and flags such issues.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyflakes/F821_25.py",
            "description": "This file tests attribute access on built-in types by comparing the 'fromkeys' method obtained via `type({}).__dict__` and `dict.__dict__`.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyflakes/F401_20.py",
            "description": "This file defines a type alias `X` using `typing.Annotated` with a lambda function that uses the `re` module. It serves as a test fixture for the `pyflakes` linter, specifically for the F401 (unused import) check, to evaluate indirect module usage.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyflakes/F707.py",
            "description": "This file contains various `try...except` block structures, specifically demonstrating bare `except:` clauses followed by more specific exception handlers, to serve as a test fixture for the Pyflakes F707 rule (unreachable exception handler).",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyflakes/F811_22.py",
            "description": "This file defines a function `redef` that uses a `match` statement to conditionally redefine an inner function `fun` based on its input. It likely serves as a test case for a linter to detect issues related to function redefinition within different branches.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyflakes/F811_17.py",
            "description": "This file is a test fixture for `pyflakes` (F811) and demonstrates a global name being shadowed by a nested function, which should generate a warning.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyflakes/F634.py",
            "description": "Tests Pyflakes F634, identifying 'if' and 'elif' conditions that are always true or always false due to the boolean evaluation of tuple literals.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyflakes/F811_4.py",
            "description": "This file is a test fixture for the Pyflakes F811 rule, demonstrating a redefined name 'fu' after an import statement.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyflakes/F811_27.py",
            "description": "This file is a test fixture for Pyflakes rule F811, demonstrating the re-import of the 'os' module within a conditional block after an initial global import.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyflakes/F811_3.py",
            "description": "This file is a test fixture for the `pyflakes` linter, specifically designed to trigger and test the F811 rule for redefinition of an imported name. It demonstrates the redefinition of 'fu' after it has been imported.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyflakes/F401_15.py",
            "description": "This test fixture for Pyflakes' F401 rule demonstrates an import of `pathlib.Path` within a `TYPE_CHECKING` block, used as a string literal type hint in a `ForeignKey` definition.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyflakes/F811_16.py",
            "description": "This file tests that a linter (likely Pyflakes, F811) correctly warns when a nested function shadows an imported global name. It defines a local function `fu` inside `bar` and `baz`, which redefines the imported module `fu`.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyflakes/F811_24.py",
            "description": "This test fixture checks that shadowing a `__future__` import with a regular module import of the same name does not trigger a 'redefinition of unused name' warning (F811) in Ruff's Pyflakes linter.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyflakes/F524.py",
            "description": "This file serves as a test fixture for the Pyflakes F524 error, demonstrating `str.format()` calls with missing positional or keyword arguments. It includes examples that are expected to trigger the F524 diagnostic.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyflakes/F811_31.py",
            "description": "Tests how the linter handles redefinitions of variables when imports occur within `contextlib.suppress(ImportError)` or `try-except ImportError` blocks. This is a regression test for a specific Pyflakes issue (F811).",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyflakes/F811_13.py",
            "description": "This file is a test fixture for Pyflakes rule F811, demonstrating the redefinition of names (`funca`, `funcb`) within a conditional import block (try-except-else) and their subsequent usage. It checks how conditional imports and potential redefinitions are handled.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyflakes/F821_28.py",
            "description": "This file tests the NFKC normalization of Unicode identifiers, specifically checking for `F821` (undefined name) warnings when Unicode characters are not properly normalized or defined.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyflakes/F821_18.py",
            "description": "This file is a test fixture for Pyflakes rule F821, specifically designed to test the handling of variable bindings created within type annotations, including list comprehensions and assignment expressions.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyflakes/F821_3.py",
            "description": "This file is a test fixture for the `pyflakes` F821 rule, specifically designed to test edge cases related to the `dict` type, including shadowing the built-in `dict` name and its usage in type annotations.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyflakes/F811_5.py",
            "description": "This file is a test fixture for the Pyflakes F811 error, demonstrating the redefinition of an imported name 'fu' through list unpacking.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyflakes/F702.py",
            "description": "This file serves as a test fixture for the Pyflakes F702 error, demonstrating various invalid placements of the 'continue' statement outside of loops. It includes examples of 'continue' in `else` blocks of loops, at the top-level, and within functions or classes without an enclosing loop.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyflakes/F811_14.py",
            "description": "This file is a test fixture for the Pyflakes linter (specifically rule F811) demonstrating variable assignment and imports within a `try...except...else...finally` block.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyflakes/F821_4.py",
            "description": "This file contains test cases for the `pyflakes` linter, specifically designed to verify its ability to track and resolve type hints even when types are imported with aliases or from nested modules.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyflakes/F811_18.py",
            "description": "This file contains unit tests to ensure that a global import, when redefined locally within one function but then correctly used from its global scope in another function, does not trigger a warning from linting tools like Pyflakes.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyflakes/F722.py",
            "description": "This file serves as a test fixture for the `ruff_linter` to validate its handling of type annotations, particularly focusing on forward references and multi-line, triple-quoted type hints, including valid and invalid syntax for Pyflakes rule F722 (Syntax error in type annotation).",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyflakes/F821_12.py",
            "description": "This file is a test case for Pyflakes F821 (undefined name) demonstrating its behavior when strings are used as type arguments within `Callable` and `VarArg` in type annotations, specifically flagging `\"os\"` as undefined.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyflakes/F401_8.py",
            "description": "This test fixture for the Ruff linter's Pyflakes F401 rule examines how the linter handles explicit re-exports of names that might shadow built-in exceptions.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyflakes/F811_2.py",
            "description": "Test fixture for Pyflakes rule F811, demonstrating the redefinition of an imported name within an import statement.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyflakes/F821_1.py",
            "description": "This file is a test fixture for the Pyflakes F821 rule, demonstrating various cases where `Undefined name` errors should or should not be raised, particularly when using `cast`, `Pattern`, and `Match` from the `typing` module.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyflakes/F821_17.py",
            "description": "Tests the `F821` (undefined name) linting rule specifically for type parameters within `type` aliases, functions, and classes, including their scope and bounds/defaults.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyflakes/F811_6.py",
            "description": "This is a test fixture for the ruff linter, specifically for a Pyflakes F811 rule. It verifies that re-importing the same module (`os`) twice within an 'if' block raises the expected warning.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyflakes/F811_30.py",
            "description": "This file serves as a regression test case for Ruff issue #11828, specifically targeting scenarios where methods or attributes are redefined within class scopes, which is related to the F811 error code.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyflakes/F822_1.py",
            "description": "This file is a test fixture for the Pyflakes F822 rule, demonstrating an undefined name ('b') included in the `__all__` dunder variable, which should trigger a warning.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyflakes/F821_33.py",
            "description": "Tests Pyflakes F821 warnings related to the use of `__class__` within lambda functions, including cases inside a class, nested lambdas, and module-level lambdas.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyflakes/F821_29.py",
            "description": "Regression test for Pyflakes F821, specifically for issue #10451. It verifies that forward references in class annotations with `from __future__ import annotations` and `sqlalchemy.orm.DeclarativeBase` do not incorrectly trigger F821 if they are resolvable.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyflakes/F821_21.py",
            "description": "This file tests how the linter handles the IPython-specific `display` function, which is not a built-in in standard Python, likely to ensure it's flagged as an undefined name (F821) in non-IPython contexts.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyflakes/F821_16.py",
            "description": "This file is a test fixture for `ruff_linter`, specifically for a Pyflakes rule, demonstrating the interaction of `Literal` types with `__future__` import annotations.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyflakes/F822_0.py",
            "description": "This file serves as a test fixture for the Pyflakes F822 rule, demonstrating an undefined name ('b') included in the `__all__` list.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyflakes/F901.py",
            "description": "Tests the `pyflakes` linter's F901 rule, which warns against raising `NotImplemented` directly instead of `NotImplementedError` or `NotImplemented()`.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyflakes/multi_statement_lines.py",
            "description": "Tests how a linter handles multi-statement lines, specifically focusing on `import` statements combined with other expressions and various line continuation methods.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyflakes/F821_7.py",
            "description": "Tests Pyflakes F821 (undefined name) detection within `mypy_extensions.DefaultNamedArg`, distinguishing between valid type annotations and invalid string literals.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyflakes/F821_2.py",
            "description": "This file is a test fixture for pyflakes rule F821, specifically demonstrating cases of `Literal` from `typing_extensions` being correctly or incorrectly recognized depending on its import status.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyflakes/F821_14.py",
            "description": "This file is a test case for `ruff`'s `pyflakes` linter (F821), specifically designed to check its behavior when an f-string is used within a type annotation. It demonstrates an f-string `f\"i{x}nt\"` as a type parameter within a `List` annotation.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyflakes/F821_20.py",
            "description": "This file is a test fixture for Pyflakes' F821 error, specifically designed to test the lazy evaluation of type alias values.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyflakes/F821_9.py",
            "description": "This file is a test fixture for Pyflakes' F821 rule (undefined name), specifically demonstrating its behavior within Python's match statements, including cases where variables are captured and where they are not.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyflakes/F841_1.py",
            "description": "This file contains test cases for the Pyflakes F841 rule, demonstrating various scenarios of unused local variables arising from tuple unpacking and assignments.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyflakes/F822_1b.py",
            "description": "This file defines a variable `a` and sets `__all__` using `builtins.list`, including both defined (`a`) and undefined (`b`) names. It likely serves as a test case for a linter checking `__all__` declarations for undefined names.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyflakes/F811_7.py",
            "description": "This test fixture ensures that importing the same module multiple times within `if-else` branches does not trigger a linter warning, as the module is subsequently used.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyflakes/builtins.py",
            "description": "This file is a test fixture for the Pyflakes linter within the Ruff project. It likely tests how the linter handles the `_()` function, commonly used for i18n/L10n (gettext) translation markers.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyflakes/F821_10.py",
            "description": "This test fixture evaluates how the linter handles the `ExceptionGroup` construct in a `try...except` block, likely to test rule F821 (undefined name) for compatibility with different Python versions.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyflakes/__init__.py",
            "description": "This `__init__.py` file defines a Python package for testing within the `ruff_linter` project, demonstrating basic package initialization and the use of `__path__` and `__all__`.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyflakes/F821_6.py",
            "description": "Tests Pyflakes F821 (undefined name) for an annotated global variable `n`. It defines a global `n` with a type hint, then accesses and modifies it in functions, demonstrating that the initial annotation prevents F821.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyflakes/F821_23.py",
            "description": "This file contains test cases demonstrating different valid ways to define `typing.NamedTuple` objects using keyword arguments, a dictionary, and a list of tuples. It serves as a fixture to ensure a linter correctly parses these definitions without raising false positives for undefined names.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyflakes/F821_13.py",
            "description": "This file is a test fixture for the `ruff` linter's `pyflakes` rule `F821`. It demonstrates `ForwardRef` and `TypeVar` declarations using string-based type hints to ensure they are handled correctly by the linter.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyflakes/F811_25.py",
            "description": "This file is a test fixture for the `ruff` linter, specifically for the `pyflakes/F811` rule, demonstrating a regression test for branch detection related to conditional `importlib.metadata` imports across different Python versions.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyflakes/F811_28.py",
            "description": "This file is a test fixture for the Ruff linter, specifically designed to reproduce and test the Pyflakes F811 error regarding the redefinition of an imported name, as described in GitHub issue #10384. It demonstrates the shadowing of the `datetime` module import by a `from datetime import datetime` statement.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyflakes/F811_32.py",
            "description": "This test fixture, related to GitHub issue #15583, checks how Ruff handles duplicate imports of `typing.List`, specifically targeting the `F811` error code for redefinition.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyflakes/F821_11.py",
            "description": "This file is a test fixture for Pyflakes rule F821, specifically demonstrating and testing for undefined names within string literals used in type annotations, particularly with `VarArg`.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyflakes/F841_3.py",
            "description": "This file contains multiple test cases demonstrating various Python syntax constructs that can lead to F841 ('local variable assigned to but never used') violations, specifically for testing linter functionality.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyflakes/F821_5.py",
            "description": "This file is a test fixture for Pyflakes rule F821, specifically designed to test the resolution of type annotations referencing inner classes. It verifies that inner classes are correctly identified when used in type hints within their containing class or other classes.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyflakes/F821_19.py",
            "description": "Tests how a linter handles variable bindings created within type annotations under `__future__` annotations, specifically covering list comprehensions and walrus operators.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyflakes/F841_0.py",
            "description": "This file serves as a test fixture for the Pyflakes F841 rule, demonstrating various scenarios where local variables are assigned but not used, alongside cases that should and should not trigger a diagnostic.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyflakes/F821_30.py",
            "description": "This file contains `TypedDict` declarations designed as a regression test for Ruff's F821 Pyflakes rule, specifically for issue #10812. It includes examples expected to produce `F821` errors for undefined names within type hints.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyflakes/F821_24.py",
            "description": "This file serves as a test fixture for the Ruff linter, specifically for the Pyflakes F821 rule (undefined name). It tests the correct detection of class member usage within the class body when employing a walrus operator and set comprehension.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyflakes/F821_31.py",
            "description": "This file is a test fixture for Ruff's Pyflakes linter, specifically for rule F821 (undefined name). It demonstrates how `typing.no_type_check` affects the detection of undefined string literal type annotations.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyflakes/F401_32.py",
            "description": "This file serves as a test fixture for the Ruff linter, specifically for the Pyflakes F401 rule. It verifies that an imported name used as a type annotation, even within a function decorated with `@no_type_check`, is correctly recognized as used, preventing an 'unused import' error.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyflakes/F823.py",
            "description": "This file serves as a test fixture for a linter, specifically for pyflakes F823, demonstrating various scenarios of local variable 'my_var' referenced before assignment and other variable scope issues across functions and classes.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyflakes/F822_2.py",
            "description": "Tests the `F822` Pyflakes rule, specifically ensuring that a name explicitly included in `__all__` (like 'foo') is correctly defined within the module. It also includes an undefined name ('bar') to verify it's not incorrectly flagged.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyflakes/F811_9.py",
            "description": "Tests that importing the same module multiple times within a `try-except` block does not trigger a redefinition warning (Pyflakes F811) in Ruff.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyflakes/F821_0.py",
            "description": "This file contains a collection of Python code snippets designed as test fixtures for a linter, specifically demonstrating various language features and potential issues, such as undefined names (F821), f-strings, type annotations (PEP 593), and class definitions.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyflakes/F842.py",
            "description": "This file serves as a test fixture for the Pyflakes F842 rule, showcasing type annotations and class variable declarations that should not be flagged as unused.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyflakes/F841_2.py",
            "description": "This file contains test cases for the Pyflakes F841 rule, specifically addressing scenarios involving slice expressions and type aliases that were reported as false positives or edge cases for unused variables.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyflakes/F401_26__all_empty/unused.py",
            "description": "This is an empty Python module used as a test fixture for `pyflakes` F401 (unused import) tests, specifically for cases involving an empty `__all__` in `__init__.py`.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyflakes/F401_26__all_empty/__init__.py",
            "description": "This file serves as a test fixture for the ruff linter, specifically for the Pyflakes F401 rule related to unused imports when the `__all__` variable is explicitly defined as an empty list.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyflakes/F401_26__all_empty/renamed.py",
            "description": "An empty Python module specifically designed as a test fixture for the Pyflakes linter, imported by an `__init__.py` file to test scenarios related to empty `__all__` definitions (F401_26).",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyflakes/F401_24/unused.py",
            "description": "This is an empty module file used as a test fixture for the Pyflakes F401 (unused import) rule. It is likely imported by an `__init__.py` in the same directory to simulate an unused module for testing purposes.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyflakes/F401_24/used.py",
            "description": "This empty Python module acts as a test fixture for ruff's pyflakes linter tests, particularly for scenarios involving unused imports (F401).",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyflakes/F401_24/aliased.py",
            "description": "This is an empty Python module used as a test fixture for `pyflakes` `F401_24` tests. It is imported by `__init__.py` to simulate an aliased import scenario.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyflakes/F401_24/__init__.py",
            "description": "This file is a test fixture for the `ruff_linter`'s F401 rule, demonstrating how it handles different types of unused imports (stdlib, first-party) and their corresponding fix strategies like removal or conversion to redundant aliases.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyflakes/F401_24/renamed.py",
            "description": "This is an empty Python module serving as a test fixture for the Ruff linter's Pyflakes F401_24 rule, intended to be imported by an __init__.py file for testing purposes.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyflakes/F401_25__all_nonempty/aliased.py",
            "description": "This is an empty Python module intended to be imported by an __init__.py file, serving as a test fixture for the Pyflakes F401 (unused import) linter rule.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyflakes/F401_25__all_nonempty/used.py",
            "description": "An empty Python module used as a test fixture, specifically designed to be imported by an __init__.py file to test the pyflakes F401_25 rule.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyflakes/F401_25__all_nonempty/unused.py",
            "description": "An empty Python module used as a test fixture for the F401 Pyflakes rule, demonstrating an unused import. It is designed to be imported by an `__init__.py` file.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyflakes/F401_25__all_nonempty/exported.py",
            "description": "This empty Python module serves as a test fixture for the `ruff_linter`, specifically for testing `pyflakes/F401_25__all_nonempty` scenarios. It is intended to be imported by an `__init__.py` file within a test case.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyflakes/F401_25__all_nonempty/__init__.py",
            "description": "This test fixture demonstrates how the linter handles unused imports (F401) in an `__init__.py` file with a non-empty `__all__` list, differentiating behavior for standard library, third-party, and first-party imports.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyflakes/F401_25__all_nonempty/renamed.py",
            "description": "An empty Python module serving as a test fixture for the `ruff_linter`. It is used to test the Pyflakes F401 rule regarding unused imports in the context of a non-empty `__all__` variable.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyflakes/F401_28__all_multiple/unused.py",
            "description": "This is an empty Python module designed to be an unused import for a Pyflakes F401 test fixture, specifically to test `__all__` handling.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyflakes/F401_28__all_multiple/renamed.py",
            "description": "This is an empty Python module used as a test fixture for the `ruff_linter`. It's imported by `__init__.py` to test a specific Pyflakes rule (F401) related to `__all__` imports.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyflakes/F401_28__all_multiple/__init__.py",
            "description": "This file is a test fixture for the Ruff linter's Pyflakes F401 rule, demonstrating unexposed imports in an `__init__.py` with multiple imports that are intended to be added to `__all__`.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyflakes/F401_29__all_conditional/unused.py",
            "description": "This is an empty Python module intended to be imported by an __init__.py file, serving as a test fixture for pyflakes F401 (unused import) rules.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyflakes/F401_29__all_conditional/renamed.py",
            "description": "An empty module specifically created as a test fixture for `pyflakes/F401` to test import-related functionalities within the Ruff linter.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyflakes/F401_29__all_conditional/also_exported.py",
            "description": "This is an empty Python module that serves as a test fixture. It is intended to be imported by another module, likely for testing scenarios related to unused imports (F401) within the ruff linter.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyflakes/F401_29__all_conditional/exported.py",
            "description": "This is an empty Python module intended to be imported by an `__init__.py` file. It serves as a test fixture for `pyflakes` tests, likely related to F401 warnings concerning conditional `__all__` definitions.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyflakes/F401_29__all_conditional/__init__.py",
            "description": "This test fixture demonstrates conditional imports and modifications to `__all__` based on Python version, serving as a complex test case for linters detecting F401 (unused imports) where `__all__` is dynamically populated.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyflakes/F401_27__all_mistyped/unused.py",
            "description": "This empty Python module serves as a test fixture for the Ruff linter, designed to be imported by an `__init__.py` file. It specifically facilitates testing Pyflakes F401 errors related to mistyped `__all__` variables.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyflakes/F401_27__all_mistyped/renamed.py",
            "description": "This is an empty Python module serving as a test fixture for Pyflakes F401, likely to test scenarios involving unused imports or `__all__` mistyping when a module is imported but its contents are not explicitly accessed.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyflakes/F401_27__all_mistyped/__init__.py",
            "description": "This file is a test fixture for the `pyflakes` `F401` rule, demonstrating a scenario where `__all__` is mistyped as `None` in an `__init__.py` file, impacting the detection of unused imports. It contains imports that would typically be recommended for inclusion in `__all__`.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyflakes/F401_33/__init__.py",
            "description": "This file is a regression test for Ruff's F401 (unused import) rule, specifically addressing an issue related to late imports within class methods, as detailed in https://github.com/astral-sh/ruff/issues/12897.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyflakes/project/foo/bar.py",
            "description": "This file is a test fixture for the ruff linter, demonstrating various ways to import and use `Literal` for type hinting. It specifically tests import resolution for `Literal`, including standard library imports, relative imports, and a case expected to raise an `F821` error.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyflakes/project/foo/bop/baz.py",
            "description": "This file serves as a test fixture for the Pyflakes linter, demonstrating how it handles various `Literal` import patterns, particularly relative imports, to identify correctly resolved vs. undefined names (F821).",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pygrep_hooks/PGH004_0.py",
            "description": "This file serves as a test fixture for `pygrep-hooks` rule PGH004, demonstrating valid and invalid `noqa` comment formats. It includes examples of correctly formatted `noqa` comments and various malformed ones that should trigger PGH004.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pygrep_hooks/PGH003_0.py",
            "description": "This file serves as a test fixture for the `PGH003` rule within `ruff_linter`, demonstrating various forms of `# type: ignore` comments and their invalid variations for testing purposes.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pygrep_hooks/PGH005_0.py",
            "description": "This file serves as a test fixture for the `ruff_linter`, demonstrating both incorrect and correct usage of `unittest.mock` and `unittest.mock.AsyncMock` assertion methods, particularly focusing on patterns flagged by the PGH005 rule.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyupgrade/UP003.py",
            "description": "This file serves as a test fixture for the 'pyupgrade/UP003' linter rule, demonstrating various `type()` call patterns, including those that should and should not trigger the linter, and a regression test case.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyupgrade/UP009_3.py",
            "description": "This is a test fixture for the `pyupgrade` linter rule UP009, containing a simple Python script with a shebang and encoding declaration.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyupgrade/UP009_1.py",
            "description": "This is a simple Python test fixture for pyupgrade rule UP009, demonstrating basic script execution by printing 'Hello world'.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyupgrade/UP009_0.py",
            "description": "This file is a test fixture for the `pyupgrade` linter rule `UP009` within the `ruff` project. It provides a simple Python script as input for testing purposes.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyupgrade/UP009_7.py",
            "description": "This file is a regression test case for Ruff issue #6756, demonstrating that leading tabs must be handled correctly to prevent syntax errors. It simply prints 'Hello world' with a leading tab.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyupgrade/UP009_5.py",
            "description": "This file is a test fixture for the `ruff` linter's `pyupgrade` rule UP009, demonstrating a Python script with a redundant encoding declaration.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyupgrade/UP005.py",
            "description": "This file is a unit test fixture for the `pyupgrade` linter rule `UP005`. It demonstrates older `unittest` assertion methods that are typically targeted for modernization by the linter.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyupgrade/UP009_2.py",
            "description": "A test fixture for Ruff's `pyupgrade` linter, specifically `UP009`, demonstrating how coding comments placed after the second line are handled or ignored.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyupgrade/UP009_9.py",
            "description": "This file is a test fixture for the `pyupgrade` linter, specifically for rule `UP009`. It demonstrates an invalid coding declaration where a line continuation character precedes the coding comment, leading to its misinterpretation.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyupgrade/UP006_1.py",
            "description": "This file is a test fixture for the `pyupgrade` linter rule UP006, demonstrating the usage of `typing.DefaultDict` which should be replaced by `collections.defaultdict` when `from __future__ import annotations` is present and type checking is active.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyupgrade/UP001.py",
            "description": "This file contains test cases for the `pyupgrade` linter rule `UP001`, demonstrating different ways classes are defined with `type` as a metaclass, specifically focusing on the Python 2 `__metaclass__` syntax vs. the Python 3 `metaclass` keyword argument.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyupgrade/UP017.py",
            "description": "Test fixtures for the `UP017` rule, demonstrating various ways to import and access `datetime.timezone` and its `utc` attribute. It covers direct imports, aliasing, and different access patterns.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyupgrade/UP009_8.py",
            "description": "This file serves as a test fixture for the Ruff linter, specifically to demonstrate an invalid `coding` declaration (UP009) due to its placement after a statement. It ensures the linter correctly identifies this non-compliant Python syntax.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyupgrade/UP009_4.py",
            "description": "This file is a test fixture for the `ruff` linter's `pyupgrade` rule `UP009`. It demonstrates a `PEP 263` encoding declaration, likely to test the linter's handling of such declarations.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyupgrade/UP009_utf8_code_other.py",
            "description": "This is a test fixture for the 'pyupgrade' linter, specifically for rule UP009, demonstrating conflicting or redundant coding declarations (utf8 and ascii) within a Python file.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyupgrade/UP007.py",
            "description": "This file contains a collection of test cases for the `UP007` rule in the Ruff linter, focusing on the usage and simplification of `typing.Union` expressions, including various valid and invalid syntaxes, string-based annotations, and regression tests for specific issues.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyupgrade/UP010_0.py",
            "description": "This file is a test fixture for `ruff_linter`'s `pyupgrade` checks, specifically for UP010. It demonstrates various `from __future__ import` statements, including duplicates and those within conditional blocks, to test import handling.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyupgrade/UP006_0.py",
            "description": "This file serves as a test fixture for the `pyupgrade` rule `UP006` in the `ruff` linter. It showcases various ways of defining type hints using `typing.List` and other generic types, including direct imports, aliasing, and string-based annotations.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyupgrade/UP009_utf8_other.py",
            "description": "This file is a test fixture for Ruff's pyupgrade linter, specifically for rule UP009, demonstrating conflicting UTF-8 and ASCII encoding declarations.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyupgrade/UP009_other_other.py",
            "description": "This file is a test fixture for the `pyupgrade` tool, specifically for rule UP009. It demonstrates the presence of multiple old-style encoding declarations (`ascii` and `latin`) that `pyupgrade` should address.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyupgrade/UP009_hashbang_utf8_other.py",
            "description": "This file is a test fixture for the `pyupgrade` linter rule `UP009`. It demonstrates how the linter handles Python files with multiple encoding declarations, including `utf-8` and `ascii`, alongside a hashbang.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyupgrade/UP018_LF.py",
            "description": "This file is a test fixture for the 'pyupgrade' linter, specifically for rule UP018. It demonstrates cases where parentheses around numeric literals with signs should be preserved despite line breaks.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyupgrade/UP018_CR.py",
            "description": "This file is a test fixture for the `pyupgrade` UP018 rule, specifically demonstrating the preservation of parentheses around `int` literals during code transformation.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyupgrade/UP008.py",
            "description": "This file contains test cases for the Ruff `pyupgrade` rule UP008, demonstrating various valid and invalid uses of `super()` with and without arguments, including scenarios involving `__class__`, keyword arguments, and local variable shadowing.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyupgrade/UP009_utf8_utf8.py",
            "description": "This file is a test fixture for the `UP009` (UTF8Encode) rule in the `pyupgrade` linter, specifically designed to test how redundant `utf-8` coding declarations are handled.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyupgrade/UP009_other_utf8.py",
            "description": "This file serves as a test fixture for the `ruff_linter`'s `pyupgrade` rule `UP009`, specifically to verify its behavior with multiple conflicting `coding` declarations.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyupgrade/UP009_code_utf8_utf8.py",
            "description": "This file is a test fixture for Ruff's `pyupgrade` rule `UP009`. It checks how the linter handles duplicate UTF-8 encoding declarations.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyupgrade/UP009_6.py",
            "description": "This file is a test fixture for Ruff's `pyupgrade` linter, specifically for rule UP009. It's a regression test to ensure proper handling of leading spaces, as described in GitHub issue #6756.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyupgrade/UP006_2.py",
            "description": "This file is a test fixture for the ruff linter's pyupgrade rule UP006, specifically demonstrating the use of `typing.DefaultDict` within a `TYPE_CHECKING` block.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyupgrade/UP029_1.py",
            "description": "This file is a test fixture for the `pyupgrade` linter rule `UP029`, demonstrating the import of `str` and `int` from `builtins`, which is considered redundant.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyupgrade/UP009_10.py",
            "description": "This file is a test fixture for the `pyupgrade` linter rule `UP009`, demonstrating an invalid `coding` declaration embedded within a docstring. It also includes an empty comment to test for false positives in linter analysis.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyupgrade/UP024_3.py",
            "description": "This test fixture defines a custom exception `SocketError` and demonstrates a basic `try-except` block, likely for validating `pyupgrade` rules related to exception handling.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyupgrade/UP015_1.py",
            "description": "This file is a test fixture for the Ruff linter's `pyupgrade` module, specifically for rule UP015. It demonstrates that an invalid type annotation (a string literal containing a function call) should be handled without causing a panic, referencing a GitHub issue.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyupgrade/UP009_many_empty_lines.py",
            "description": "This file is a test fixture for the Ruff linter, designed to check the `pyupgrade` rule UP009 which likely addresses the presence of many empty lines in a Python file.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyupgrade/UP004.py",
            "description": "This file contains various Python class definitions that explicitly inherit from `object`, serving as test cases for a linter rule (UP004 in pyupgrade) designed to detect and remove such redundant inheritance in Python 3.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyupgrade/UP010_1.py",
            "description": "This file serves as a test fixture for the `pyupgrade` linter, specifically for the `UP010` rule. It demonstrates various `__future__` imports, including repetitions and combinations, along with basic Python constructs like classes, functions, and `__all__` definitions, to test refactoring or linting capabilities.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyupgrade/UP020.py",
            "description": "This file serves as a test fixture for the `pyupgrade` linter rule `UP020`, demonstrating various usages of `io.open` and `open` imported from `io`.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyupgrade/UP014.py",
            "description": "Test fixtures for the `pyupgrade` linter rule `UP014`, demonstrating various `NamedTuple` definitions including valid, invalid, and unfixable cases.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyupgrade/UP019.py",
            "description": "This file is a test fixture for the `pyupgrade` linter rule UP019. It demonstrates various ways of importing and using `typing.Text` and `typing_extensions.Text` for type hinting.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyupgrade/UP011.py",
            "description": "This file serves as a test fixture for the ruff linter's `UP011` rule, which identifies redundant empty parentheses when using the `lru_cache` decorator. It demonstrates both problematic and correct usages of `functools.lru_cache` in various scenarios.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyupgrade/UP031_0.py",
            "description": "This file contains various test cases demonstrating the use of old-style '%' string formatting. It is likely used by a linter (e.g., Ruff's `pyupgrade` rule UP031) to identify and potentially fix such formatting patterns, including edge cases and complex scenarios.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyupgrade/UP015.py",
            "description": "This file serves as a test fixture for the `pyupgrade` linter rule UP015, which detects and flags the deprecated 'U' universal newline mode used in `open()` calls.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyupgrade/UP012.py",
            "description": "This file serves as a test fixture for the `UP012` linter rule in Ruff, demonstrating various scenarios for replacing `str.encode()` calls with equivalent `bytes` literals and cases where this transformation should not occur.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyupgrade/UP021.py",
            "description": "Test cases for the `pyupgrade` rule `UP021`, demonstrating redundant `universal_newlines=True` arguments in `subprocess.run` calls when `text=True` is also present.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyupgrade/UP032_0.py",
            "description": "This file serves as a test fixture for the Ruff linter, demonstrating various `str.format()` usages. It categorizes examples into 'Errors' (cases that should trigger a linting rule, likely for conversion to f-strings) and 'Non-errors' (cases that should be ignored or are handled correctly).",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyupgrade/UP013.py",
            "description": "This file serves as a test fixture for the `pyupgrade` linter rule `UP013`, demonstrating various valid and invalid patterns of `TypedDict` usage. It includes examples of `TypedDict` definitions that should and should not be refactored or flagged by the linter.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyupgrade/UP024_2.py",
            "description": "This file is a test fixture for a linter, specifically designed to test various `raise` statements involving built-in and module-specific error types like `socket.error`, `mmap.error`, `EnvironmentError`, and `IOError`.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyupgrade/UP024_1.py",
            "description": "This file serves as a test fixture for the `pyupgrade` linter, specifically for rule UP024. It demonstrates `try-except` blocks catching deprecated exceptions like `mmap.error`, `socket.error`, and `IOError` alongside `OSError`, which are expected to be flagged for replacement.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyupgrade/UP036_3.py",
            "description": "This file contains Python code demonstrating conditional execution based on the Python interpreter's version (Python 2 vs. Python 3). It serves as a test fixture for the `pyupgrade` linter rule UP036, which targets `sys.version_info` comparisons.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyupgrade/UP025.py",
            "description": "Tests the `UP025` linter rule, which targets redundant 'u' prefixes for string literals in Python 3. It includes examples of strings that should be flagged and those that should be ignored.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyupgrade/UP009_utf8_utf8_other.py",
            "description": "This file is a test fixture for the ruff linter's `pyupgrade` tool, specifically for rule `UP009`. It contains redundant and conflicting encoding declarations to test how the linter handles such cases.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyupgrade/UP029_2.py",
            "description": "This file is a test fixture for the `ruff` linter's `pyupgrade` rule `UP029`, demonstrating various forms of relative imports for built-in functions like `next`, `str`, and `int`.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyupgrade/UP022.py",
            "description": "Tests the `pyupgrade` rule UP022 for `subprocess.run` usage, specifically variations in `stdout`, `stderr`, and `capture_output` arguments.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyupgrade/UP018.py",
            "description": "This file serves as a test fixture for the `pyupgrade` rule UP018 in Ruff, demonstrating various `str()`, `bytes()`, `int()`, `float()`, and `bool()` calls that should either be transformed into literals or remain unchanged by the linter.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyupgrade/UP032_3.py",
            "description": "This file is a test fixture for the `pyupgrade` linter rule UP032, demonstrating a `gettext` call with string concatenation and `.format()` for testing purposes, potentially related to E501 line length violations.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyupgrade/UP029_0.py",
            "description": "This file is a test fixture for the `pyupgrade` linter rule `UP029`, demonstrating various imports from `builtins` and `six.moves` that might be considered unnecessary in Python 3.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyupgrade/UP023.py",
            "description": "This file is a test fixture for the `pyupgrade` linter rule UP023. It demonstrates various import scenarios involving `xml.etree.cElementTree` to test the linter's ability to identify and transform or ignore them.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyupgrade/UP042.py",
            "description": "Tests for the pyupgrade UP042 rule, showcasing various invalid or problematic enum inheritance patterns involving `str` and `Enum` to ensure the linter correctly identifies them.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyupgrade/UP035.py",
            "description": "This file serves as a test fixture for the 'UP035' linting rule, demonstrating various import patterns from `collections`, `typing`, and `typing_extensions` modules that should trigger or not trigger the rule across different Python versions.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyupgrade/UP037_3.py",
            "description": "This file is a regression test fixture for the `ruff` linter's `pyupgrade` rule UP037, specifically addressing a bug where not all components of special dataclass annotations were marked as runtime-required.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyupgrade/UP032_1.py",
            "description": "This file serves as a test fixture for the `pyupgrade` linter rule UP032, demonstrating an old-style string format method call that should be flagged for potential modernization.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyupgrade/UP026.py",
            "description": "This file serves as a test fixture for the `UP026` linter rule, demonstrating various incorrect and correct ways to import the `mock` library. It specifically highlights cases where `mock` is imported directly instead of from `unittest.mock`.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyupgrade/UP031_1.py",
            "description": "This file serves as a test fixture for the Ruff linter, specifically for the `pyupgrade` rule `UP031`. It demonstrates various string formatting examples using the `%` operator, including cases that are considered acceptable and potentially problematic for this rule.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyupgrade/UP043.py",
            "description": "This file serves as a test fixture for the Ruff linter rule `UP043` (from `pyupgrade`), demonstrating various valid and potentially redundant type hints for `Generator` and `AsyncGenerator` functions.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyupgrade/UP039.py",
            "description": "This file serves as a test fixture for the `pyupgrade` linter rule UP039. It demonstrates Python class definitions that either incorrectly include empty parentheses or correctly omit them for classes with no explicit base classes, showcasing both violations and valid syntax for testing purposes.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyupgrade/UP030_1.py",
            "description": "This file serves as a test fixture for the Ruff linter, providing valid Python `.format()` and f-string usages that should not trigger any `pyupgrade` (UP030) errors.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyupgrade/UP033_1.py",
            "description": "This file is a test fixture for the ruff linter's pyupgrade UP033 rule. It demonstrates various uses of the `functools.lru_cache` decorator, including cases with `maxsize=None` that are expected to trigger the linter rule, and other valid or scope-related uses that should not.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyupgrade/UP047_1.py",
            "description": "This file is a test fixture for the `ruff_linter`, demonstrating that the UP047 rule correctly ignores `TypeVar` definitions with default arguments when imported from `typing_extensions` for Python version compatibility.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyupgrade/UP036_4.py",
            "description": "This file is a test fixture for the ruff linter, specifically for the pyupgrade UP036 rule. It demonstrates various conditional blocks using `sys.version_info < (3, 3)` to test how the linter handles checks for older Python versions.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyupgrade/UP046_1.py",
            "description": "Tests a `pyupgrade` scenario (UP046) where `AnyStr` cannot be replaced due to the `str` builtin being shadowed, specifically demonstrating this edge case.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyupgrade/UP036_0.py",
            "description": "This file contains various `sys.version_info` conditional statements, testing how a linter handles Python version-specific code execution and declarations across different syntax patterns and version comparisons. It serves as a test fixture for the `pyupgrade` rule UP036 in `ruff_linter`.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyupgrade/UP046_2.py",
            "description": "This test fixture demonstrates the use of `typing_extensions.TypeVar` with a default argument for compatibility with Python versions before 3.13. It verifies that the `UP046` lint rule does not incorrectly flag this specific usage.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyupgrade/UP044.py",
            "description": "This file contains test cases demonstrating various uses and limitations of `Unpack` within Python type hints, including with `TypeVarTuple`, `Generic`, and `TypedDict`.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyupgrade/UP040.py",
            "description": "This file contains test cases for the `UP040` linter rule, which targets various usages of `typing.TypeAlias` and `TypeAliasType` definitions, including those involving `typing.TypeVar` and generics.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyupgrade/UP032_2.py",
            "description": "This file serves as a test fixture for the `pyupgrade` rule `UP032` in the Ruff linter, demonstrating various cases where the `.real` attribute is redundantly or incorrectly used in string formatting with `format()`.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyupgrade/UP034.py",
            "description": "This file serves as a test fixture for the `UP034` linting rule, demonstrating cases where parentheses are redundant and should be removed, as well as valid uses of parentheses that should be ignored by the linter.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyupgrade/UP006_3.py",
            "description": "This file is a test fixture for the ruff linter's `pyupgrade` rule `UP006`. It demonstrates a type hint using a string literal for `typing.DefaultDict`, which the linter aims to identify and potentially simplify.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyupgrade/UP028_1.py",
            "description": "This file contains a collection of test cases for the `pyupgrade` linter rule `UP028`. It demonstrates various scenarios of `yield` statements within `for` loops, including how loop variables are accessed or modified within and after the loop.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyupgrade/UP045_py39.py",
            "description": "This file is a regression test for Ruff's UP045 rule, specifically designed to check its behavior with `Optional` type hints, including stringified annotations and `TypeAlias` declarations, and to identify cases where the rule might fail to flag issues.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyupgrade/UP036_5.py",
            "description": "This file serves as a test fixture for the `pyupgrade` rule `UP036` within the Ruff linter, evaluating its behavior against various `sys.version_info` comparisons to ensure correct flagging of version-specific code.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyupgrade/UP038.py",
            "description": "Tests the `pyupgrade` UP038 rule in Ruff, which flags the use of tuples for type unions in `isinstance` and `issubclass` calls, preferring the `|` operator instead.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyupgrade/UP045.py",
            "description": "This file serves as a test fixture for the `pyupgrade` (UP045) rule in the `ruff` linter, demonstrating various valid and invalid uses of `typing.Optional` annotations. It includes regression tests for specific issues related to `Optional[None]`, `NamedTuple`, nested optionals, and complex type annotations.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyupgrade/UP036_2.py",
            "description": "This file serves as a test fixture for the `UP036` rule within the `pyupgrade` linter, demonstrating various `sys.version_info` checks for Python version compatibility.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyupgrade/UP024_0.py",
            "description": "This file serves as a test fixture for the `ruff_linter`'s `pyupgrade` rules, specifically `UP024`. It contains various `try...except` blocks demonstrating deprecated exception types and their modern `OSError` equivalents to verify the linter's detection and autofix capabilities.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyupgrade/UP030_0.py",
            "description": "This file serves as a test fixture for the ruff linter's `pyupgrade` rule `UP030`, demonstrating various invalid uses of string `.format()` calls that are expected to trigger linting errors.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyupgrade/UP028_0.py",
            "description": "This file contains test cases for the `pyupgrade` linter rule `UP028` in Ruff, demonstrating various scenarios involving loop variable shadowing in generator functions. It includes both cases where the rule should trigger and cases where it should be ignored (marked as 'OK').",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyupgrade/UP036_1.py",
            "description": "This file contains various `sys.version_info` checks, serving as a test fixture for the `pyupgrade` linter rule `UP036`, which targets and flags Python 2 compatibility checks.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyupgrade/future_annotations.py",
            "description": "This file serves as a test fixture for `ruff_linter`'s `pyupgrade` rules, demonstrating various type hinting scenarios, including `__future__ import annotations`, forward references, `dataclass` type hints, and `TypeAlias` definitions.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyupgrade/UP049_1.py",
            "description": "This file serves as a test fixture for the `ruff` linter's `pyupgrade` rule UP049, demonstrating various scenarios for type variable syntax in generic classes, including cases for renaming, name collisions, and unfixable issues.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyupgrade/UP050.py",
            "description": "Provides test cases for the `pyupgrade` rule UP050, which targets redundant explicit `metaclass=type` declarations in class definitions. It covers various scenarios including formatting, comments, inheritance, and local/aliased `type` usage.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyupgrade/UP047_0.py",
            "description": "This file serves as a test fixture for `pyupgrade` rule UP047, demonstrating various uses of `TypeVar`, `ParamSpec`, and `TypeVarTuple` in type annotations. It includes examples of constrained, bound, and default type variables, along with a 'broken fix' scenario highlighting limitations in type variable conversion across module boundaries.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyupgrade/UP033_0.py",
            "description": "Test fixture for the `pyupgrade` rule `UP033` in `ruff`, demonstrating cases where `functools.lru_cache(maxsize=None)` should and should not be upgraded to `functools.cache`.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyupgrade/UP029_3.py",
            "description": "This file serves as a test fixture for the Ruff linter's `UP029` rule, which detects unnecessary imports of built-in functions. It includes various scenarios to test how the linter handles shadowing, star imports, and direct imports of built-ins, demonstrating both expected and false positive detections.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyupgrade/UP041.py",
            "description": "This file serves as a test fixture for the Ruff linter's `pyupgrade` rule UP041, demonstrating various scenarios for handling `asyncio.TimeoutError` and `socket.timeout` in `try...except` blocks.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyupgrade/UP049_0.py",
            "description": "This file serves as a test fixture for the `pyupgrade` linter rule `UP049`, demonstrating various usages of generic type variables in classes and functions, including their application in type hints, return types, and within method bodies.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyupgrade/UP024_4.py",
            "description": "This file is a test fixture for the `ruff` linter's `pyupgrade` rule UP024, demonstrating an outdated `socket.error` exception handling pattern within a `kombu` connection attempt.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyupgrade/UP037_0.py",
            "description": "This file serves as a test fixture for the Ruff linter, specifically for the `pyupgrade` rule `UP037`. It demonstrates various scenarios of string-based type annotations across functions, variables, and complex typing constructs like `NamedTuple` and `TypedDict`.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyupgrade/UP046_0.py",
            "description": "This file serves as a test fixture for a linter rule (likely `pyupgrade`'s UP046) that validates and potentially modernizes `Generic` class definitions and `TypeVar` usage in Python. It demonstrates various valid and invalid patterns, including `TypeVarTuple`, `ParamSpec`, multiple inheritance, and specific edge cases related to `Generic` and `TypeVar` declarations.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyupgrade/UP037_1.py",
            "description": "This file is a test fixture for the `ruff_linter`'s `pyupgrade` rule `UP037`, demonstrating the flagging of quoted type annotations, specifically for `Tuple`.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/refurb/FURB110.py",
            "description": "This file contains test cases for the `FURB110` linter rule, demonstrating various redundant conditional expressions where the condition is the same as the 'true' value (e.g., `x if x else y`). It includes examples with different formatting and multi-line structures to ensure comprehensive rule testing.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/refurb/FURB105.py",
            "description": "This file serves as a test fixture for the `FURB105` linter rule, showcasing various `print` function calls that are expected to raise errors, alongside examples that are considered valid.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/refurb/FURB161.py",
            "description": "This file serves as a test fixture for the `FURB161` rule in the Ruff linter, demonstrating cases where `bin(...).count(\"1\")` should be flagged and where `bit_count()` is considered acceptable.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/refurb/FURB113.py",
            "description": "This file serves as a test fixture for the `FURB113` linter rule, demonstrating various cases of consecutive list `append` calls that should trigger or not trigger the rule.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/refurb/FURB131.py",
            "description": "This file serves as a test fixture for the Ruff linter, specifically designed to verify the detection of the `FURB131` rule. It includes examples of `del` statements that should trigger the rule (clearing lists or dictionaries) and those that should not.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/refurb/FURB101_0.py",
            "description": "This file serves as a test fixture for the Ruff linter, specifically demonstrating cases that should and should not trigger the FURB101 rule. It illustrates scenarios where `open()` followed by `f.read()` can potentially be refactored using `pathlib.Path.read_text()` or `read_bytes()`.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/refurb/FURB140.py",
            "description": "This file serves as a test fixture for the Ruff linter's FURB140 rule, demonstrating cases that should and should not trigger the rule in list, generator, and set comprehensions when calling a function with unpacked iteration variables.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/refurb/FURB168.py",
            "description": "This file contains test cases for the `FURB168` linter rule, demonstrating various `isinstance` checks that involve `type(None)` or `None` within type hints, classifying them as either erroneous/redundant or acceptable patterns.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/refurb/FURB101_1.py",
            "description": "Test fixture for the `refurb` linter (FURB101), demonstrating common file opening patterns using `pathlib.Path.open()`.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/refurb/FURB167.py",
            "description": "Test fixture for the `FURB167` linter rule, demonstrating the detection of `re.I` usage instead of `re.IGNORECASE` in regular expression searches.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/refurb/FURB169.py",
            "description": "This file is a test fixture for the `Refurb` linter (rule `FURB169`). It contains various Python expressions to test the linter's ability to identify and flag incorrect comparisons involving `type(None)` vs. correct `is None` checks.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/refurb/FURB122.py",
            "description": "This file contains test cases for the `FURB122` rule in the Ruff linter, demonstrating correct and incorrect patterns for writing to a file inside a loop. It serves as a fixture to verify the linter's detection of inefficient `f.write()` calls that could be replaced by `f.writelines()`.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/refurb/FURB164.py",
            "description": "This file serves as a test fixture for the Ruff linter rule FURB164, demonstrating various cases of `Fraction` and `Decimal` initialization from floats or decimals, including those that should trigger errors, be considered 'OK', or require specific types of fixes (safe/unsafe).",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/refurb/FURB145.py",
            "description": "Test fixtures for the `FURB145` linter rule, demonstrating various list slicing operations including redundant copies (`l[:]`, `l[::]`) that should be flagged, and valid slices that should be ignored.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/refurb/FURB132.py",
            "description": "This file serves as a test fixture for the 'FURB132' linter rule, demonstrating various scenarios where an item is checked for existence in a collection before being removed. It includes both cases that should trigger the linter warning and those that should not.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/refurb/FURB152.py",
            "description": "This file contains test cases for the `FURB152` linter rule, evaluating various floating-point approximations of mathematical constants like Pi and Euler's number to determine which ones trigger the rule.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/refurb/FURB103_0.py",
            "description": "This file serves as a test fixture for the Ruff linter's Refurb plugin, specifically for rule FURB103. It demonstrates various scenarios where `open().write()` is used, differentiating between cases that should trigger the linter warning and those that should not.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/refurb/FURB156.py",
            "description": "This file serves as a test fixture for the `FURB156` linter rule, demonstrating various string literals that should trigger errors, along with examples that are considered valid or are explicitly ignored, such as docstrings.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/refurb/FURB136.py",
            "description": "This file serves as a test fixture for the Ruff linter, specifically for the `refurb/FURB136` rule. It demonstrates various conditional expressions to check when the rule should or should not flag issues.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/refurb/FURB171_0.py",
            "description": "This file contains test cases for the `FURB171` linter rule, demonstrating both expected errors and non-errors for membership tests (`in` and `not in`) with single-element collections. It includes various data types and edge cases like `math.nan` and custom `__eq__` methods.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/refurb/FURB180.py",
            "description": "This file contains test cases for the Refurb (FURB180) linter rule, demonstrating correct and incorrect ways to define abstract base classes using `abc.ABCMeta` and `abc.ABC`.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/refurb/FURB162.py",
            "description": "This file contains test cases for a linter rule (FURB162) that identifies redundant or potentially incorrect manual timezone offset handling (e.g., stripping 'Z' and adding '+00:00') when using `datetime.fromisoformat`.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/refurb/FURB116.py",
            "description": "This file serves as a test fixture for the 'FURB116' linting rule, demonstrating various scenarios where `oct()`, `hex()`, and `bin()` calls are followed by `[2:]` slicing, including cases for autofix, no autofix, and expected ignorable inputs.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/refurb/FURB177.py",
            "description": "This file serves as a test fixture for the `FURB177` linter rule, demonstrating both erroneous and correct uses of `pathlib.Path().resolve()` methods.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/refurb/FURB163.py",
            "description": "This file serves as a test fixture for the Ruff linter, specifically demonstrating cases where `math.log` calls with bases 2, 10, or `math.e` should be flagged for replacement by `math.log2`, `math.log10`, or `math.log` (single argument), respectively. It includes both error-producing and acceptable `math.log` usages, along with related edge cases and issue reproductions.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/refurb/FURB181.py",
            "description": "This file is a test fixture for the Ruff linter's FURB181 rule, demonstrating various valid and invalid usages of hashing algorithms from the `hashlib` module, particularly focusing on the `digest().hex()` pattern.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/refurb/FURB154.py",
            "description": "This file serves as a test fixture for the Ruff linter's FURB154 rule, demonstrating various valid and invalid uses of `global` and `nonlocal` statements, including redundant declarations.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/refurb/FURB103_1.py",
            "description": "This file is a test fixture for the ruff linter, demonstrating various uses of `pathlib.Path.open()` for writing to files. It likely serves to test a linter rule (e.g., refurb's FURB103) that suggests using `Path.write_text()` or `Path.write_bytes()` instead.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/refurb/FURB171_1.py",
            "description": "This file serves as a test fixture for the Ruff linter's `FURB171` rule, demonstrating cases where `set()` or `frozenset()` are initialized with single-element iterables (which can be optimized) and edge cases like `NaN`.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/refurb/FURB188.py",
            "description": "This file serves as a test fixture for the Refurb linter, extended with ruff-specific cases, to evaluate rules related to `str.removeprefix` and `str.removesuffix` suggestions, particularly when `startswith`/`endswith` checks are followed by string slicing.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/refurb/FURB148.py",
            "description": "This file is a test fixture for a linter rule (likely FURB148) that checks for suboptimal uses of `enumerate`. It demonstrates various cases where either the index or the item from `enumerate` is ignored, as well as correct usage and alternative iteration patterns.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/refurb/FURB189.py",
            "description": "This file serves as a test fixture for the `FURB189` linter rule, showcasing various class definitions including direct subclasses of built-in types (dict, list, str) to be detected by the linter, as well as classes that should be ignored.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/refurb/FURB142.py",
            "description": "This file is a test fixture for the `FURB142` linting rule, demonstrating various `for` loop patterns involving `set.add` or `set.discard` operations to identify cases that should be flagged, ignored, or optimized. It covers different iterables, expression types, and specific edge cases like `lambda` and ternary expressions.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/refurb/FURB118.py",
            "description": "This file serves as a test fixture for the Ruff linter's `FURB118` rule, demonstrating various `lambda` and simple function definitions that should or should not be flagged for potential replacement by `operator` module functions. It includes examples of unary/binary operations, item getters, and contextual uses of lambdas like in class methods or decorators.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/refurb/FURB157.py",
            "description": "This file provides test cases for the Ruff linter rule FURB157, which identifies verbose or problematic usages of the `decimal.Decimal` constructor, especially when converting floats or parsing strings with non-standard formatting.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/refurb/FURB192.py",
            "description": "This file is a test fixture for the `FURB192` rule in the `ruff` linter's `refurb` plugin. It provides examples of `sorted()` function calls that should trigger (or not trigger) the linter rule for various patterns.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/refurb/FURB129.py",
            "description": "This file serves as a test fixture for the Ruff linter's `FURB129` rule, demonstrating various correct and incorrect usages of `file.readlines()` to ensure the rule effectively flags inefficient or problematic patterns.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/refurb/FURB187.py",
            "description": "This file contains test cases for a linter rule (likely FURB187) that identifies instances where a sequence is 'reversed' using `reversed()` or `[::-1]` and the result is immediately reassigned back to the original variable, which can be an inefficient or misleading operation if in-place reversal was intended.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/refurb/FURB166.py",
            "description": "This file is a test fixture for the `FURB166` rule in the Ruff linter, designed to identify and flag redundant string slicing when converting base-prefixed string literals to integers using `int()` with an explicit base.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/syntax_errors/yield_from_in_async_function.py",
            "description": "This file is a test fixture for the `ruff` linter, demonstrating a syntax error where 'yield from' is used inside an asynchronous function.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/syntax_errors/late_future_import.py",
            "description": "This file is a test fixture demonstrating a syntax error that occurs when a `from __future__` import statement is not placed at the very beginning of the file, after other imports.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/syntax_errors/load_before_global_declaration.py",
            "description": "This file serves as a test fixture for a linter, demonstrating correct and incorrect usage of the 'global' keyword in Python functions, specifically showcasing scenarios that lead to syntax errors.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/syntax_errors/async_comprehension.py",
            "description": "This file is a test fixture for the Ruff linter, designed to demonstrate and test the detection of syntax errors related to the incorrect use of asynchronous constructs (like 'async for' or 'async with') within a synchronous function.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/tryceratops/TRY203.py",
            "description": "This file serves as a test fixture for the Ruff linter's TRY203 rule, demonstrating various `try...except...raise` patterns to identify direct re-raising of exceptions after being rescued.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/tryceratops/TRY301.py",
            "description": "This Python file serves as a test fixture for the 'TRY301' linter rule. It demonstrates code patterns that violate the rule (raising exceptions within a `try` block) and patterns that comply with it.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/tryceratops/TRY300.py",
            "description": "This file serves as a test fixture for the `tryceratops` linter rule TRY300, demonstrating valid and invalid patterns for returning values from `try` blocks versus `else` blocks.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/tryceratops/TRY400.py",
            "description": "This file contains test cases for the `TRY400` Tryceratops rule, demonstrating when to use `.exception()` versus `.error()` for logging exceptions within `except` blocks. It illustrates 'bad' examples that trigger the rule and 'good'/'fine' examples that comply or correctly handle exception logging.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/tryceratops/TRY003.py",
            "description": "This file contains various Python code snippets designed to test the `TRY003` rule of the Tryceratops linter, demonstrating both violations and acceptable patterns for exception message formatting.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/tryceratops/TRY002.py",
            "description": "This file serves as a test fixture for the `tryceratops` linter, specifically for rule TRY002. It demonstrates various scenarios of raising `Exception` and `BaseException`, some of which are expected to trigger violations for raising vanilla exceptions with custom messages, and others that should be ignored.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/tryceratops/TRY004.py",
            "description": "This file serves as a test fixture for the Tryceratops linter rule TRY004, demonstrating cases where exceptions other than `TypeError` are raised after type-checking conditions, which should ideally be `TypeError`.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/tryceratops/TRY401.py",
            "description": "This file serves as a test fixture for the Ruff linter's TRY401 rule, demonstrating various scenarios where exceptions are logged. It includes examples expected to trigger the TRY401 error and examples considered 'OK' by the linter, primarily focusing on how exception objects are passed to logging functions.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/tryceratops/TRY201.py",
            "description": "This file serves as a test fixture for the Ruff linter's `tryceratops` plugin, specifically demonstrating valid and invalid patterns for re-raising exceptions (TRY201) after catching them.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pylint/bad_str_strip_call.py",
            "description": "This file serves as a test fixture for the Pylint rule PLE1310 within the Ruff linter, demonstrating various string strip calls that should and should not trigger the warning.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pylint/bad_string_format_type.py",
            "description": "Test fixtures for the Pylint `bad-string-format-type` rule, demonstrating various cases of type mismatches in string formatting using the '%' operator, including errors, false negatives, and correct usages.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pylint/bad_open_mode.py",
            "description": "This file serves as a test fixture for a linter, demonstrating various valid and invalid mode strings used with `open()` and `pathlib.Path.open()` to detect 'bad-open-mode' issues.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pylint/bad_string_format_character.py",
            "description": "Tests the `bad-format-character` linting rule across old-style string formatting, new-style `.format()` method, and f-strings, demonstrating both expected errors and correct usage.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pylint/global_statement.py",
            "description": "This file contains test cases demonstrating the `global` statement in Python, specifically for validating or testing a linter's `global-statement` rule, showing various scenarios like reassignments, imports, and overrides.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pylint/comparison_of_constant.py",
            "description": "This file is a test fixture for a linter, specifically demonstrating cases where Pylint's 'comparison-of-constants' rule should or should not trigger. It contains examples of comparing constant values and variable values to show expected linting behavior.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pylint/invalid_all_format.py",
            "description": "This file serves as a test fixture for the `invalid-all-format` lint rule, demonstrating various valid and invalid assignments to the `__all__` variable in Python.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pylint/bad_staticmethod_argument.py",
            "description": "This file contains test cases for a linter, specifically checking for incorrect usage of `self` or `cls` as the first argument in `staticmethod` definitions, and demonstrating exceptions for `__new__`.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pylint/import_aliasing.py",
            "description": "This file serves as a test fixture for the 'ruff_linter' to demonstrate and test various Pylint-related import aliasing checks, such as 'useless-import-alias' and 'consider-using-from-import'.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pylint/boolean_chained_comparison.py",
            "description": "This file contains test cases for a linter rule (`boolean-chained-comparison`) in Ruff, demonstrating various valid and invalid patterns of chained comparison operators for detection and fixing.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pylint/if_stmt_min_max.py",
            "description": "This file contains test cases for a linter rule that suggests replacing specific `if` statements with `min()` or `max()` function calls. It demonstrates various scenarios, including basic assignments, class attributes, and dictionary elements, as well as cases where the refactoring should not be applied.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pylint/global_at_module_level.py",
            "description": "This file is a test fixture for the Ruff linter, designed to verify the detection of 'global' statements at the module level, corresponding to Pylint warning W0604.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pylint/empty_comment_line_continuation.py",
            "description": "Tests Pylint's handling of empty comment lines combined with line continuations in Python code.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pylint/empty_comment.py",
            "description": "This file serves as a test fixture for the ruff linter, demonstrating various examples of comments, specifically to test the detection and handling of 'empty comments' by a Pylint-related rule.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pylint/assert_on_string_literal.py",
            "description": "This file contains test cases for a linter rule that flags `assert` statements where the primary assertion is a string literal. It demonstrates various scenarios where the rule should and should not be applied.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pylint/collapsible_else_if.py",
            "description": "This file contains test cases for a linter rule (likely Pylint's 'else-if-used' check) that identifies collapsible 'else if' constructs. It demonstrates both valid and invalid code patterns related to this rule.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pylint/continue_in_finally.py",
            "description": "This file contains test cases for the `continue-in-finally` linting rule, demonstrating various scenarios where a `continue` statement appears within a `finally` block.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pylint/logging_too_many_args.py",
            "description": "This file contains test cases for the `logging-too-many-args` linter rule, demonstrating correct and incorrect usage of logging functions with positional arguments and various edge cases.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pylint/comparison_with_itself.py",
            "description": "This file serves as a test fixture for the `pylint` linter, specifically designed to check for redundant or always-true/false comparisons where an object is compared to itself.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pylint/invalid_return_type_str.py",
            "description": "This file serves as a test fixture for a linter, specifically designed to check for incorrect return types from `__str__` magic methods. It includes examples that should trigger errors and others that should pass without issues.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pylint/global_variable_not_assigned.py",
            "description": "Test fixtures for the `global-variable-not-assigned` Pylint rule, demonstrating scenarios where a global variable is used or deleted without prior assignment within a function, alongside non-error cases.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pylint/invalid_return_type_bool.py",
            "description": "Tests the linter's ability to detect invalid return types for the `__bool__` dunder method, including both cases that should and should not raise an `invalid-bool-return` error.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pylint/invalid_return_type_length.py",
            "description": "This file serves as a test fixture for a linter, demonstrating various valid and invalid return types for the `__len__` magic method. It's used to verify that the linter correctly identifies and flags non-integer or non-returning `__len__` implementations.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pylint/sys_exit_alias_13.py",
            "description": "Tests the `exit()` function with a specified exit code.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pylint/bad_dunder_method_name.py",
            "description": "This file serves as a test fixture for a linter rule (`bad-dunder-name`) that identifies incorrectly named or misspelled dunder (double underscore) methods in Python classes. It includes examples of both invalid method names that should trigger the rule and valid/allowed method names that should not.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pylint/redefined_slots_in_subclass.py",
            "description": "This file serves as a test fixture for a linter, demonstrating various scenarios of `__slots__` redefinition in Python subclasses. It includes examples designed to trigger the `redefined-slots-in-subclass` linting rule.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pylint/misplaced_bare_raise.py",
            "description": "This file serves as a test fixture for a linter, demonstrating various valid and invalid placements of bare `raise` statements. It's used to test the detection of 'misplaced-bare-raise' linting errors.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pylint/dict_iter_missing_items.py",
            "description": "Test fixture for a linter rule that identifies incorrect dictionary iteration, specifically when `dict.items()` is omitted, and distinguishes between error and non-error cases.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pylint/compare_to_empty_string.py",
            "description": "This file is a test fixture for the ruff linter, demonstrating various string comparisons against empty strings, likely to test Pylint-related rules for such comparisons.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pylint/misplaced_comparison_constant.py",
            "description": "This file contains test cases for a linter rule that checks for misplaced comparison constants, ensuring they are on the right side of the comparison operator. It includes examples of both compliant and non-compliant code patterns.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pylint/logging_too_few_args.py",
            "description": "This file is a test fixture for a linter, specifically designed to test the `logging-too-few-args` rule. It includes examples of logging calls that should trigger the rule and various edge cases that should be ignored, demonstrating the rule's behavior and limitations.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pylint/non_ascii_name.py",
            "description": "This file is a test fixture for the Ruff linter, demonstrating various usages of non-ASCII variable names to test detection of issues like Pylint's C2401.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pylint/binary_op_exception.py",
            "description": "This file serves as a test fixture for the ruff linter, demonstrating incorrect uses of binary operators ('or', 'and') directly with exception types in `except` clauses, which the `binary-op-exception` rule is designed to flag.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pylint/stop_iteration_return.py",
            "description": "This file contains test cases for the Pylint rule PLR1708 (stop-iteration-return) in Ruff, demonstrating valid and invalid uses of `StopIteration` within generator functions.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pylint/no_method_decorator.py",
            "description": "Tests linter rules for `classmethod` and `staticmethod` when applied via direct assignment rather than decorators, specifically checking for missing decorators.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pylint/non_ascii_module_import.py",
            "description": "This file serves as a test case for `pylint` to evaluate how it handles non-ASCII characters in various import statements, including aliases and module names, distinguishing between valid and invalid usages.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pylint/sys_exit_alias_11.py",
            "description": "This file is a test fixture for the 'pylint' linter, demonstrating the use of 'exit(0)' after importing all names from the 'sys' module.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pylint/invalid_characters_syntax_error.py",
            "description": "This file contains Python code snippets with various syntax errors, specifically unterminated strings containing backspace characters. It serves as a test fixture for `ruff_linter` to verify correct error handling and highlighting behavior in such cases.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pylint/literal_membership.py",
            "description": "This file provides test cases for a linter, demonstrating various usages of the `in` operator with literal collections. It distinguishes between expected linter errors and valid code for literal membership checks.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pylint/self_or_cls_assignment.py",
            "description": "This file contains test cases for the Pylint rule PLW0642, demonstrating when `self` or `cls` parameters are incorrectly reassigned within class methods, instance methods, and `__new__` methods.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pylint/missing_maxsplit_arg.py",
            "description": "This file contains test cases for the `missing-maxsplit-arg` Pylint rule, demonstrating scenarios where `str.split()` or `str.rsplit()` are called and immediately indexed at `[0]` or `[-1]` without specifying the `maxsplit` argument, which could be optimized.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pylint/magic_value_comparison.py",
            "description": "This file serves as a test fixture for the Ruff linter, demonstrating various examples of 'magic value comparison' and 'comparison of constants' rules to verify the linter's behavior.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pylint/invalid_return_type_index.py",
            "description": "This file serves as a test fixture for the Ruff linter, demonstrating valid and invalid return types for the `__index__` magic method to verify the detection of `invalid-index-return` errors.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pylint/duplicate_bases.py",
            "description": "This file contains test cases for a linter, specifically demonstrating class definitions with duplicate base classes (expected errors) and valid inheritance patterns (expected non-errors) to check linter rule Pylint PLW0240.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pylint/sys_exit_alias_3.py",
            "description": "Tests linting rules for `sys.exit` and `quit` usage, including scenarios where `exit` is reassigned locally, causing a `TypeError` when called.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pylint/invalid_return_type_hash.py",
            "description": "This file contains test cases for a linter to validate the return type of `__hash__` methods. It demonstrates both correct and incorrect return values for the `__hash__` special method.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pylint/repeated_keyword_argument.py",
            "description": "This file contains test cases for detecting repeated keyword arguments in Python function calls, showcasing both valid and invalid scenarios involving direct arguments and dictionary unpacking.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pylint/nan_comparison.py",
            "description": "This file contains test cases for a linter, demonstrating correct and incorrect ways to compare floating-point 'Not a Number' (NaN) values using `float`, `math`, and `numpy`.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pylint/singledispatch_method.py",
            "description": "This file demonstrates the usage of `@singledispatch` and `@singledispatchmethod` decorators in Python, showcasing their application to class methods, static methods, and instance methods. It also includes examples illustrating the `singledispatch-method` linting rule and false negatives related to `singledispatch.register`.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pylint/return_in_init.py",
            "description": "This file serves as a test fixture for the `ruff` linter, specifically for a rule (likely Pylint-related) that detects and flags inappropriate `return` statements within `__init__` methods of classes.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pylint/sys_exit_alias_6.py",
            "description": "This file tests how a linter handles calls to the built-in `exit()` and `quit()` functions, especially when those names are later shadowed by user-defined functions.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pylint/redeclared_assigned_name.py",
            "description": "Tests Ruff's `PLW0128` (redeclared-assigned-name) rule with various examples of variable re-declaration in assignment statements, including unpacking and multiple assignments. It demonstrates scenarios where this warning should and should not be triggered.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pylint/modified_iterating_set.py",
            "description": "This file serves as a test fixture for the 'pylint' linter, demonstrating cases of modifying a set while iterating over it that should raise errors, alongside examples that are considered safe or acceptable.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pylint/repeated_equality_comparison.py",
            "description": "This file contains test cases for a linter rule that identifies repeated equality or inequality comparisons, checking for both valid and invalid scenarios. It demonstrates cases where comparisons can be refactored into membership tests and situations where they should not be.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pylint/property_with_parameters.py",
            "description": "This file serves as a test fixture for the Ruff linter, demonstrating various Python property definitions that incorrectly include parameters in their getter methods. It specifically tests the detection of the 'property-with-parameters' linting rule.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pylint/redefined_loop_name.py",
            "description": "This file contains test cases for the `redefined_loop_name` pylint rule in the Ruff linter. It demonstrates various scenarios where loop variables are redefined within nested loops, `with` statements, or through assignments, marking expected errors and non-errors.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pylint/invalid_return_type_bytes.py",
            "description": "This file contains test cases for the `ruff_linter` to verify its ability to detect invalid return types for the `__bytes__` magic method. It includes examples that should and should not raise `invalid-bytes-return` errors.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pylint/iteration_over_set.py",
            "description": "This file serves as a test fixture for a linter, demonstrating examples of iterating over set literals that should be flagged as errors, as well as valid iteration patterns that should not trigger warnings.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pylint/sys_exit_alias_1.py",
            "description": "Test fixture for the `ruff` linter, specifically for Pylint rules related to `sys.exit` aliases, demonstrating direct calls to `exit()` and `quit()` and scenarios where `sys` is shadowed.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pylint/redefined_argument_from_local.py",
            "description": "This file serves as a test fixture for a linter, demonstrating various scenarios where a function argument is (or is not) redefined by a local variable within its scope, particularly in loops, exception handlers, and 'with' statements.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pylint/singledispatchmethod_function.py",
            "description": "Tests or demonstrates the `singledispatchmethod-function` linting rule by showing valid and invalid applications of `@singledispatchmethod` on functions and methods.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pylint/sys_exit_alias_5.py",
            "description": "Tests scenarios involving `exit()` and `quit()` calls after a wildcard import from the `sys` module, likely for a linter's analysis of system exit functions.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pylint/no_self_use.py",
            "description": "This file serves as a test fixture for the `pylint/no-self-use` rule in the Ruff linter, alongside other related linting checks for constructs like `@override`, `@staticmethod`, `@property`, `super()`, `attrs` validators, and `NotImplementedError` messages.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pylint/subprocess_popen_preexec_fn.py",
            "description": "This file serves as a test fixture for a linter, demonstrating correct and incorrect usages of the `preexec_fn` argument in `subprocess.Popen` calls.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pylint/load_before_global_declaration.py",
            "description": "This file serves as a test fixture for the 'pylint' linter, specifically designed to evaluate how it handles various `global` keyword usages relative to variable access and modification within function scopes, distinguishing between error and non-error scenarios.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pylint/self_assigning_variable.py",
            "description": "Test fixtures for the Pylint `self-assigning-variable` rule, demonstrating various cases of self-assignment that should or should not trigger a linter error.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pylint/bidirectional_unicode.py",
            "description": "This file serves as a test fixture for the `ruff_linter`, specifically designed to test the Pylint `E2502` rule, which identifies problematic bidirectional Unicode characters that can lead to code obfuscation or security vulnerabilities. It includes examples that should trigger the rule and those that should be considered valid.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pylint/too_many_arguments_params.py",
            "description": "This file serves as a test fixture for the 'pylint/too many arguments' rule, demonstrating scenarios with functions exceeding argument limits and how 'dummy_variable_rgx' (e.g., 'skip_') affects argument counting.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pylint/sys_exit_alias_10.py",
            "description": "This file is a test fixture for the Ruff linter, designed to test how it handles direct calls to `exit()` when `sys.exit` is aliased within a `TYPE_CHECKING` block.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pylint/sys_exit_alias_14.py",
            "description": "This file is a test fixture for the `ruff_linter`, designed to test a linter rule related to the `exit()` function, likely for `sys.exit` alias detection. It demonstrates calling `exit()` with keyword arguments.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pylint/unreachable.py",
            "description": "This file contains various Python functions designed as test cases for a linter to detect unreachable code after control flow statements like `return` and `raise`.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pylint/sys_exit_alias_16.py",
            "description": "This file contains test cases for linting `exit()` calls, demonstrating how a linter handles various argument types and preserved comments for `sys.exit` (or its alias) diagnostics.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pylint/sys_exit_alias_8.py",
            "description": "This test fixture demonstrates a Python program that exits successfully using the built-in `exit()` function, likely to check linting rules related to program termination or aliases of `sys.exit`.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pylint/unnecessary_dunder_call.py",
            "description": "This file serves as a test fixture for the `PLC2801` linter rule, demonstrating various cases of unnecessary direct calls to dunder (magic) methods in Python code.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pylint/single_string_slots.py",
            "description": "Tests linter rules related to `__slots__` definitions, specifically checking for cases where `__slots__` is assigned a single string instead of a tuple of strings.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pylint/dict_index_missing_items.py",
            "description": "This file serves as a test fixture for a linter, demonstrating cases where dictionary values are accessed inefficiently by key lookup within a loop that only iterates over keys. It contrasts these 'error' cases with efficient access using `.items()` and includes examples for other data types and complex usage.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pylint/nested_min_max.py",
            "description": "Tests various nested `min` and `max` function calls, including edge cases with keyword arguments, comments, iterables, and starred arguments, to validate a linter rule (PLW3301) for redundant min/max operations.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pylint/unnecessary_dict_index_lookup.py",
            "description": "This file contains test cases for the Pylint rule PLR1733, which identifies unnecessary dictionary index lookups. It demonstrates scenarios where the rule should trigger (when the value is already available from iteration) and where it should not (when the key or value is reassigned, or the value is explicitly ignored).",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pylint/too_many_positional_params.py",
            "description": "This file serves as a test fixture for a linter, specifically to test the 'too many positional arguments' rule in function definitions, including cases with dummy variable regex exceptions.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pylint/too_many_boolean_expressions.py",
            "description": "This file is a test fixture for the Pylint 'too-many-boolean-expressions' rule, demonstrating an `if/elif` chain with an increasing number of boolean conditions to test linter behavior.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pylint/unnecessary_lambda.py",
            "description": "This file serves as a test fixture for a linter rule that identifies and flags 'unnecessary lambda' expressions in Python code. It includes examples of lambdas that should be flagged, as well as cases that should be ignored by the linter.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pylint/sys_exit_alias_15.py",
            "description": "This file is a test fixture for the `ruff` linter, specifically for a `pylint` rule related to `sys.exit` aliases. It demonstrates how an exit code is determined and passed to the `exit()` function.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pylint/sys_exit_alias_9.py",
            "description": "This file is a test fixture demonstrating a direct call to `exit(0)` within a function, alongside an import from the `sys` module. It likely serves to test linting rules related to `sys.exit` usage or its aliases.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pylint/too_many_statements.py",
            "description": "This file is a test fixture for the `too-many-statements` Pylint rule in the Ruff linter, demonstrating a function that exceeds the allowed statement limit.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pylint/sys_exit_alias_7.py",
            "description": "This file is a test fixture for `pylint` checks within `ruff_linter`, likely demonstrating the behavior of the built-in `exit()` function.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pylint/sys_exit_alias_0.py",
            "description": "This file is a test fixture demonstrating the use of `exit()` and `quit()` functions with different exit codes, both at the module level and within a function.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pylint/too_many_public_methods.py",
            "description": "Test fixtures for the `too-many-public-methods` linter rule, demonstrating classes with various numbers of public methods, including scenarios with `__init__`, private methods, and overloaded method definitions.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pylint/len_as_condition.py",
            "description": "This file contains a comprehensive set of test cases for the Pylint rule `PLC1802` (len-as-condition) in the Ruff linter. It demonstrates various scenarios where using `len()` as a boolean condition should or should not trigger a linting error.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pylint/non_slot_assignment.py",
            "description": "This file is a test fixture for a linter, demonstrating various scenarios of `__slots__` usage in Python classes. It specifically tests the detection of `assigning-non-slot` errors when attributes not defined in `__slots__` are assigned, and valid assignments.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pylint/too_many_positional_arguments.py",
            "description": "This file contains test cases for a linter rule that detects functions or methods with an excessive number of positional arguments, mimicking Pylint's `too-many-positional-arguments` check.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pylint/too_many_return_statements_params.py",
            "description": "This file is a test fixture for the `ruff` linter, designed to verify its detection of the Pylint 'too many return statements' rule. It contains a function with multiple return statements that should trigger a linter warning.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pylint/yield_in_init.py",
            "description": "Test fixtures for pylint-related checks, specifically demonstrating various uses of `yield` within `__init__` methods of functions and classes.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pylint/sys_exit_alias_2.py",
            "description": "This file tests the usage of `exit()` and `quit()` functions for script termination. It demonstrates their behavior when called at the module level and within a function.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pylint/sys_exit_alias_4.py",
            "description": "This file is a test fixture for the Ruff linter, demonstrating calls to `exit()` and `quit()` functions, including scenarios where `sys.exit` is aliased.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pylint/non_augmented_assignment.py",
            "description": "This file serves as a test fixture for a linter, specifically designed to identify and flag instances of non-augmented assignments (e.g., `x = x + y` instead of `x += y`). It includes both expected errors and cases that should pass without flagging.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pylint/too_many_statements_params.py",
            "description": "This file is a test fixture for the Ruff linter, specifically designed to trigger a Pylint 'too-many-statements' error when the maximum allowed statements is set to one. It contains functions that exceed this limit.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pylint/nonlocal_and_global.py",
            "description": "Test fixtures for the Ruff linter, demonstrating correct and incorrect usages of `global` and `nonlocal` keywords in various Python function scopes.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pylint/invalid_characters.py",
            "description": "This file is a test fixture for the Ruff linter, demonstrating various 'invalid character' violations as defined by Pylint rules (e.g., backspace, substitute, escape, null, zero-width space) in strings and f-strings. It includes examples of both problematic character usage and their correct escaped representations.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pylint/too_many_arguments.py",
            "description": "This file serves as a test fixture for the Ruff linter, specifically to evaluate its 'too many arguments' rule (Pylint's R0913 check) across various function and method definitions, including special cases like decorators, positional-only, keyword-only, `self`/`cls` parameters, and `__new__`.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pylint/too_many_branches_params.py",
            "description": "This file is a test fixture for Pylint's 'too many branches' rule, demonstrating functions with varying levels of conditional branching complexity. It is used to test the linter's detection of excessive branching.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pylint/unnecessary_list_index_lookup.py",
            "description": "This file serves as a test fixture for the Pylint rule PLR1736 (unnecessary-list-index-lookup), demonstrating scenarios where the warning should and should not be triggered, including edge cases and exceptions.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pylint/useless_with_lock.py",
            "description": "This file serves as a test fixture for a linter rule that detects 'useless' `with` statements involving newly created threading synchronization primitives (Lock, RLock, Condition, Semaphore, BoundedSemaphore), contrasting them with valid uses of pre-assigned lock objects.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pylint/useless_else_on_loop.py",
            "description": "This file serves as a test fixture for the `pylint` rule `useless-else-on-loop`. It demonstrates various scenarios where the `else` branch of a loop is considered useless due to `break` or `return` statements, as well as cases that should not trigger the warning.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pylint/unnecessary_direct_lambda_call.py",
            "description": "This file is a test fixture for the Ruff linter, demonstrating code that triggers the `unnecessary-direct-lambda-call` diagnostic, which identifies direct calls to lambda expressions.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pylint/yield_from_in_async_function.py",
            "description": "This file is a Pylint test fixture for Ruff, demonstrating `yield` and `yield from` expressions within async functions. It provides examples of valid `yield` and an invalid `yield from` to be caught by linting rules.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pylint/useless_return.py",
            "description": "This file serves as a test fixture for the Ruff linter, specifically designed to identify and flag 'useless-return' statements in Python code, particularly when functions explicitly return `None` unnecessarily.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pylint/too_many_locals.py",
            "description": "This test fixture demonstrates the Pylint `PLR0914` rule (`too-many-locals`), showing a function that passes and one that fails the local variable limit.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pylint/unspecified_encoding.py",
            "description": "This file serves as a test fixture for a linter, demonstrating various Python file opening and manipulation functions (e.g., `open`, `io.TextIOWrapper`, `tempfile`, `codecs.open`, `pathlib.Path` methods) with and without explicit encoding specifications, differentiating between expected 'errors' and 'non-errors' for an 'unspecified encoding' rule.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pylint/useless_exception_statement.py",
            "description": "This file serves as a test fixture for the Pylint `PLW0133` rule in Ruff, demonstrating cases where exception or warning objects are instantiated but not raised or used, and distinguishing them from valid uses.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pylint/too_many_branches.py",
            "description": "This file contains test cases for detecting functions with an excessive number of branches, demonstrating how various control flow statements contribute to the branch count. It includes examples that are expected to trigger a 'too-many-branches' linting error and an example with nested functions.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pylint/unexpected_special_method_signature.py",
            "description": "This file is a test fixture for a linter, designed to verify its ability to detect incorrect or unexpected argument signatures for Python special (dunder) methods. It includes numerous examples with varying argument counts, types (mandatory, optional, `*args`, `**kwargs`, positional-only), and decorators (`@staticmethod`).",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pylint/too_many_nested_blocks.py",
            "description": "This file serves as a test fixture for the `too-many-nested-blocks` Pylint rule (PLR1702) within the Ruff linter. It includes examples of deeply nested code blocks to test the linter's detection capabilities.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pylint/too_many_return_statements.py",
            "description": "This file serves as a test fixture for the `ruff_linter` to verify the detection of functions with too many return statements, mirroring a Pylint rule. It includes a positive test case for multiple returns and a negative test case for multiple yields.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pylint/sys_exit_alias_12.py",
            "description": "This Pylint test fixture demonstrates the use of the built-in `exit()` function, likely for analyzing how Pylint handles program termination.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pylint/import_self/module.py",
            "description": "This file contains various forms of self-imports, likely serving as a test case for a linter to detect or handle these specific import patterns.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pylint/import_aliasing_2/__init__.py",
            "description": "This file is a test fixture demonstrating various import aliasing scenarios, including redundant aliasing where the alias is identical to the original module or object name. It's likely used to test static analysis tools for import resolution and aliasing detection.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pylint/import_private_name/__init__.py",
            "description": "This file defines a private variable `_top_level_secret` within the package. It serves as a test fixture for analyzing pylint's detection of private name imports.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pylint/import_private_name/submodule/__main__.py",
            "description": "This file serves as a test fixture for a linter, specifically demonstrating valid and invalid imports of private names according to linter rules, including special cases for built-in modules and type annotations.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pylint/import_private_name/submodule/__init__.py",
            "description": "This file defines a private variable within a submodule, serving as a test fixture for the 'import private name' linting rule in Pylint.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pylint/import_private_name/submodule/subsubmodule/__init__.py",
            "description": "This `__init__.py` file defines a private variable `_subsubmodule_secret` within a nested submodule. It serves as a test fixture to demonstrate how private names are handled during imports.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pylint/import_private_name/sibling_module/__init__.py",
            "description": "This `__init__.py` file defines private and public variables within a sibling module. It serves as a test fixture to evaluate linter behavior regarding the import of private names.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/semantic_errors/invalid_star_expression.py",
            "description": "This file contains test cases demonstrating invalid usage of star expressions in Python, specifically within return, for, and yield statements. It serves as a fixture for testing semantic error detection in a linter.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/semantic_errors/duplicate_match_class_attribute.py",
            "description": "This file is a test fixture for the `ruff_linter` demonstrating a semantic error: a 'match' statement with duplicate class attributes in a pattern.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/semantic_errors/duplicate_match_key.py",
            "description": "Tests the linter's ability to detect semantic errors, specifically duplicate keys within a dictionary pattern in a `match` statement.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/semantic_errors/global_parameter.py",
            "description": "This file contains test cases for semantic errors in Python, specifically demonstrating invalid usages of the 'global' keyword with function parameters.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/semantic_errors/irrefutable_case_pattern.py",
            "description": "Tests the detection of irrefutable 'case' patterns in Python's 'match' statements, where subsequent cases become unreachable. This file serves as a test fixture for semantic error analysis in the ruff linter.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/semantic_errors/single_starred_assignment.py",
            "description": "This file is a test fixture designed to trigger a semantic error in a linter. It demonstrates an invalid single starred assignment, specifically `*a = [1, 2, 3, 4]`.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/ruff/RUF010.py",
            "description": "This file contains test cases for the Ruff linter's RUF010 rule, demonstrating scenarios where `str()`, `repr()`, or `ascii()` calls are redundant inside f-strings when specific format specifiers (`!s`, `!r`, `!a`) can be used instead, along with valid cases that should not trigger the rule.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/ruff/RUF007.py",
            "description": "This file contains test cases for the RUF007 linter rule, demonstrating valid and invalid usages of the `zip` function with successive slices of the same iterable.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/ruff/RUF034.py",
            "description": "This file contains test cases for the RUF034 linter rule, demonstrating redundant conditional expressions where both branches yield the same value. It includes valid and invalid examples to verify the linter's detection capabilities.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/ruff/RUF015.py",
            "description": "This file contains test cases for the `RUF015` linter rule, demonstrating scenarios where a list or tuple is created and its first element is immediately accessed, alongside examples that should and should not trigger the linter warning.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/ruff/RUF016.py",
            "description": "This file serves as a test fixture for the RUF016 linter rule, demonstrating various valid and invalid index and slice access patterns on strings, lists, tuples, and bytes to verify the linter's behavior.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/ruff/RUF013_2.py",
            "description": "Test fixture for Ruff rule RUF013, demonstrating a function with an optional integer argument using `typing_extensions.Optional`.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/ruff/RUF024.py",
            "description": "This file serves as a test fixture for the RUF024 linting rule, demonstrating incorrect and correct usages of `dict.fromkeys` with mutable default values.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/ruff/RUF026.py",
            "description": "This file serves as a test fixture for the RUF026 linter rule, demonstrating various `defaultdict` usages that should and should not trigger the linting violation.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/ruff/RUF005_slices.py",
            "description": "Tests Ruff's RUF005 rule by demonstrating various list slicing and concatenation patterns, including cases that should and should not trigger the linter.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/ruff/RUF008_attrs.py",
            "description": "This file serves as a test fixture for the `ruff` linter's RUF008 rule, demonstrating various cases of mutable default arguments in `attrs` and `attr` class definitions, including both violations and correct implementations.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/ruff/RUF005.py",
            "description": "This file serves as a test fixture for the `ruff` linter's RUF005 rule, demonstrating various scenarios of list and tuple concatenations that are classified as non-fixable errors, fixable errors, and non-errors.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/ruff/RUF039_py_version_sensitive.py",
            "description": "Tests the `RUF039` linter rule for Python version-sensitive Unicode character names in regular expressions, specifically demonstrating a fix that depends on the target Python version (3.8+).",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/ruff/RUF017_1.py",
            "description": "This file serves as a test fixture for Ruff's RUF017 rule, demonstrating the use of `sum()` with an empty list as the start value to flatten an iterable.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/ruff/RUF006.py",
            "description": "This file contains test cases for the RUF006 linter rule, demonstrating correct and incorrect ways to manage `asyncio.Task` objects created via `create_task`, `ensure_future`, or `loop.create_task` to prevent their premature garbage collection.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/ruff/RUF027_2.py",
            "description": "This file is a test fixture for the RUF027 rule in Ruff, demonstrating the use of `eval()` to convert a string representation of a dictionary.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/ruff/RUF009.py",
            "description": "This file serves as a test fixture for the Ruff linter, specifically for rule RUF009, demonstrating various scenarios of mutable default arguments in dataclasses, ClassVar usage, and NewType definitions.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/ruff/RUF022.py",
            "description": "This file serves as a test fixture for the Ruff linter, showcasing various valid and invalid ways to define and modify `__all__` in Python modules. It covers single-line, multi-line, assignment, augmentation, and `extend` methods, including edge cases related to formatting, comments, and item types.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/ruff/RUF031_prefer_parens.py",
            "description": "This file contains test cases for the `RUF031_prefer_parens` rule, which checks for consistent use of parentheses around tuple keys in dictionary subscriptions. It includes various scenarios, edge cases, and exclusions to ensure the linter rule behaves correctly.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/ruff/RUF032.py",
            "description": "This file serves as a test fixture for the RUF032 linter rule, demonstrating various `Decimal` constructor calls, specifically highlighting cases where passing float literals directly should trigger a diagnostic or suggestion.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/ruff/RUF023.py",
            "description": "This file serves as a test fixture for a linter, showcasing various valid and invalid `__slots__` definitions in Python classes. It demonstrates different formatting styles, edge cases, and scenarios that should or should not be flagged and fixed by a linter.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/ruff/RUF027_1.py",
            "description": "This file serves as a test fixture for the Ruff linter's RUF027 rule. It contains various string formatting examples, including standard f-strings, `.format()` calls, and strings used in `gettext`, logging, and FastAPI path parameters, to verify correct rule application.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/ruff/RUF019.py",
            "description": "This file serves as a test fixture for the RUF019 linter rule in Ruff, demonstrating various `if 'key' in dict and dict['key']` patterns. It includes cases that should trigger the rule and some that are expected to be ignored.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/ruff/RUF009_attrs_auto_attribs.py",
            "description": "This file serves as a test fixture for the Ruff linter, demonstrating various configurations of `auto_attribs` within `attrs` and `attr` decorated classes. It's used to verify the linter's behavior, particularly for rule RUF009, when `auto_attribs` is explicitly set to `None` or omitted.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/ruff/RUF058_1.py",
            "description": "This file is a regression test for a Ruff issue (15786) where the `map` builtin is shadowed. It ensures a diagnostic is raised without an incorrect fix.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/ruff/RUF037.py",
            "description": "This file contains test cases for the RUF037 linter rule, which identifies redundant initializations of `collections.deque` with empty iterables. It demonstrates both triggering and non-triggering scenarios, including regression tests and specific cases involving `maxlen` arguments and string inputs.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/ruff/RUF027_0.py",
            "description": "This file serves as a test fixture for the RUF027 linter rule, demonstrating various string formatting scenarios to ensure the rule correctly identifies or ignores f-string-like syntax in regular strings. It includes examples for simple cases, escaped characters, raw strings, multi-line strings, and specific regression tests.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/ruff/RUF047_try.py",
            "description": "Test fixtures for the RUF047 rule, demonstrating scenarios where comments before `except`, `else`, or `finally` blocks might be incorrectly attributed, leading to linting errors or correct behavior.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/ruff/RUF031.py",
            "description": "This file is a test fixture for the Ruff linter's RUF031 rule, demonstrating various dictionary key access patterns, especially involving tuple indices, to test parenthesis handling.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/ruff/RUF046.py",
            "description": "This file serves as a test fixture for the RUF046 linter rule, demonstrating various scenarios of redundant `int()` calls, categorized by whether they are safely fixable, unsafe to fix, or not considered errors.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/ruff/RUF021.py",
            "description": "This file serves as a test fixture for the `RUF021` linter rule, demonstrating and validating its detection of operator precedence issues between `and` and `or` in Python expressions. It includes examples that violate the rule, showing the expected autofix, and cases that are considered compliant or correctly parenthesized.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/ruff/RUF033.py",
            "description": "This file serves as a test fixture for the RUF033 linter rule in Ruff, demonstrating valid and invalid uses of default parameters in `__post_init__` methods of dataclasses.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/ruff/RUF017_0.py",
            "description": "This file serves as a test fixture for the RUF017 linting rule, demonstrating cases where `sum()` is called with an explicit empty list as the `start` argument, which should trigger the linting error, alongside valid calls and regression tests.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/ruff/RUF055_1.py",
            "description": "Tests the `RUF055` rule's ability to track single string assignments used as pattern and replacement arguments in `re.sub`, and to correctly ignore aliases.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/ruff/RUF009_attrs.py",
            "description": "This file serves as a test fixture for the Ruff linter, specifically for rule RUF009 concerning mutable default arguments in `attrs` classes. It demonstrates various valid and invalid patterns for defining attributes with default values, including different `attrs` decorators and field definitions, and includes regression tests for known issues.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/ruff/RUF054.py",
            "description": "This test fixture for the Ruff linter (`RUF054`) demonstrates and verifies the detection of form feed characters in Python code, showcasing both erroneous and acceptable usages.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/ruff/RUF029.py",
            "description": "This file serves as a test fixture for the RUF029 linter rule, demonstrating various valid and invalid asynchronous function implementations. It includes examples that should and should not trigger the linter warning for unused async functions.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/ruff/RUF040.py",
            "description": "This file serves as a test fixture for the RUF040 linting rule in Ruff, containing code that likely demonstrates a scenario for this specific check.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/ruff/RUF047_if.py",
            "description": "Test fixture for the RUF047 linter rule, demonstrating cases where comments are considered to be part of `if`/`else` blocks and where they are not.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/ruff/RUF045.py",
            "description": "This file serves as a test fixture for the RUF045 linter rule in Ruff. It defines a dataclass with various field declarations, illustrating both valid and invalid patterns that the rule is designed to catch or ignore.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/ruff/RUF046_LF.py",
            "description": "This is a test fixture for the RUF046 linting rule in the ruff linter. It specifically tests how the linter handles line breaks within an integer expression.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/ruff/RUF059_1.py",
            "description": "This file contains test cases for the RUF059 linter rule, demonstrating various scenarios of unpacking assignments, particularly focusing on unnecessary unpacking that triggers the rule.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/ruff/RUF018.py",
            "description": "This file contains test cases for the RUF018 linting rule, demonstrating valid and invalid uses of the walrus operator within assert statements.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/ruff/RUF043.py",
            "description": "This file serves as a test fixture for the RUF043 rule in Ruff, specifically testing its detection and handling of unescaped regular expression metacharacters within `pytest.raises` `match` arguments. It includes cases designed to produce errors, acceptable false positives, and scenarios where no errors should be reported, covering various metacharacters and escape sequences.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/ruff/RUF030.py",
            "description": "This file provides test cases for the RUF030 linter rule, which targets `print()` calls used as the error message in `assert` statements. It covers various argument combinations within `print()` to test the rule's detection and transformation capabilities.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/ruff/RUF066_custom_property_decorator.py",
            "description": "This file is a test fixture for Ruff (a linter), demonstrating the detection of missing return statements in methods decorated with both custom properties and built-in `@property`.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/ruff/RUF008.py",
            "description": "This file serves as a test fixture for the RUF008 linter rule, demonstrating various scenarios involving mutable default arguments in dataclasses. It includes examples of correct and incorrect usage, handling of ClassVars, and deferred annotations.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/ruff/RUF059_2.py",
            "description": "This file serves as a test case for identifying and fixing RUF059 violations in `with` statements and assignment unpacking within the Ruff linter.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/ruff/RUF039.py",
            "description": "This file is a test fixture for the RUF039 linting rule in Ruff, demonstrating various problematic and valid regular expression patterns using the `re` and `regex` modules.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/ruff/RUF049.py",
            "description": "This file serves as a test fixture for a linter rule (RUF049), demonstrating incorrect usage of the `@dataclass` decorator with various Enum types and contrasting it with the correct usage of `@attrs` decorators.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/ruff/RUF068.py",
            "description": "This file serves as a test fixture for the RUF068 linter rule, demonstrating various `__all__` declarations with and without duplicate entries to test the detection of redundant names.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/ruff/RUF061_warns.py",
            "description": "This file contains pytest test cases demonstrating how `pytest.warns` is used to catch `UserWarning`s, serving as a fixture for testing linter rule RUF061 related to warning handling.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/ruff/RUF028.py",
            "description": "This file serves as a test fixture for the Ruff linter, demonstrating the expected behavior and parsing of `fmt: off` and `fmt: skip` comments across various Python syntax constructs like lists, decorators, control flow statements, and function/method definitions.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/ruff/RUF048.py",
            "description": "This file is a test fixture for the `RUF048` linter rule, showcasing different ways to split a version string using `str.split()` with various arguments and then converting the parts to integers within `tuple` or `list`.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/ruff/RUF048_1.py",
            "description": "Tests various ways of splitting and parsing version strings from `__version__` attributes, including different separators and argument styles for `split`.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/ruff/RUF039_concat.py",
            "description": "This file serves as a test fixture for the Ruff linter, demonstrating various forms of implicit and explicit string concatenations used as patterns in regular expression functions from both the `re` and `regex` modules.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/ruff/RUF012.py",
            "description": "This file serves as a test fixture for the RUF012 linter rule, demonstrating various class field definitions including mutable defaults across different class types and frameworks like dataclasses, Pydantic, msgspec, SQLModel, and ctypes, to test the linter's behavior.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/ruff/RUF063.py",
            "description": "This file serves as a test fixture for the RUF063 linter rule in Ruff. It provides examples of code that should and should not trigger the RUF063 violation, which targets direct access to `__annotations__` via `__dict__.get` or `__dict__`.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/ruff/RUF047_while.py",
            "description": "Test fixtures for the RUF047 linter rule, demonstrating various valid `while...else` loop structures that should not trigger any errors.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/ruff/RUF058_2.py",
            "description": "This file serves as a test fixture for the RUF058_2 linter rule, demonstrating cases where using 'strict' as a keyword argument in 'zip' within a 'starmap' call will raise errors in Python 3.14+ versus cases that are considered valid.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/ruff/RUF047_for.py",
            "description": "This file provides test cases for the RUF047 linter rule, demonstrating correct and incorrect comment placements within or around `for-else` statements. It distinguishes between scenarios that should raise an error and those that should not.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/ruff/RUF059_0.py",
            "description": "This file contains a collection of Python code snippets designed as test fixtures for the RUF059 linter rule within the ruff linter, demonstrating various syntax and variable usage patterns.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/ruff/RUF059_3.py",
            "description": "This file serves as a test fixture for the `ruff_linter` rule RUF059, specifically to validate a fix for issue #8441 related to tuple unpacking and variable assignment.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/ruff/RUF057.py",
            "description": "This file contains test cases for the RUF057 linting rule, specifically demonstrating various scenarios and expected linter behavior for the `round()` function, particularly concerning its `ndigits` argument.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/ruff/RUF008_deferred.py",
            "description": "This test fixture demonstrates how the Ruff linter, specifically rule RUF008, handles `ClassVar` usage within a dataclass when `__future__.annotations` are enabled and `ClassVar` is conditionally imported for type checking.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/ruff/RUF051.py",
            "description": "This file serves as a test fixture for the Ruff linter rule RUF051, demonstrating various patterns of `if key in dict: del dict[key]` that are considered errors or safely fixable. It covers different literal types for dictionary keys and scenarios where the pattern does not trigger an error.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/ruff/RUF055_0.py",
            "description": "This file serves as a test fixture for a linter rule (RUF055) that identifies instances of `re` module calls which can be replaced by simpler string methods. It includes examples of `re.sub`, `re.match`, `re.search`, `re.fullmatch`, and `re.split` where replacements are both recommended and intentionally avoided based on regex complexity or usage context.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/ruff/RUF060.py",
            "description": "This file serves as a test fixture for the RUF060 linting rule in Ruff. It demonstrates `in` and `not in` membership checks against various empty and non-empty literals and collections, categorizing them into expected errors and valid code.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/ruff/confusables.py",
            "description": "This file serves as a test fixture for the Ruff linter, demonstrating various cases of ambiguous or confusible Unicode characters in strings, f-strings, comments, docstrings, and class attributes. It includes examples for character normalization and detection of problematic unicode symbols.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/ruff/RUF055_3.py",
            "description": "This file is a test fixture for the RUF055 linter rule, demonstrating cases where simple `re` module calls with byte strings can be replaced by more efficient `bytes` methods, and cases where `re` is necessary due to metacharacters.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/ruff/RUF056.py",
            "description": "This file serves as a test fixture for the RUF056 linting rule in Ruff, demonstrating both correct and incorrect usages of `dict.get()` with falsy default values in boolean contexts.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/ruff/RUF046_CR.py",
            "description": "This file is a test fixture for the Ruff linter, specifically designed to test the handling of carriage return characters (`\\r`) when used as newlines, likely in relation to rule RUF046.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/ruff/RUF055_2.py",
            "description": "This file contains test cases for a linter rule (likely RUF055) that identifies inefficient or verbose uses of `re.search`, `re.match`, and `re.fullmatch` compared with `None`. It demonstrates scenarios where these can be replaced with more Pythonic string operations or direct comparisons, including considerations for safe vs. unsafe automated fixes due to comments.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/ruff/RUF065_0.py",
            "description": "This file contains test cases for a linter rule (RUF065) that identifies potentially incorrect or redundant usage of `str()`, `repr()`, `ascii()`, `oct()`, and `hex()` with logging format strings (`%s`, `%r`). It covers various logging function calls and import styles.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/ruff/RUF064.py",
            "description": "This file contains test cases for a linter rule (RUF064) that checks for the correct usage of octal literals when specifying file permissions in `os` and `Path` functions. It demonstrates both valid (octal) and invalid (decimal, binary, hexadecimal) permission arguments.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/ruff/RUF100_4.py",
            "description": "This file is a test fixture for the Ruff linter, specifically designed to test the `RUF100` rule regarding unused `noqa` directives and the `F401` rule for unused imports.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/ruff/RUF066.py",
            "description": "This file serves as a test fixture for the RUF066 linter rule, demonstrating various scenarios for property return behavior, including missing returns, stubs, abstract methods, yield statements, and raise statements.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/ruff/RUF058_0.py",
            "description": "This file serves as a test fixture for a linter rule (RUF058) that identifies potentially incorrect or inefficient uses of `itertools.starmap` with `zip`, specifically when `zip` is called with zero arguments or only keyword arguments, which would lead to an empty iterable. It includes examples that should trigger the linter and examples that should not.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/ruff/RUF052_0.py",
            "description": "This file serves as a test fixture for the Ruff linter's RUF052 rule, showcasing correct and incorrect usages of private-like variables (prefixed with an underscore) to detect unnecessary underscores or shadowing issues.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/ruff/RUF065_1.py",
            "description": "This file provides test cases for the RUF065 linter rule, specifically examining how `str()`, `oct()`, and `hex()` functions are used within `logging.warning` format strings to determine which calls should or should not trigger a flag.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/ruff/RUF069.py",
            "description": "This file serves as a test fixture for the RUF069 linter rule, demonstrating various scenarios involving floating-point comparisons that should either trigger or be ignored by the linter.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/ruff/RUF067/modules/okay.py",
            "description": "This file serves as a test fixture for the RUF067 linting rule, demonstrating valid and invalid assignments to special module variables (like `__all__`, `__path__`) and definitions of special functions, specifically in a context where the linting rule should generally not apply because it's not an `__init__.py` file.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/ruff/RUF067/modules/__init__.py",
            "description": "This file serves as a test fixture for the RUF067 linter rule, demonstrating various valid and invalid patterns for special module-level attributes like `__all__`, `__path__`, `__getattr__`, and others within a Python package's `__init__.py`.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_no_pep420/test_pass_pep723/script.py",
            "description": "This script fetches a list of Python Enhancement Proposals (PEPs) from `peps.python.org`, extracts their titles, and pretty-prints the first ten. It also demonstrates PEP 723 script metadata for specifying Python requirements and dependencies.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_no_pep420/test_fail_nonempty/example.py",
            "description": "This file is a test fixture for `ruff`'s `flake8_no_pep420` rule, demonstrating a non-empty Python file that should fail the check if it's not an `__init__.py` in a namespace package context.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_no_pep420/test_pass_script",
            "description": "This directory serves as a test fixture for the `flake8_no_pep420` rule within the `ruff_linter` crate. It specifically holds code samples that are expected to pass this lint check, validating its correct behavior when no violations are present.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_no_pep420/test_pass_shebang/example.py",
            "description": "This file is a test fixture for the Ruff linter, specifically for the `flake8_no_pep420` rule. It demonstrates a Python file with a shebang that is expected to pass linter checks without issues related to PEP 420.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_no_pep420/test_ignored/example.py",
            "description": "This file is a test fixture for Ruff's implementation of `flake8-no-pep420` rules, specifically demonstrating a case where the INP001 rule is explicitly ignored.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_no_pep420/test_pass_namespace_package",
            "description": "This directory contains a test fixture designed to pass the `flake8_no_pep420` linting rule when applied to a valid Python namespace package. It serves to verify that the linter correctly handles and does not flag errors in such package structures.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_no_pep420/test_fail_empty",
            "description": "This directory contains a test fixture for the `flake8_no_pep420` linter rule. It includes an `example.py` file designed to demonstrate a failing scenario, verifying that the linter correctly identifies and reports violations related to PEP 420 namespace packages when the file is empty.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_no_pep420/test_pass_init",
            "description": "This directory contains a test fixture for the `ruff_linter` crate, specifically designed to test the `flake8_no_pep420` rule. It represents a valid Python package structure with an `__init__.py` file, serving as a 'passing' case to ensure the linter correctly identifies no issues. The presence of `__init__.py` and `example.py` simulates a standard Python module.",
            "spof": false
          }
        ],
        "contributors": [
          {
            "name": "Brent Westbrook",
            "percent": 18
          },
          {
            "name": "chiri",
            "percent": 11
          },
          {
            "name": "Dylan",
            "percent": 8
          }
        ]
      },
      "Typing and Docstring Rule Implementations": {
        "files": [
          {
            "path": "crates/ty_python_semantic/resources/mdtest/declaration/error.md",
            "description": "This markdown file provides examples of Python type declaration errors, illustrating various scenarios where declared types conflict with inferred types or other declarations. It demonstrates error types such as `invalid-declaration` and `conflicting-declarations`, alongside cases that currently do not raise errors.",
            "spof": true
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/88_regression_issue_17792.py",
            "description": "A regression test for Ruff issue #17792, verifying how the linter handles type mismatches in function calls.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/checkers/ast/analyze/definitions.rs",
            "description": "This file contains the core logic for running various lint rules over `Definition` nodes (functions, classes, methods) within the AST, particularly focusing on type annotations, docstrings, and dunder methods. It applies checks from multiple rule categories like flake8-annotations, flake8-pyi, pydoclint, pydocstyle, and pylint based on enabled rules.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/docstrings/google.rs",
            "description": "This file defines the recognized section types for Google-style docstrings, used by the ruff linter. It provides an abstraction for parsing and validating docstrings written in the Google format.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/src/docstrings/numpy.rs",
            "description": "This file defines the recognized section kinds for NumPy-style docstrings, providing abstractions for parsing and validating them within the ruff linter.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/src/docstrings/sections.rs",
            "description": "This file defines an enum for various docstring section kinds (e.g., Args, Returns) and provides functionality to parse and extract these sections from Python docstrings, including their types, names, and ranges.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/docstrings/extraction.rs",
            "description": "This file provides utilities for extracting docstrings from Python AST nodes and for classifying AST definitions (functions, classes) within the semantic model for a linter.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/src/docstrings/styles.rs",
            "description": "This file defines an enumeration `SectionStyle` to represent different docstring styles (Numpy, Google) and provides a method to retrieve the predefined sections associated with each style.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/src/docstrings/mod.rs",
            "description": "This module defines core structures for representing and interacting with Python docstrings, providing methods to access their content, style, and various components. It serves as the main entry point for docstring-related functionality within the linter.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_annotations/settings.rs",
            "description": "This file defines the `Settings` struct and its display implementation for the `flake8_annotations` plugin, including various boolean flags to configure its behavior.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_annotations/helpers.rs",
            "description": "This file provides helper functions for inferring Python function return types and converting these inferred types into AST expressions, handling necessary imports and Python version-specific syntax (e.g., PEP 604 unions). It also includes utilities for identifying overloaded functions.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_annotations/mod.rs",
            "description": "This file serves as the main module for the `flake8_annotations` rule set within the `ruff_linter` crate. It defines the module structure for helpers, rules, and settings, and includes extensive integration tests for the `flake8-annotations` rules.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_annotations/snapshots",
            "description": "This directory is intended to store snapshot files for testing the `flake8_annotations` rule within the `ruff_linter` crate. These snapshots capture expected outputs or AST structures, enabling efficient regression testing for this specific linting rule.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_annotations/rules/mod.rs",
            "description": "This module acts as a public interface for the `definition` module within the `flake8_annotations` rules, re-exporting its contents.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_annotations/rules/definition.rs",
            "description": "This file defines various linting rules and their associated metadata for missing type annotations in Python function arguments and return types, as part of the `flake8_annotations` plugin in Ruff. It includes definitions for specific violations like missing argument types, missing `*args`/`**kwargs` types, and missing return types for public and private functions.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_type_checking/settings.rs",
            "description": "This file defines the configuration settings for the `flake8-type-checking` rule within the Ruff linter, including options for strictness, module exemptions, and runtime requirements.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_type_checking/imports.rs",
            "description": "This file defines the `ImportBinding` struct, which encapsulates all relevant information about a single imported symbol within a Python file, including its name, binding, ranges, and other contextual details, for use in static analysis.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_type_checking/mod.rs",
            "description": "This module integrates the `flake8-type-checking` rules into the Ruff linter. It orchestrates sub-modules for rules, settings, and helpers, and contains extensive unit tests for these type-checking related rules.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_type_checking/helpers.rs",
            "description": "This file provides helper functions and an enum (`TypingReference`) to classify Python type annotations and other constructs as either runtime-required or typing-only. It assists in determining the appropriate handling of imports, decorators, and special annotations for linting type-checking rules.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_type_checking/rules/runtime_cast_value.rs",
            "description": "This file implements the `flake8-type-checking` rule `TC006`, which checks for and fixes unquoted type expressions used in `typing.cast()` calls to ensure stylistic consistency and avoid potential runtime overhead.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_type_checking/rules/runtime_import_in_type_checking_block.rs",
            "description": "This file implements a Ruff linter rule (TC004) that identifies and flags imports defined in `TYPE_CHECKING` blocks but used at runtime. It provides fixes to either move the import out of the block or quote its runtime usages.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_type_checking/rules/empty_type_checking_block.rs",
            "description": "Implements a lint rule (TC005) for Ruff that detects and fixes empty `if TYPE_CHECKING:` blocks in Python code, which typically contain only a `pass` statement.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_type_checking/rules/mod.rs",
            "description": "This file acts as the main module (`mod.rs`) for the `flake8_type_checking` rules within the `ruff` linter, re-exporting individual rule implementations for use elsewhere in the crate.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_type_checking/rules/runtime_string_union.rs",
            "description": "This file implements a linter rule (TC010) that identifies and flags string literals used as members in Python's `X | Y` union type syntax, as this can cause runtime errors. It provides suggestions for correcting such type annotations.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_type_checking/rules/type_alias_quotes.rs",
            "description": "This file implements Ruff rules (TC007 and TC008) for checking and fixing the quoting of type aliases, ensuring that runtime-unavailable types are quoted and unnecessary quotes are removed.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_type_checking/rules/typing_only_runtime_import.rs",
            "description": "This file defines linter rules (TC001, TC002, TC003) for identifying and suggesting the relocation of Python imports used exclusively for type annotations into `if TYPE_CHECKING:` blocks. This optimizes runtime performance and prevents import cycles by ensuring type-only dependencies are not loaded at runtime.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_type_checking/snapshots",
            "description": "This directory stores test snapshots specifically for the `flake8_type_checking` rules within the `ruff_linter` crate. These snapshots are used to verify the expected behavior and output of the linter rules during development and testing.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_pyi/mod.rs",
            "description": "This file defines and tests the rules implemented from the `flake8-pyi` linter within the `ruff_linter` project. It acts as the main module for the `flake8-pyi` rule set, including its test suite.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_pyi/rules/custom_type_var_for_self.rs",
            "description": "This file implements a Ruff linting rule (PYI019) that flags Python methods using custom TypeVars in their `self` or `cls` annotations when the `typing.Self` type could be used instead. It includes logic to identify such cases and provides a fix to replace the TypeVar with `Self`.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_pyi/rules/collections_named_tuple.rs",
            "description": "This file implements a linter rule (PYI024) that detects the use of `collections.namedtuple` in Python stub files and suggests replacing it with `typing.NamedTuple` for better type checking.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_pyi/rules/ellipsis_in_non_empty_class_body.rs",
            "description": "This file defines a linting rule (PYI013) that identifies and removes unnecessary ellipses (`...`) from non-empty class bodies in Python type stub files, providing a fix for such violations.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_pyi/rules/complex_assignment_in_stub.rs",
            "description": "This file defines a linting rule (PYI017) for Ruff that flags complex assignments in Python stub files. It checks for assignments with multiple targets or non-name targets, which are generally discouraged in stub files.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_pyi/rules/duplicate_union_member.rs",
            "description": "This file implements a linter rule (`PYI016`) that detects and fixes duplicate members within Python type unions (e.g., `str | str` or `typing.Union[str, str]`), simplifying them to a single unique type (e.g., `str`). It handles both PEP 604 style unions and `typing.Union`.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_pyi/rules/no_return_argument_annotation.rs",
            "description": "Implements a lint rule that checks for the use of `typing.NoReturn` in function parameter annotations and suggests `typing.Never` instead, for stylistic reasons.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_pyi/rules/bytestring_usage.rs",
            "description": "Implements a lint rule (PYI057) that detects and flags the use of `typing.ByteString` or `collections.abc.ByteString`, which are deprecated and have unclear semantics. It provides diagnostics for both attribute access and imports of these types.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_pyi/rules/iter_method_return_iterable.rs",
            "description": "Implements a linter rule (PYI045) for Python stub files that flags `__iter__` or `__aiter__` methods returning a generic `Iterable` or `AsyncIterable` instead of a more specific `Iterator` or `AsyncIterator` type, respectively. This ensures type checker compatibility and adherence to Python's iteration protocol expectations.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_pyi/rules/pass_in_class_body.rs",
            "description": "Implements a Ruff lint rule (`PYI012`) that identifies and removes unnecessary `pass` statements within non-empty class bodies in Python stub files (`.pyi`).",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_pyi/rules/quoted_annotation_in_stub.rs",
            "description": "This file defines a linter rule for `flake8_pyi` that identifies and automatically fixes quoted type annotations in Python stub (`.pyi`) files. It flags these as unnecessary because stub files natively support forward references without quotes.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_pyi/rules/bad_version_info_comparison.rs",
            "description": "This file defines and implements linting rules for Python's `sys.version_info` comparisons. It flags incorrect comparison operators and enforces a specific order for version-dependent code branches.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_pyi/rules/complex_if_statement_in_stub.rs",
            "description": "Implements a lint rule (PYI002) for Ruff that detects and flags complex `if` statement conditions in Python stub files, recommending simpler comparisons against `sys.platform` or `sys.version_info`.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_pyi/rules/future_annotations_in_stub.rs",
            "description": "This file implements a Ruff linter rule (PYI044) that identifies and provides a fix for redundant `from __future__ import annotations` imports within Python stub (`.pyi`) files.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_pyi/rules/numeric_literal_too_long.rs",
            "description": "This file implements a linting rule (PYI054) for Python stub files (`.pyi`) that flags and automatically fixes numeric literals exceeding ten characters in length, replacing them with ellipses (`...`).",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_pyi/rules/prefix_type_params.rs",
            "description": "Implements Ruff's `PYI001` linting rule, which enforces that `TypeVar`, `ParamSpec`, and `TypeVarTuple` names in Python stub files (`.pyi`) must be prefixed with an underscore.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_pyi/rules/pre_pep570_positional_argument.rs",
            "description": "Implements a linting rule (`PYI063`) that detects and flags Python function parameters using the deprecated PEP 484-style `__name` convention for positional-only arguments, recommending the modern PEP 570 `/` syntax instead. This rule applies to Python 3.8 and newer.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_pyi/rules/simple_defaults.rs",
            "description": "This file defines several linting rules for Python stub files (`.pyi`) related to default values, assignments, and type alias annotations. It checks for issues like complex default values in function arguments and assignments, unannotated assignments, and unassigned special variables.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_pyi/rules/duplicate_literal_member.rs",
            "description": "This file implements a linter rule (PYI062) for Ruff that detects and fixes duplicate members within `typing.Literal` annotations in Python code. It provides a mechanism to report these duplicates as violations and automatically remove them.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_pyi/rules/non_empty_stub_body.rs",
            "description": "This file implements a lint rule (`PYI010`) for Ruff that enforces minimalist function bodies in Python stub (`.pyi`) files. It flags non-empty function bodies, excluding `pass` statements or docstrings, that are not simply an ellipsis (`...`).",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_pyi/rules/unnecessary_literal_union.rs",
            "description": "This file defines a `ruff` rule (PYI030) that identifies and fixes `Union` annotations containing multiple `Literal` types by merging them into a single `Literal` for improved conciseness and clarity.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_pyi/rules/type_comment_in_stub.rs",
            "description": "Implements a linting rule for `flake8_pyi` that detects and flags the use of `type:` comments (excluding `type: ignore`) in Python stub (`.pyi`) files.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_pyi/rules/mod.rs",
            "description": "This module serves as the central entry point for the `flake8-pyi` linter rules, re-exporting individual rule implementations and providing shared utility functions for generating fixes related to typing annotations.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_pyi/rules/redundant_final_literal.rs",
            "description": "Implements a linting rule (PYI064) that identifies and fixes redundant `Final[Literal[...]]` type annotations in Python code by simplifying them to `Final`.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_pyi/rules/exit_annotations.rs",
            "description": "This file implements a Ruff linting rule (`PYI036`) that checks for incorrect type annotations on `__exit__` and `__aexit__` methods, ensuring they conform to proper Python type stub conventions.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_pyi/rules/redundant_numeric_union.rs",
            "description": "Implements a lint rule that identifies and fixes redundant unions of Python's numeric types (e.g., `int | float`) in type annotations, simplifying them based on Python's numeric tower rules. It supports both `typing.Union` and PEP 604 union syntax.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_pyi/rules/any_eq_ne_annotation.rs",
            "description": "Implements a linter rule (PYI032) for Ruff that checks for and fixes `__eq__` and `__ne__` methods using `typing.Any` instead of `object` for their second parameter in type annotations.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_pyi/rules/unaliased_collections_abc_set_import.rs",
            "description": "This file implements a lint rule (PYI025) that flags `from collections.abc import Set` imports which are not aliased to `AbstractSet`, aiming to prevent confusion with the built-in `set` type. It provides an automatic fix, with carefully determined applicability based on file type and scope to ensure safety.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_pyi/rules/unsupported_method_call_on_all.rs",
            "description": "Implements a Ruff linter rule that flags unsupported method calls (like `append`, `extend`, `remove`) on Python's `__all__` variable in type stub files, recommending the use of `+=` instead.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_pyi/rules/redundant_none_literal.rs",
            "description": "This file implements a lint rule that identifies and fixes redundant `Literal[None]` type annotations in Python code. It suggests replacing them with `None`, `Optional[Literal[...]]`, or `Literal[...] | None` depending on the context and Python version.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_pyi/rules/unnecessary_type_union.rs",
            "description": "This file implements a linting rule (PYI055) that detects and fixes redundant `type` annotations within Python type unions, suggesting a more concise `type[A | B]` form instead of `type[A] | type[B]`.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_pyi/rules/pass_statement_stub_body.rs",
            "description": "This file defines a `ruff` linter rule (PYI009) that identifies and automatically fixes `pass` statements in empty stub file bodies, replacing them with `...` for stylistic consistency.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_pyi/rules/docstring_in_stubs.rs",
            "description": "Implements a linting rule to detect and remove docstrings from Python stub (`.pyi`) files, as they are considered unnecessary for type hints.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_pyi/rules/str_or_repr_defined_in_stub.rs",
            "description": "Implements a linter rule (PYI029) for Ruff that detects and offers to remove redundant `__str__` or `__repr__` method definitions in Python type stub (`.pyi`) files, as their signatures often match the default object methods.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_pyi/rules/unrecognized_version_info.rs",
            "description": "This file implements linting rules for Python stub files, specifically checking for correct and recognized usage of `sys.version_info` in version comparisons to ensure compatibility with type checkers.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_pyi/rules/unused_private_type_definition.rs",
            "description": "This file implements various linter rules for Ruff, specifically identifying and reporting unused private type definitions (like TypeVars, Protocols, TypeAliases, and TypedDicts) in Python code. It defines the violation structures and the logic to detect these unused declarations.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_pyi/rules/non_self_return_type.rs",
            "description": "Implements a Ruff Linter rule (PYI034) that checks for and fixes method return type annotations that should use `Self` instead of a fixed class name. This rule helps ensure correct type inference for methods in subclasses, particularly for dunder methods like `__new__`, `__enter__`, and in-place binary operators.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_pyi/rules/type_alias_naming.rs",
            "description": "Implements two linting rules (PYI042 and PYI043) for `flake8-pyi` to enforce Python type alias naming conventions, specifically checking for CamelCase for public aliases and preventing 'T' suffixes for private aliases.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_pyi/rules/redundant_literal_union.rs",
            "description": "Implements a Ruff linter rule (PYI051) that identifies redundant type unions where a `Literal` type is combined with its builtin supertype (e.g., `Literal[1] | int`). The rule aims to improve type annotation clarity and conciseness.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_pyi/rules/unrecognized_platform.rs",
            "description": "This file defines and implements linting rules for Python type stub (`.pyi`) files, specifically to ensure `sys.platform` checks use simple string comparisons and recognized platform names. It prevents complex expressions or misspelled platform identifiers in `sys.platform` checks for improved type checker compatibility.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_pyi/rules/stub_body_multiple_statements.rs",
            "description": "This file defines a linting rule (PYI048) for Ruff, which checks Python stub (`.pyi`) files to ensure that function bodies contain exactly one statement, preventing functional code in type hint files.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_pyi/rules/string_or_bytes_too_long.rs",
            "description": "This file implements a linting rule (PYI053) that flags string and bytes literals longer than 50 characters within Python stub (`.pyi`) files, suggesting replacement with ellipses for brevity in type hints. It includes logic to count characters in various string types and provides an automatic fix.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_pyi/snapshots",
            "description": "This directory is designated to store test snapshots for the `flake8_pyi` rules within the `ruff_linter` crate. These snapshots are used for regression testing, ensuring consistent behavior and output of the linter rules. They serve as a reference point to detect unintended changes in rule application or reported diagnostics.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_future_annotations/mod.rs",
            "description": "This file defines the module structure for `flake8-future-annotations` rules and contains unit tests for `FutureRewritableTypeAnnotation` (FA100) and `FutureRequiredTypeAnnotation` (FA102) within the Ruff linter.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_future_annotations/rules/future_rewritable_type_annotation.rs",
            "description": "This file implements a Ruff rule (FA100) that checks for type annotations which could be simplified by adding `from __future__ import annotations`, enabling PEP 563/585/604 syntax. It detects cases where the future import would allow for more succinct type hints like `list[str]` or `str | None`.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_future_annotations/rules/future_required_type_annotation.rs",
            "description": "This file defines a Ruff lint rule (FA102) that detects the use of modern type annotations (PEP 585/604) without the required `from __future__ import annotations` import, ensuring compatibility with older Python versions.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_future_annotations/rules/mod.rs",
            "description": "This file acts as the module entry point for `flake8_future_annotations` rules, re-exporting the `future_required_type_annotation` and `future_rewritable_type_annotation` rule implementations.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_future_annotations/snapshots",
            "description": "This directory stores snapshot test files specifically for the `flake8_future_annotations` rule within the `ruff_linter` crate. These snapshots capture expected outputs or internal representations used to ensure consistent behavior of the linter rule over time.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pycodestyle/rules/doc_line_too_long.rs",
            "description": "Implements a linter rule (W505) that checks for and reports docstrings or standalone comment lines exceeding a configurable maximum character length, with specific exceptions for URLs, pragmas, and task comments.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pydoclint/mod.rs",
            "description": "This file is the main module for the `pydoclint` rule set within the Ruff linter, importing its rules and settings submodules and containing comprehensive unit tests for these rules across different docstring styles.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pydoclint/rules/mod.rs",
            "description": "This file serves as the module entry point for the `pydoclint` rules, re-exporting all items from the `check_docstring` submodule.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/src/rules/pydoclint/rules/check_docstring.rs",
            "description": "This file defines and implements various linter rules for `pydoclint` within Ruff, focusing on validating the content and structure of Python docstrings, such as checking for extraneous parameters, missing or superfluous return/yield sections, and undocumented exceptions.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pydoclint/snapshots",
            "description": "This directory stores snapshot test files for the `pydoclint` rule within the `ruff_linter` crate. These snapshots are used to verify the correct behavior and output of the pydoclint linter rule during testing.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pylint/rules/type_name_incorrect_variance.rs",
            "description": "This Rust file implements a Pylint rule (`PLC0105`) for Ruff, which detects when Python `TypeVar` or `ParamSpec` names do not correctly reflect their declared variance (e.g., `_co` for covariant, `_contra` for contravariant). It suggests renaming them for consistency with PEP 484 guidelines.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pylint/rules/type_bivariance.rs",
            "description": "This file implements a Pylint rule (`PLC0131`) in Ruff that detects and reports `TypeVar` or `ParamSpec` definitions in Python that are incorrectly marked as both covariant and contravariant.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pylint/rules/type_param_name_mismatch.rs",
            "description": "This file implements a Pylint rule (PLC0132) that detects instances where the declared name of a type parameter (e.g., `TypeVar`, `ParamSpec`) does not match the name of the variable it's assigned to, as per PEP 484.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/ruff/typing.rs",
            "description": "This file defines utilities for analyzing and interpreting Python type annotations within the Ruff linter. It parses various typing constructs (e.g., Union, Optional, Literal) and determines properties such as whether a type can resolve to `None` or `Any`.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/ruff/rules/never_union.rs",
            "description": "This file implements a linting rule (RUF020) for Ruff that identifies and fixes redundant uses of `typing.Never` or `typing.NoReturn` within Python union types (`|` or `typing.Union`). It provides auto-fixes to remove these types as they do not change the resulting type in a union.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/ruff/rules/none_not_at_end_of_union.rs",
            "description": "Implements the RUF036 rule, which checks for Python type annotations where `None` is not positioned at the end of a union type for improved readability.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/ruff/rules/implicit_optional.rs",
            "description": "This file implements a lint rule (RUF013) that detects and suggests fixes for implicit `Optional` types in Python function parameter annotations. It ensures that parameters with a default value of `None` explicitly indicate `None` as a possible type, either via `Optional[T]` or `T | None`.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/ruff/rules/unnecessary_nested_literal.rs",
            "description": "This file implements a Ruff rule (`RUF041`) that identifies and fixes unnecessarily nested `Literal` type hints in Python, promoting a flattened and more concise representation. It provides a diagnostic and a fix to replace nested literals with a single, combined `Literal`.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/ruff/rules/redundant_bool_literal.rs",
            "description": "Implements a `ruff` linting rule (RUF038) that identifies and suggests replacing `Literal[True, False]` type annotations with `bool` (or `Literal[...] | bool` if other literals are present) for conciseness and readability. It also provides a fix, which is marked as unsafe due to potential semantic changes.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/src/rules/ruff/rules/class_with_mixed_type_vars.rs",
            "description": "This file implements a Ruff rule (RUF053) that detects and offers to fix Python classes which incorrectly combine PEP 695 type parameter lists with inheritance from `typing.Generic`, aiming to unify type variable declarations.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/src/rules/pydocstyle/mod.rs",
            "description": "This module defines and tests the implementation of pydocstyle rules for the Ruff linter. It includes various test cases for different pydocstyle rules against sample Python code.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pydocstyle/helpers.rs",
            "description": "This file provides helper functions for parsing and analyzing docstrings, including utilities for text manipulation, identifying logical lines, and determining docstring section styles (Google vs. NumPy) within the `pydocstyle` rule set.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pydocstyle/rules/not_empty.rs",
            "description": "This file implements the `D419` pydocstyle rule for the Ruff linter, which detects and reports empty docstrings in Python code. It defines the `EmptyDocstring` violation and the logic (`not_empty` function) to check if a docstring's body is empty.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pydocstyle/rules/ends_with_punctuation.rs",
            "description": "Implements a linter rule (D415) that checks if the first line of a Python docstring ends with a period, question mark, or exclamation point. It also provides a fix to add a period if missing, while handling specific exceptions for docstring formats and existing punctuation.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pydocstyle/rules/capitalized.rs",
            "description": "Implements the `pydocstyle` rule D403, which checks if the first word of a docstring is capitalized and provides a fix if it's not. It ensures grammatical correctness and consistency in docstrings.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pydocstyle/rules/newline_after_last_paragraph.rs",
            "description": "This file implements a lint rule (D209) that enforces PEP 257's recommendation for multi-line docstrings, ensuring their closing quotes are on a separate line. It includes a fix to automatically move the closing quotes to a new line when this violation is detected.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pydocstyle/rules/no_surrounding_whitespace.rs",
            "description": "This file implements a linter rule (D210) that detects and can fix docstrings containing leading or trailing whitespace. It ensures docstrings adhere to consistency guidelines by trimming unnecessary surrounding spaces.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pydocstyle/rules/blank_after_summary.rs",
            "description": "Implements a linter rule (D205) for `pydocstyle` to enforce a single blank line between the summary and description in Python docstrings, providing a fix for violations.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pydocstyle/rules/if_needed.rs",
            "description": "Implements a linter rule (D418) that checks for and reports docstrings in Python functions decorated with `@overload`, as these should not contain docstrings.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pydocstyle/rules/blank_before_after_class.rs",
            "description": "This file implements Pydocstyle linting rules (D203, D204, D211) that check for correct blank line placement before and after class docstrings in Python code. It defines diagnostics for incorrect blank line counts and provides auto-fixing capabilities.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pydocstyle/rules/mod.rs",
            "description": "This file serves as the `mod.rs` for the `pydocstyle` rules module, aggregating and re-exporting all individual pydocstyle rule implementations.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pydocstyle/rules/no_signature.rs",
            "description": "This file implements a Pydocstyle linter rule (D402) that detects and flags docstrings that incorrectly include a function's signature in their first line, as recommended by PEP 257.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pydocstyle/rules/backslashes.rs",
            "description": "Implements a linting rule (D301) for `ruff` that checks Python docstrings for backslashes, ensuring they are defined as raw string literals to prevent unintended escape sequence interpretations. It provides a fix to add the `r` prefix to such docstrings.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pydocstyle/rules/indent.rs",
            "description": "This file implements rules for detecting and fixing indentation issues within Python docstrings, including the use of tabs, under-indentation, and over-indentation, as part of the `pydocstyle` linting rules.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pydocstyle/rules/not_missing.rs",
            "description": "This file defines the rules and violations for detecting missing docstrings in public Python modules, classes, methods, and functions as part of the Ruff linter's pydocstyle checks.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pydocstyle/rules/ends_with_period.rs",
            "description": "Implements a linter rule (D400) to check if the first line of a Python docstring ends with a period, as recommended by PEP 257. It identifies and offers to fix missing trailing periods, while ignoring specific docstring sections to prevent false positives.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pydocstyle/rules/non_imperative_mood.rs",
            "description": "This file implements a linter rule (D401) that checks if the first line of a Python docstring is written in the imperative mood, as recommended by PEP 257. It reports a diagnostic if a docstring's first line is not imperative.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pydocstyle/rules/multi_line_summary_start.rs",
            "description": "This file implements Pydocstyle rules D212 and D213, which enforce conventions regarding whether a multi-line docstring's summary should start on the first or second line, and provides automatic fixes for these violations.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pydocstyle/rules/sections.rs",
            "description": "This file defines various linting rules for docstring sections within the `pydocstyle` plugin, primarily checking for proper indentation and capitalization of section headers and their underlines in different docstring conventions.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pydocstyle/rules/starts_with_this.rs",
            "description": "This file implements a Ruff linting rule (D404) that checks for Python docstrings starting with the word 'This', which violates PEP 257's recommendation for using the imperative mood.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pydocstyle/rules/one_liner.rs",
            "description": "This file defines a `ruff` linter rule (D200, UnnecessaryMultilineDocstring) that identifies Python docstrings containing only one line of content but formatted across multiple lines. It provides a fix to reformat such docstrings onto a single line.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pydocstyle/rules/blank_before_after_function.rs",
            "description": "This file implements `pydocstyle` rules D201 and D202, which check for and fix violations related to blank lines immediately before and after a function's docstring in Python code. It ensures docstrings are directly adjacent to their function definitions and subsequent code.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pydocstyle/rules/triple_quotes.rs",
            "description": "Implements a linter rule (D300) that checks for and fixes Python docstrings not using triple double quotes (`\"\"\"`), adhering to PEP 257 recommendations.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pydocstyle/snapshots",
            "description": "This directory stores snapshot test files specifically for the Pydocstyle linter rules within the `ruff_linter` crate. These snapshots are used to compare current rule outputs against expected baselines, ensuring consistent behavior and preventing regressions.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pyupgrade/rules/pep695/private_type_parameter.rs",
            "description": "Implements a Ruff lint rule (UP049, `private-type-parameter`) that flags PEP 695 type parameters with leading underscores in generic classes and functions, providing a fix to remove them unless doing so would cause shadowing or create an invalid identifier.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_annotations/allow_nested_overload.py",
            "description": "This file is a test fixture for `flake8_annotations`, demonstrating how the linter handles `typing.overload` decorator used for method overloading within a class.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_annotations/allow_overload.py",
            "description": "Tests how the `flake8_annotations` linter handles `typing.overload` declarations, including scenarios where statements are interleaved between overload signatures and the function implementation.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_annotations/suppress_dummy_args.py",
            "description": "This file serves as a test fixture for `flake8_annotations`, demonstrating valid usage of dummy arguments (prefixed with `_`) when the `suppress_dummy_args` configuration is enabled.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_annotations/shadowed_builtins.py",
            "description": "This file serves as a test fixture for the `flake8_annotations` linter, specifically demonstrating scenarios where built-in types like `str` are shadowed.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_annotations/simple_magic_methods.py",
            "description": "A test fixture for flake8-annotations, demonstrating the definition of various simple magic methods within a class. It likely verifies how the linter handles or ignores type annotation requirements for these methods.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_annotations/suppress_none_returning.py",
            "description": "This file contains test cases for the `flake8_annotations` linter (within Ruff), specifically demonstrating its behavior when `suppress_none_returning` is enabled. It includes examples of functions that implicitly or explicitly return `None` (expected to be OK) and those that return other values (expected to be errors).",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_annotations/allow_star_arg_any.py",
            "description": "This file serves as a test fixture for the `flake8-annotations` linter, specifically evaluating the ANN401 rule's detection of `Any` type annotations in function arguments, return types, and especially with star arguments (`*args`, `**kwargs`). It includes both passing (`OK`) and failing (`ANN401`) cases for different `Any` placements.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_annotations/auto_return_type.py",
            "description": "This file serves as a test fixture for `ruff_linter`'s `flake8_annotations` plugin, specifically demonstrating various function return type inference scenarios and edge cases in Python.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_annotations/annotation_presence.py",
            "description": "This file contains test cases for a linter, specifically demonstrating correct and incorrect usage of type annotations in function definitions, including the detection of `Any` type annotations (ANN401) and cases handled by the `@override` decorator.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_annotations/mypy_init_return.py",
            "description": "This file serves as a test fixture for the `ruff_linter`'s `flake8_annotations` rules. It specifically demonstrates expected error and valid cases for `__init__` method return type annotations when the `mypy_init_return` setting is enabled.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_annotations/ignore_fully_untyped.py",
            "description": "This file is a test fixture for a linter, specifically for `flake8_annotations` rules in Ruff, to verify its behavior when `ignore_fully_untyped = True`. It includes functions and methods with various levels of type hints (fully untyped, partially typed, fully typed) to check expected linting outcomes.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_future_annotations/ok_quoted_type.py",
            "description": "This file serves as a test fixture for the `flake8_future_annotations` linter, demonstrating correct usage of quoted type annotations that should not trigger any warnings.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_future_annotations/import_typing_as.py",
            "description": "This file is a test fixture for `flake8-future-annotations`, demonstrating type annotations using an aliased `typing` module (e.g., `import typing as t`). It shows a basic function with a list type hint.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_future_annotations/import_typing.py",
            "description": "Illustrates the use of `typing.List` for type hinting in Python, likely serving as a test case for linters examining type annotation practices without future imports.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_future_annotations/from_typing_import_many.py",
            "description": "This file is a test fixture for `flake8_future_annotations`. It demonstrates various complex type hints and `cast` usage, importing multiple types from the `typing` module.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_future_annotations/ok_uses_future.py",
            "description": "This file is a test fixture for Ruff's `flake8_future_annotations` linter, demonstrating correct usage of `from __future__ import annotations` with type hints.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_future_annotations/from_typing_import.py",
            "description": "This test fixture demonstrates the use of `typing.List` for type annotations. It likely tests how the linter handles such annotations when `from __future__ import annotations` is not present.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_future_annotations/edge_case.py",
            "description": "This file is a test fixture for the `ruff` linter, specifically designed to test edge cases related to `flake8_future_annotations` and the handling of type hints from the `typing` module.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_future_annotations/ok_no_types.py",
            "description": "This file is a positive test fixture for the `ruff_linter`, specifically for the `flake8_future_annotations` rule. It provides a simple Python function without type annotations or `from __future__ import annotations`, indicating it should pass without issues related to future annotations.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_future_annotations/ok_non_simplifiable_types.py",
            "description": "This file is a test fixture for the `flake8-future-annotations` linter, demonstrating type annotations that are already simplified (using built-in types) and thus do not benefit from future annotations. It defines a `NamedTuple` with a simple `int` annotation and a `main` function.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_future_annotations/ok_variable_name.py",
            "description": "This file serves as a positive test fixture for the `flake8_future_annotations` linter rule in Ruff. It verifies that the linter correctly handles a variable named `List` and an unused assignment to `IRRELEVANT` from `typing.TypeVar` without raising false positives related to future annotations.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_future_annotations/no_future_import_uses_union.py",
            "description": "This test fixture demonstrates code using PEP 604 union types (e.g., `list[str] | None`) without importing `from __future__ import annotations`. It is used to test linting rules related to future annotations when such union types are present.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_future_annotations/no_future_import_uses_union_inner.py",
            "description": "This file is a test fixture for the `flake8_future_annotations` linter, demonstrating the use of modern union type syntax (`str | None`) within generic type parameters without a `from __future__ import annotations` import. It tests linting behavior for `list`, `dict`, and `tuple` types.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_future_annotations/no_future_import_uses_lowercase.py",
            "description": "This file is a test fixture for the Ruff linter, demonstrating the use of PEP 585 style type hints (e.g., `list[str]`) without a `from __future__ import annotations` import. It likely verifies the linter's behavior with built-in generic types in Python 3.9+.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_quotes/docstring_doubles_class.py",
            "description": "This file is a test fixture for the `flake8_quotes` linter, demonstrating the use of single-line double-quoted docstrings in classes and methods, including cases that should and should not be considered docstrings.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_quotes/docstring_doubles.py",
            "description": "This file is a test fixture for a linter, showcasing the identification of double-quoted multiline docstrings for modules, classes, and functions, distinguishing them from other triple-quoted string literals.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_quotes/docstring_singles_module_singleline.py",
            "description": "This file is a test fixture for the `flake8_quotes` linter, demonstrating a single-line module docstring using single quotes. It includes other multi-line strings that are not docstrings to test linter behavior.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_quotes/docstring_doubles_mixed_quotes_class_var_2.py",
            "description": "This file is a test fixture for the `flake8-quotes` linter. It specifically examines the handling of mixed-quote single-line docstrings within class definitions, methods, and nested classes.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_quotes/docstring_singles_class.py",
            "description": "This file is a test fixture for the `flake8_quotes` linter. It contains examples of single-line class and method docstrings, as well as regular string literals, to test quote style enforcement within a class.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_quotes/docstring_doubles_function.py",
            "description": "This file contains Python function definitions illustrating various docstring scenarios, including valid single-line and multi-line docstrings, and misplaced string literals that are not considered docstrings. It likely serves as a test fixture for linting tools to verify docstring and string literal detection.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_quotes/docstring_singles_mixed_quotes_class_var_1.py",
            "description": "This file is a test fixture for the `flake8_quotes` linter. It demonstrates string concatenations with mixed single and double quotes, checking how the linter distinguishes actual docstrings from other string literals in such cases.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_quotes/docstring_singles_mixed_quotes_class_var_2.py",
            "description": "This file serves as a test fixture for the 'flake8_quotes' linter, specifically demonstrating how it handles concatenated strings that resemble docstrings in various contexts, including classes, methods, and nested class definitions.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_pyi/PYI001.py",
            "description": "This file serves as a test fixture for the PYI001 rule, demonstrating various valid declarations of TypeVar, TypeVarTuple, and ParamSpec, both globally and within a function.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_pyi/PYI007.py",
            "description": "This file contains valid test cases for the PYI007 flake8-pyi linter rule, demonstrating correct usage of `sys.platform` comparisons.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_pyi/PYI032.py",
            "description": "This file contains test cases for the `flake8_pyi` rule PYI032, demonstrating `__eq__` and `__ne__` methods with `Any` type hints that should trigger the rule, and examples that should not.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_pyi/PYI012.py",
            "description": "This file serves as a test fixture for the `flake8-pyi` linter, demonstrating violations and non-violations of rules like `PYI012` (class body `pass` with other attributes), `Y009` (empty body `pass`), and `Y013` (non-empty body `...`).",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_pyi/PYI036.py",
            "description": "This file contains test cases for the `PYI036` linter rule, which checks for correct signatures of `__exit__` and `__aexit__` methods in Python type stubs, including various 'good' and 'bad' examples and `overload` scenarios.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_pyi/PYI015.py",
            "description": "This file serves as a test fixture for the `flake8-pyi` linter plugin, specifically demonstrating and testing rules related to type annotations, type comments, and the complexity of default values in assignments (PYI015, Y033, Y052).",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_pyi/PYI016.py",
            "description": "This file serves as a test fixture for the `PYI016` linter rule, demonstrating various cases of duplicate members within type unions. It includes examples of type hints using `|` and `typing.Union` that should and should not trigger the linter, covering simple and complex scenarios.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_pyi/PYI004.py",
            "description": "This file serves as a test fixture for the `PYI004` linting rule in Ruff. It demonstrates various `sys.version_info` comparisons, highlighting those that should trigger the `PYI004` violation.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_pyi/PYI003.py",
            "description": "This file serves as a test fixture for the Ruff linter, demonstrating various incorrect or problematic patterns when checking `sys.version_info` in Python code. It includes examples that trigger specific `flake8-pyi` (Y) error codes.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_pyi/PYI010.py",
            "description": "This file serves as a test fixture for the `PYI010` rule of the `flake8_pyi` linter, demonstrating valid and invalid function body contents in type stub files.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_pyi/PYI025_3.py",
            "description": "This test fixture evaluates the PYI025 linter rule for redundant `import X as X` aliases, specifically when such an alias is used to re-export a name and the automatic fix is not deemed safe.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_pyi/PYI030.py",
            "description": "This file contains test cases for the `PYI030` rule from the `flake8-pyi` linter, demonstrating various scenarios where unions of `Literal` types should or should not trigger a linting error.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_pyi/PYI002.py",
            "description": "This file serves as a test fixture for the `PYI002` rule in the `ruff` linter. It contains examples of conditional statements that are expected to trigger `PYI002` violations, specifically related to non-simple comparisons for `sys.version` or `sys.platform` in stub files.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_pyi/PYI017.py",
            "description": "This file serves as a test fixture for the `PYI017` flake8-pyi linter rule, demonstrating valid assignments and type annotations that should not trigger the linter warning. It primarily shows various forms of variable and type alias declarations that are considered acceptable.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_pyi/PYI024.py",
            "description": "This file serves as a test fixture for the `PYI024` rule in the Ruff linter, demonstrating various ways `collections.namedtuple` can be used to ensure the linter correctly flags them for replacement with `typing.NamedTuple`.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_pyi/PYI008.py",
            "description": "This file is a test fixture for the `ruff_linter`'s `flake8_pyi` plugin, demonstrating valid uses of `sys.platform` checks that should not trigger the PYI008 error.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_pyi/PYI005.py",
            "description": "This file serves as a test fixture for the `PYI005` linter rule within `ruff_linter`, demonstrating various conditional checks involving `sys.version_info` and `sys.platform`.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_pyi/PYI018.py",
            "description": "This file is a test fixture for the `flake8-pyi` linter, specifically for rule `PYI018` (Unused TypeVar). It defines various `TypeVar`, `ParamSpec`, and `TypeVarTuple` instances, demonstrating both used and unused cases.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_pyi/PYI055.py",
            "description": "This file contains test cases for the `PYI055` linter rule, demonstrating incorrect usage of `Union` with `type` in type annotations where `Union` can be simplified or is unnecessarily nested.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_pyi/PYI047.py",
            "description": "Tests `flake8-pyi` (PYI047) to identify unused private type aliases, including both `typing.TypeAlias` and PEP 695 `type` statements, across various usage scenarios and conditional definitions.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_pyi/PYI021.py",
            "description": "This file serves as a test fixture for the `flake8_pyi` linter, specifically for rule `PYI021`. It demonstrates valid uses of docstrings in non-stub Python files, verifying that the linter correctly identifies them as not violating the rule.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_pyi/PYI025_2.py",
            "description": "This file is a test fixture for the ruff linter's flake8_pyi plugin (rule PYI025), designed to test how `__all__` handles references, specifically when strings are added using various literal forms (raw strings, concatenations, etc.).",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_pyi/PYI025_1.py",
            "description": "This file is a test fixture for the `flake8-pyi` linter rule `PYI025`. It demonstrates the linter's behavior when `Set` is imported directly versus aliased from `collections.abc`.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_pyi/PYI020.py",
            "description": "This file is a test fixture for the `flake8_pyi` linter plugin, designed to trigger and test the `PYI020` rule concerning quoted type annotations in stub files. It also includes cases for `PYI021` (docstrings in stubs) and `PYI052` (missing type annotations).",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_pyi/PYI042.py",
            "description": "This file contains examples of `TypeAlias` and `type` definitions used to test the `PYI042` linting rule, which enforces naming conventions for type aliases, particularly for camel case. It demonstrates both compliant and non-compliant alias names.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_pyi/PYI019_0.py",
            "description": "This file serves as a test fixture for the `PYI019` linter rule, demonstrating various cases of incorrect (PYI019) and correct usage of `TypeVar` and `Self` in method signatures, including string-based type hints and Python 3.12+ generic type syntax.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_pyi/PYI013.py",
            "description": "This file serves as a test fixture for the `ruff` linter, providing various examples of classes and functions using ellipses (`...`) to test the `flake8-pyi` rule `PYI013` (redundant ellipsis) under different contexts.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_pyi/PYI009.py",
            "description": "This file serves as a test fixture for the `flake8-pyi` linter (rule `PYI009`), demonstrating valid uses of `pass` and `...` in a regular Python file, which should not trigger warnings typically reserved for stub files.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_pyi/PYI041_2.py",
            "description": "This file is a test fixture for the `flake8_pyi` linter in Ruff, specifically designed to test a fix for issue #18298. It verifies that type annotations with multiple `None` types are handled correctly without generating a runtime `TypeError`.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_pyi/PYI050.py",
            "description": "This file serves as a test fixture for the `flake8-pyi` linter rule `PYI050`, demonstrating various scenarios where `NoReturn` or `Never` are incorrectly used as function argument type hints.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_pyi/PYI044.py",
            "description": "This file serves as a test fixture for the PYI044 linter rule, demonstrating that `from __future__ import annotations` is not flagged as an error in non-stub files.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_pyi/PYI033.py",
            "description": "This file serves as a test fixture for the `flake8-pyi` (PYI033) rule within Ruff, demonstrating various instances of type comments that should be flagged as errors in stub files. It illustrates valid and invalid uses of type comments and `type: ignore`.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_pyi/PYI014.py",
            "description": "This file serves as a test fixture for the `PYI014` rule in the Ruff linter's `flake8-pyi` plugin, demonstrating various valid default argument expressions that should not trigger a linting error.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_pyi/PYI026.py",
            "description": "This file serves as a test fixture for the `flake8-pyi` linter, demonstrating various type alias definitions and enum structures to test the `PYI026` rule.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_pyi/PYI056.py",
            "description": "This file serves as a test fixture for the `flake8-pyi` linter rule `PYI056`. It demonstrates various modifications to the `__all__` variable, categorizing them into expected errors and valid operations for testing purposes.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_pyi/PYI011.py",
            "description": "This file serves as a test fixture for the `ruff` linter, specifically for the `flake8_pyi` plugin's PYI011 rule. It demonstrates various valid types of default argument values in function signatures, including literals, expressions, and module attributes, in the context of type stubs.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_pyi/PYI041_1.py",
            "description": "This file serves as a test fixture for the `PYI041` linter rule, demonstrating various scenarios of type hint usage, particularly with `Union` and `|` (union operator), including redundant, nested, and simplified forms.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_pyi/PYI043.py",
            "description": "This file serves as a test fixture for the PYI043 linter rule, demonstrating various TypeAlias definitions. It includes examples that are expected to trigger the linter warning (ending in 'T') and those that should pass.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_pyi/PYI029.py",
            "description": "This file serves as a test fixture for the `flake8-pyi` linter rule `PYI029` in Ruff, demonstrating various implementations of `__repr__` and `__str__` methods to test for missing or incorrect return type hints.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_pyi/PYI045.py",
            "description": "This file serves as a test fixture for the Ruff linter, specifically for `flake8_pyi` rules. It contains various class definitions demonstrating different return type annotations for `__iter__` and `__aiter__` methods, including `Iterable`, `Iterator`, and `AsyncIterable` from `typing` and `collections.abc`, to test type stub validation.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_pyi/PYI066.py",
            "description": "This file serves as a test fixture for the `PYI066` linter rule, demonstrating both cases that should trigger the rule (incorrect ordering of `sys.version_info` checks) and negative cases that should not.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_pyi/PYI052.py",
            "description": "This file serves as a test fixture for the `flake8_pyi` linter rules, specifically demonstrating and testing `Y033`, `Y052`, and `Y015` related to type annotations, type comments, and simple default values in assignments. It includes examples that trigger these diagnostics and cases where they should be ignored.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_pyi/PYI035.py",
            "description": "This file serves as a test fixture for the `flake8_pyi` PYI035 linter rule, demonstrating various declarations of `__all__`, `__match_args__`, and `__slots__` attributes at module and class levels.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_pyi/PYI059.py",
            "description": "This file serves as a test fixture for the `PYI059` linter rule in Ruff, demonstrating various cases where `Generic` is incorrectly or correctly positioned in class inheritance lists within `flake8-pyi` checks.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_pyi/PYI048.py",
            "description": "This file serves as a test fixture for the `PYI048` linting rule, demonstrating cases where function implementations are (or are not) allowed in a stub file context.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_pyi/PYI054.py",
            "description": "This file provides various examples of long numeric literals, including integers, floats, and complex numbers, to serve as a test fixture for the `flake8_pyi` linter rule PYI054.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_pyi/PYI057.py",
            "description": "This file is a test fixture for the `ruff` linter's `PYI057` rule. It tests the linter's handling of `ByteString` type annotations when imported from different modules (e.g., `typing`, `collections.abc`).",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_pyi/PYI049.py",
            "description": "Tests the linter's PYI049 rule for detecting unused TypedDict definitions. It includes examples of both used and unused TypedDicts, as well as a case for class scope handling.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_pyi/PYI034.py",
            "description": "This file serves as a test fixture for the `flake8-pyi` linter rules (specifically PYI034) within the Ruff project, demonstrating correct and incorrect usage of `typing_extensions.Self` type hints in Python stub files for various magic methods like `__new__`, `__enter__`, `__iter__`, and `__aiter__`.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_pyi/PYI046.py",
            "description": "This file contains test cases for the `flake8-pyi` rule `PYI046`, demonstrating valid usages of private protocols that should not trigger a linter error. It defines several private protocols and shows their acceptable use within a public function signature.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_pyi/PYI061.py",
            "description": "This file serves as a test fixture for the `ruff_linter`, specifically to test the `flake8-pyi` rule `PYI061`. It demonstrates various scenarios where `None` is used within `typing.Literal` expressions, highlighting cases that should trigger the linter warning and providing suggested fixes.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_pyi/PYI064.py",
            "description": "This file serves as a test fixture for the `PYI064` linter rule, demonstrating cases where `Final[Literal]` annotations with a single value are flagged or not, including fixable and non-fixable scenarios.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_pyi/PYI058.py",
            "description": "This file contains test cases for the `flake8-pyi` rule PYI058, which flags the incorrect use of `Generator` or `AsyncGenerator` as a return type for `__iter__` or `__aiter__` methods when `Iterator` or `AsyncIterator` would be more appropriate for simple iteration.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_pyi/PYI063.py",
            "description": "This file contains test cases for the `PYI063` linting rule within the `ruff_linter`'s `flake8_pyi` plugin. It demonstrates various function and method definitions, highlighting both correct and incorrect patterns related to positional-only argument syntax and naming conventions as per PEP 484, especially in the context of type hints.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_pyi/PYI053.py",
            "description": "This file serves as a test fixture for the `ruff` linter's `flake8_pyi` plugin, specifically for the `PYI053` (Long string literal) rule. It contains various string and byte literals, some exceeding the typical 50-character limit, to test the rule's detection of long literals and its exemptions for docstrings and `deprecated` decorator messages.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_type_checking/TC001_future_present.py",
            "description": "This file is a test fixture for the ruff linter, specifically designed to test the `flake8-type-checking` rule `TC001` with future annotations and local imports. It demonstrates a function with a type hint using a locally imported module while `annotations` from `__future__` is enabled.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_type_checking/TC001-3_future.py",
            "description": "This file is a test fixture for `ruff`'s `flake8-type-checking` rule TC001, demonstrating type hints with first-party, third-party, and standard library imports.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_type_checking/TC008.py",
            "description": "This file serves as a test fixture for the `flake8_type_checking` linter, specifically for rule TC008, which likely checks for incorrect or unnecessary use of string literals in `TypeAlias` and `type` statements.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_type_checking/TC001.py",
            "description": "This file contains test cases to classify first-party imports in Python code. It demonstrates how imports are handled for both type annotations and runtime usage, including relative imports.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_type_checking/TC004_1.py",
            "description": "This file is a test fixture for `flake8_type_checking` (rule TC004), demonstrating the conditional import of `datetime` under `TYPE_CHECKING` for type analysis.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_type_checking/TC004_6.py",
            "description": "This file is a test fixture for the `flake8_type_checking` linter, specifically for rule TC004. It demonstrates the use of a runtime import of 'DataFrame' that is also conditionally imported within a `TYPE_CHECKING` block.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_type_checking/TC001_future.py",
            "description": "This file serves as a test fixture for the `flake8_type_checking` linter, demonstrating various valid type annotations, including type parameter bounds and defaults, non-generic aliases, unions, and mixed runtime/typing usage, often involving local relative imports.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_type_checking/TC004_13.py",
            "description": "This file defines a `TypeAlias` for a literal string union (`RatingKey`) exclusively for type checking, and then declares a `Final` tuple (`RATING_KEYS`) using this type alias for runtime use.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_type_checking/TC004_3.py",
            "description": "This file is a test fixture for the `flake8_type_checking` linter, specifically for rule TC004. It demonstrates a dynamic `TYPE_CHECKING` block used to conditionally import `Any` and define a type alias.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_type_checking/TC010_1.py",
            "description": "This file serves as a test fixture for the 'flake8_type_checking' linter, specifically demonstrating cases that trigger or pass the 'TC010' rule related to forward references and stringized type annotations.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_type_checking/kw_only.py",
            "description": "This file is a test fixture demonstrating the use of `KW_ONLY` annotations within dataclasses, specifically for testing `flake8_type_checking` rules. It includes examples of `dataclass` definitions with `KW_ONLY` fields.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_type_checking/TC004_4.py",
            "description": "This file is a test fixture for the Ruff linter, specifically designed to test the `TC004` rule within the `flake8_type_checking` plugin. It demonstrates type hints using `TYPE_CHECKING`, `Type`, and `Any` for type-checking related scenarios.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_type_checking/runtime_evaluated_base_classes_4.py",
            "description": "Defines a SQLAlchemy ORM model 'Birthday' with 'id' and 'day' columns. This file likely serves as a test fixture for type checking, specifically for runtime-evaluated base classes.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_type_checking/TC004_5.py",
            "description": "This file is a test fixture for the `ruff` linter's `flake8-type-checking` rule TC004. It demonstrates the use of `typing.TYPE_CHECKING` for conditional type imports within a function signature.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_type_checking/TC010_2.py",
            "description": "This file serves as a test fixture for the `flake8-type-checking` linter rule TC010. It demonstrates various type annotations, including string literal types, to test scenarios that should and should not trigger the TC010 violation.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_type_checking/TC004_10.py",
            "description": "This file is a test fixture for the `flake8-type-checking` linter, specifically for rule `TC004`. It demonstrates unqualified type annotations (Tuple, List, Dict) when the `typing` module is only imported conditionally within a `TYPE_CHECKING` block.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_type_checking/TC004_2.py",
            "description": "This file is a test fixture demonstrating the conditional import of `datetime.date` inside a `TYPE_CHECKING` block, used for type-checking-only dependencies. It verifies how a linter handles such constructs.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_type_checking/TC004_15.py",
            "description": "This file is a test fixture for flake8_type_checking (TC004_15), demonstrating the use of type aliases, conditional imports for type checking, and generic type hints with `type` statements and `TypeVar` bounds.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_type_checking/TC002.py",
            "description": "This file contains test cases for a linter, specifically designed to check the accurate detection of imports that are only used for type annotations or hints. It demonstrates various scenarios where an import might or might not be considered 'typing-only'.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_type_checking/quote3.py",
            "description": "This file provides test fixtures for a linter's type checking rules, specifically demonstrating various uses of `typing.Literal`, `typing.Union`, and `typing.Annotated` with mixed quote styles in type annotations.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_type_checking/snapshot.py",
            "description": "This is a regression test fixture for ruff's `flake8_type_checking` linter, specifically designed to ensure that `__all__` entries are not incorrectly identified as typing-only references.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_type_checking/singledispatch.py",
            "description": "This file is a test fixture for `flake8_type_checking` that demonstrates the use of `singledispatch` functions with various type hints and imports, including conditional imports for type checking.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_type_checking/exempt_type_checking_1.py",
            "description": "This file serves as a test fixture for `flake8_type_checking`, demonstrating a scenario where `TYPE_CHECKING` is added to an existing `typing` import, and another member is moved. It includes an example of a constant defined using `typing.Final`.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_type_checking/TC004_17.py",
            "description": "This file serves as a test fixture for the `flake8-type-checking` linter, demonstrating the use of `TYPE_CHECKING` guards for conditional imports in conjunction with `from __future__ import annotations`.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_type_checking/quote.py",
            "description": "This file serves as a test fixture for a linter, demonstrating various type hinting scenarios, especially involving 'pandas' types and `TYPE_CHECKING` blocks, to ensure correct analysis of type annotations.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_type_checking/typing_modules_1.py",
            "description": "This file is a test fixture for the `flake8_type_checking` rule in `ruff`. It tests the handling of `typing_extensions.Self` and a deferred import for type annotations within a function.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_type_checking/exempt_modules.py",
            "description": "This file provides test fixtures for the `flake8-type-checking` rules, showcasing how type annotations involving imported modules like pandas and flask are handled.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_type_checking/runtime_evaluated_base_classes_3.py",
            "description": "This file serves as a test fixture for the `flake8_type_checking` linter, demonstrating various class definitions with type hints and base classes (including Pydantic models) to test runtime evaluation of base classes and type-checking rules like TC003.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_type_checking/TC006.py",
            "description": "This file serves as a test fixture for the `flake8_type_checking` linter rule TC006, demonstrating various correct and incorrect usages of `typing.cast`.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_type_checking/TC004_9.py",
            "description": "This file is a test fixture for the `flake8-type-checking` linter, specifically for rule TC004. It demonstrates the use of type hints (Tuple, List, Dict) that are imported within a `TYPE_CHECKING` block and then used outside of it.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_type_checking/TC007.py",
            "description": "This file is a test fixture for the `TC007` rule of the `flake8_type_checking` linter plugin, demonstrating valid and invalid uses of `TypeAlias` for forward references and nested type aliases, contrasted with the new `type` statement.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_type_checking/singledispatchmethod.py",
            "description": "This file contains test cases demonstrating the usage of `functools.singledispatchmethod` with type annotations for different argument types within class methods. It illustrates how to define a generic method and register specialized implementations for types like `MutableMapping`, `Mapping`, `int`, `str`, and `Union`.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_type_checking/TC004_8.py",
            "description": "This file is a test fixture for the `flake8_type_checking` linter, specifically for rule `TC004`. It demonstrates the use of `WeakKeyDictionary` with string-based type hints for `Any` that are only imported during type checking.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_type_checking/TC004_7.py",
            "description": "A test fixture for the `flake8_type_checking` linter, demonstrating type-checking-only imports within a `TYPE_CHECKING` block when `from __future__ import annotations` is active for an async generator.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_type_checking/runtime_evaluated_base_classes_2.py",
            "description": "This file serves as a test fixture for a linter, demonstrating how it handles type-hinted attributes within classes that inherit from various base classes, including those from external libraries like Pydantic, GeoPandas, and NumPy.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_type_checking/TC008_union_syntax_pre_py310.py",
            "description": "This file is a test fixture for the `ruff` linter's `flake8-type-checking` rule TC008. It evaluates type aliases defined as string literals for union and `Annotated` types, focusing on behavior before Python 3.10's native union syntax and within `TYPE_CHECKING` blocks.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_type_checking/TC004_16.py",
            "description": "This file is a test fixture for the `ruff_linter` demonstrating the correct use of `TYPE_CHECKING` to conditionally import `DataFrame` from `pandas` for type annotations, ensuring the linter does not flag it as an error.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_type_checking/runtime_evaluated_decorators_3.py",
            "description": "This file defines classes using `attrs` and `dataclasses`, and a function with `pydantic.validate_call`, all utilizing type hints. It serves as a test fixture for `flake8-type-checking` rules related to runtime-evaluated decorators.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_type_checking/strict.py",
            "description": "This file contains test cases (fixtures) for the `flake8-type-checking` linter rules, specifically demonstrating various import usage scenarios in both strict and non-strict modes. It covers how imports used in type annotations or runtime code should or should not trigger linting errors.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_type_checking/TC008_typing_execution_context.py",
            "description": "This file is a test fixture for the Ruff linter, designed to demonstrate and verify the `TC008` diagnostic from the `flake8-type-checking` plugin. It defines various `TypeAlias` assignments using string literals within a `TYPE_CHECKING` block, which are expected to trigger the linter rule.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_type_checking/exempt_type_checking_2.py",
            "description": "This file is a test fixture for Ruff's `flake8_type_checking` rule, demonstrating the import and usage of `TYPE_CHECKING` alongside other members from the `typing` module.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_type_checking/TC004_11.py",
            "description": "This test fixture demonstrates a conditional import of `typing.List` within a `TYPE_CHECKING` block, which is then made part of the module's public API via `__all__`.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_type_checking/TC003.py",
            "description": "This file provides test cases for the `flake8_type_checking` rule `TC003`, focusing on the classification of standard library imports. It includes examples of runtime and typing-only usage, alongside a regression test for `KW_ONLY` in dataclasses.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_type_checking/runtime_evaluated_decorators_1.py",
            "description": "This file is a test fixture for `flake8_type_checking` (specifically rule TC004) to demonstrate type-checking-only imports used within type hints of classes decorated with runtime-evaluated decorators like `attrs.define` or `dataclass`.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_type_checking/runtime_evaluated_base_classes_5.py",
            "description": "This file is a test fixture for the `ruff_linter`'s `flake8_type_checking` module. It demonstrates a Pydantic `BaseModel` subclass using `from __future__ import annotations` and a `pandas.DataFrame` type hint, likely to test runtime evaluation of base classes.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_type_checking/whitespace.py",
            "description": "This is a regression test fixture for ruff's `flake8_type_checking` rules, specifically addressing an issue with a unicode formfeed character in an import statement.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_type_checking/init_var.py",
            "description": "This file is a test fixture for the Ruff linter, demonstrating a `dataclasses.InitVar` usage within a dataclass to test specific type-checking rules related to `InitVar`.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_type_checking/exempt_type_checking_3.py",
            "description": "This file is a test fixture for the `ruff_linter`'s `flake8_type_checking` rule, demonstrating a scenario involving `typing` imports (`Final`, `Mapping`) and potentially an exemption related to type checking.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_type_checking/quote2.py",
            "description": "This file provides test fixtures for a linter, specifically to verify its behavior when processing type annotations that contain various forms of quotes, `Literal`, `Annotated`, `Union`, and `Optional` types. It includes cases for double, single, and mixed quotes within type arguments, as well as complex nested type constructs.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_type_checking/TC004_12.py",
            "description": "This file is a test fixture for the `flake8_type_checking` linter, demonstrating the definition of a `TypeAlias` for a generic callable using a `TYPE_CHECKING` guard for the `Callable` import.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_type_checking/module/direct.py",
            "description": "This file serves as a test fixture for the `flake8_type_checking` linter within the Ruff project. It demonstrates basic class definition and type annotations using `collections.abc.Sequence` to test linter behavior.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_type_checking/module/app.py",
            "description": "This file is a test fixture for type checking, demonstrating FastAPI application definitions and routes with type hints for `datetime` and `array` which are conditionally imported under `TYPE_CHECKING`.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_type_checking/module/import.py",
            "description": "This file serves as a test fixture for the `flake8_type_checking` linter. It demonstrates various import statements and type hints within a class definition for testing purposes.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pydoclint/DOC202_numpy.py",
            "description": "This file contains test cases for the PyDocLint rule DOC202, which checks for missing 'Returns' sections in NumPy-style docstrings. It demonstrates both valid and invalid docstrings related to this rule in functions and methods.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pydoclint/DOC403_google.py",
            "description": "This file contains test cases for the `DOC403` rule of `pydoclint`, demonstrating correct and incorrect Google-style docstring formatting, particularly regarding the 'Yields' section.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pydoclint/DOC102_numpy.py",
            "description": "This file contains a series of Python functions and a class with NumPy-style docstrings, serving as test cases for a linter rule (likely DOC102) that validates parameter consistency between function signatures and their docstrings.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pydoclint/DOC502_numpy.py",
            "description": "This file serves as a test fixture for the `pydoclint` linter, specifically demonstrating various scenarios and expected behaviors for the `Raises` section within docstrings, including handling of multiple exceptions and Sphinx directives.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pydoclint/DOC501_numpy.py",
            "description": "Test fixtures for the `pydoclint` DOC501 rule, demonstrating various scenarios of `Raises` section presence and absence in NumPy-style docstrings for a linter.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pydoclint/DOC403_numpy.py",
            "description": "This file contains test cases for the `DOC403` linting rule in `pydoclint`, demonstrating correct and incorrect docstring formats, particularly for functions that yield values.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pydoclint/DOC202_google.py",
            "description": "This file serves as a test fixture for the `pydoclint` `DOC202` rule, demonstrating various scenarios where docstrings do or do not correctly specify return types or include `Returns:` sections when none is necessary.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pydoclint/DOC502_google.py",
            "description": "This file serves as a test fixture for a linter, specifically demonstrating cases that should and should not trigger the `DOC502` rule related to the `Raises` section in Google-style docstrings.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pydoclint/DOC201_google.py",
            "description": "This file serves as a test fixture for the `pydoclint` linter, specifically demonstrating cases that should trigger or pass the `DOC201` rule related to missing or incorrect 'Returns' sections in Google-style docstrings, especially concerning `None` returns.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pydoclint/DOC402_google.py",
            "description": "This file serves as a test fixture for the `pydoclint` rule DOC402 within the Ruff linter. It contains examples of generator functions that either correctly include or incorrectly omit a `Yields` section in their docstrings.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pydoclint/DOC102_google.py",
            "description": "This file contains test fixtures for the `DOC102` pydoclint rule, demonstrating various cases of mismatches between function parameters and their docstring `Args:` sections in Google style.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pydoclint/DOC501_google.py",
            "description": "This file serves as a test fixture for the `pydoclint` linter, specifically evaluating the `DOC501` rule which checks for documentation of raised exceptions in function docstrings. It contains various examples of functions raising exceptions, with comments indicating whether they should pass or fail the `DOC501` check.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pydoclint/DOC201_numpy.py",
            "description": "This file is a test fixture for the `ruff` linter, specifically designed to test the `DOC201` rule of `pydoclint` for NumPy-style docstrings. It demonstrates various scenarios of return type documentation, including `None` returns and generator functions, marking whether they pass ('OK') or fail ('DOC201') the linter check.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pydoclint/DOC402_numpy.py",
            "description": "This file contains test cases for the `DOC402` linter rule, which checks for missing or incorrect 'Yields' sections in Numpydoc-style docstrings for generator functions. It includes examples that should trigger the rule and those that should pass.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pydoclint/DOC501.py",
            "description": "This file serves as a test fixture for the `pydoclint` linter within the `ruff` project. It contains Python function definitions with various docstring examples, likely to test specific docstring validation rules.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pydocstyle/D208.py",
            "description": "This file contains test fixtures for the `ruff_linter` to verify the detection of incorrect docstring indentation, specifically targeting `pydocstyle` rule D208 and related cases.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pydocstyle/D401.py",
            "description": "This file serves as a test fixture for the D401 pydocstyle rule, demonstrating both correct and incorrect docstring formatting regarding imperative mood for functions, methods, and classes.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pydocstyle/D400.py",
            "description": "This file serves as a test fixture for the `ruff` linter, specifically designed to test the D400 pydocstyle rule (First line of docstring should end with a period) with various docstring formats.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pydocstyle/D215.py",
            "description": "This file is a test fixture for the Pydocstyle D215 rule in the Ruff linter, designed to test its behavior with a placeholder docstring.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pydocstyle/D402.py",
            "description": "Test cases for the Pydocstyle D402 rule, which checks if the first line of a docstring ends with a period. It contains multiple examples of docstrings that violate this rule.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pydocstyle/D403.py",
            "description": "This file serves as a test fixture for Pydocstyle rule D403, demonstrating various docstring capitalization and formatting scenarios, including valid and invalid cases. It is used to test how a linter handles the capitalization of the first word in a docstring.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pydocstyle/D400_415.py",
            "description": "This file contains test fixtures for pydocstyle rules D400 and D415, specifically demonstrating docstrings that end with various punctuation marks or whitespace.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pydocstyle/D214_module.py",
            "description": "This file serves as a test fixture for the `pydocstyle` linter, specifically designed to demonstrate and detect D214 violations (over-indented sections) within docstrings.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pydocstyle/canonical_google_examples.py",
            "description": "This file contains canonical Google Python Style Guide docstring examples for modules, functions, and classes. It serves as a test fixture for a linter to check for expected pydocstyle violations based on these examples.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pydocstyle/sections.py",
            "description": "This file contains a collection of test cases for a linter, specifically designed to check various docstring formatting and convention issues related to sections (e.g., Returns, Args, Parameters) in Python code. It defines functions and classes that intentionally violate different docstring style rules to ensure the linter correctly identifies them.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pydocstyle/canonical_numpy_examples.py",
            "description": "This file serves as a test fixture for a linter, providing canonical NumPy-style docstring examples to identify and test various docstring convention violations.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pydocstyle/D410.py",
            "description": "This file contains Python functions with docstrings that serve as test fixtures for the `pydocstyle` D410 rule, likely verifying correct blank line usage after 'Parameters' and 'Returns' sections.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pydocstyle/D209_D400.py",
            "description": "Test fixture for Pydocstyle, specifically to check violations D209 (multi-line docstring closing quotes) and D400 (first line period).",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pydocstyle/D.py",
            "description": "This file serves as a test fixture for the Pydocstyle linter rules (D-series). It contains various intentionally malformed docstrings and missing docstrings in classes, methods, and functions to test the linter's ability to identify specific D-style violations.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pydocstyle/sphinx.py",
            "description": "This file serves as a test fixture for the `ruff_linter` project, specifically designed to test various Sphinx-style docstring formats, particularly around code blocks and example sections, to ensure correct linter behavior.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pydocstyle/D417.py",
            "description": "This file contains a series of Python functions and classes designed as test fixtures for the D417 Pydocstyle rule, which checks for proper documentation of function arguments in docstrings. It demonstrates various valid and invalid argument documentation styles, including hanging indents, missing argument descriptions, `*args`/`**kwargs`, and handling of special argument names.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pydocstyle/D200.py",
            "description": "This file contains test cases for the `pydocstyle` D200 rule within the Ruff linter, demonstrating various forms of empty or nearly empty docstrings.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pydocstyle/setter.py",
            "description": "This file is a test fixture for `pydocstyle` within the `ruff` linter, demonstrating a class with a property, its setter, and deleter methods, including a redefinition, likely to test linter behavior.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pydocstyle/D300.py",
            "description": "This file contains test cases for the `D300` pydocstyle linting rule, showcasing how the linter handles docstrings with backslashes and various quote styles.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pydocstyle/bom.py",
            "description": "This file is a test fixture for `pydocstyle`, specifically designed to test how the linter handles Python files containing a Byte Order Mark (BOM). It includes a docstring that defines SAM macros.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pydocstyle/all.py",
            "description": "This file is a test fixture for the `pydocstyle` linter, demonstrating how public and private members are defined and explicitly exposed using `__all__`.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pydocstyle/D413.py",
            "description": "This file serves as a test fixture for the Ruff linter's `pydocstyle` rules, specifically `D413`. It contains multiple docstring examples designed to test the detection of missing blank lines after the last section (e.g., 'Returns') in docstrings.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pydocstyle/D202.py",
            "description": "This file contains test cases for the pydocstyle D202 rule (blank-line-after-function), specifically demonstrating its behavior and special cases around comment handling after a function's docstring.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pydocstyle/D301.py",
            "description": "This file provides test cases and fixtures for the Pydocstyle D301 rule within the Ruff linter, focusing on the correct or incorrect usage of raw string literals (r-strings) in docstrings.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pydocstyle/D104",
            "description": "This directory contains test fixtures for the `ruff_linter`. It provides example Python files specifically designed to verify the linter's correct identification and handling of `pydocstyle` rule D104, which checks for missing docstrings in public packages.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pydocstyle/_unrelated/pkg/_priv",
            "description": "This directory contains test fixtures for the `ruff_linter`, specifically for validating `pydocstyle` rules within a simulated private package structure. It includes a Python module designed to test the absence of a module docstring (D100) in a private context. This helps ensure `ruff` correctly applies or ignores docstring requirements in private or internal code.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyflakes/F821_15.py",
            "description": "This file is a test fixture demonstrating the use of f-strings within future type annotations. It specifically tests how `ruff` (or `pyflakes`) handles `List[f\"i{x}nt\"]` type hints.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyflakes/F821_27.py",
            "description": "Tests various type annotation constructs, such as self-references, circular references, and forward references, to evaluate their validity when `from __future__ import annotations` is enabled versus when it's not.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyflakes/F821_26.py",
            "description": "This file tests Python type hinting constructs that are valid in `.pyi` stub files but might cause issues or behave differently in regular `.py` runtime files, especially concerning forward references and circular dependencies.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyflakes/typing_modules.py",
            "description": "This file is a test fixture for `ruff_linter` to evaluate its handling of `typing` module imports and type annotations, including specialized imports from `airflow.typing_compat`. It defines examples of `Union` and `Optional` types using `Literal`.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pyflakes/future_annotations.py",
            "description": "This file serves as a test fixture for the Pyflakes linter, demonstrating various type annotations, including `__future__` imports, stringified forward references, and complex type hints.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pygrep_hooks/PGH003_1.py",
            "description": "This file serves as a test fixture for the PGH003 rule within ruff_linter, demonstrating various valid and invalid formats of `pyright: ignore` comments to ensure correct parsing and detection.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pylint/type_bivariance.py",
            "description": "This file serves as a test fixture for a linter, specifically demonstrating valid and invalid (bivariant) combinations of 'covariant' and 'contravariant' flags when defining 'TypeVar' and 'ParamSpec' objects.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pylint/type_name_incorrect_variance.py",
            "description": "Test fixture for a linter rule that identifies incorrect variance declarations in `TypeVar` and `ParamSpec` definitions, distinguishing between expected errors and non-errors.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pylint/type_param_name_mismatch.py",
            "description": "This file is a test fixture demonstrating cases where the assigned variable name for `TypeVar`, `ParamSpec`, `NewType`, or `TypeVarTuple` does not match the name passed to its constructor, categorized by expected linting outcome.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/semantic_errors/duplicate_type_parameter.py",
            "description": "This file contains a test case demonstrating a semantic error caused by defining a class with duplicate type parameters, specifically for the ruff linter.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/semantic_errors/annotated_global.py",
            "description": "Tests various semantic error cases and valid usages when the `global` keyword is combined with type annotations in functions and class scopes.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/ruff/RUF013_1.py",
            "description": "This file is a test fixture for the RUF013 rule in Ruff, demonstrating a violation where `None` is used as a default value for a type-hinted argument without explicitly importing or using `typing.Optional`.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/ruff/RUF013_4.py",
            "description": "This file serves as a test fixture for the Ruff linter, demonstrating various usages of `typing.Optional` in function signatures and return types. It likely targets a specific linter rule related to issue #13833.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/ruff/RUF013_3.py",
            "description": "This file serves as a test fixture for the Ruff linter, specifically for the RUF013 rule. It demonstrates various type hints from the `typing` module, such as `List`, `Optional`, `Union`, and `Literal`, to check how the linter handles `None` as a default argument.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/ruff/RUF038.py",
            "description": "This file contains test cases for the `RUF038` linter rule, which detects redundant `Literal[True, False]` type hints that can be simplified to `bool`.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/ruff/RUF012_deferred.py",
            "description": "This file is a test fixture for Ruff, designed to verify that the linter correctly handles deferred type annotations, specifically `ClassVar`, when imported only within a `TYPE_CHECKING` block.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/ruff/RUF013_0.py",
            "description": "This file serves as a test fixture for the RUF013 rule in the Ruff linter, demonstrating various scenarios where a parameter's type annotation does not explicitly include 'None' but its default value is 'None'.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/ruff/RUF036.py",
            "description": "Test cases for the RUF036 ruff rule, demonstrating redundant `None` in type hints using both `|` syntax and `typing.Union`.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/ruff/RUF041.py",
            "description": "This file serves as a test fixture for the 'ruff' linter, specifically for rule RUF041. It demonstrates various scenarios involving `typing.Literal` with nested types and duplicate values to test the linter's detection capabilities.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/ruff/RUF101_1.py",
            "description": "This file is a regression test for RUF101, designed to verify Ruff's linting behavior regarding type-checking imports, specifically after `TCH` rules were recoded to `TC`.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/ruff/RUF053.py",
            "description": "This file serves as a test fixture for the RUF053 linter rule, demonstrating various valid and invalid uses of generic type parameters and the `Generic` base class in class definitions. It includes examples of `TypeVar`, `TypeVarTuple`, and `ParamSpec` to test the linter's behavior.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/ruff/redirects.py",
            "description": "This file serves as a test fixture for the Ruff linter, demonstrating how `Optional` type hints are handled and likely testing or documenting a specific error code redirect (U007 to UP007).",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_no_pep420/test_pass_pyi",
            "description": "This directory serves as a test fixture for the `ruff_linter`, specifically for the `flake8_no_pep420` rule. It contains test cases that are expected to pass linting checks when applied to `.pyi` files. The absence of files here likely indicates a scenario where no issues should be reported.",
            "spof": false
          }
        ],
        "contributors": [
          {
            "name": "Brent Westbrook",
            "percent": 22
          },
          {
            "name": "Auguste Lalande",
            "percent": 14
          },
          {
            "name": "Alex Waygood",
            "percent": 11
          }
        ]
      },
      "Core Analysis Engine": {
        "files": [
          {
            "path": "crates/ty_python_semantic/resources/mdtest/exception/control_flow.md",
            "description": "This markdown document describes and tests the control flow semantics and type inference within Python's `try`/`except`/`else`/`finally` blocks, focusing on how variable definition states and types are determined across different branches.",
            "spof": true
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/exception/basic.md",
            "description": "This file is a Markdown test resource for the `ruff` linter's Python semantic analysis, demonstrating various aspects of exception handling. It covers type inference for caught exceptions, valid and invalid `except` clauses, proper usage of `raise` statements, and the scope of exception variables.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/cyclic_comprehensions.py",
            "description": "This file is a regression test case for a linter (likely Ruff) designed to trigger a 'too many cycle iterations' error, specifically related to the analysis of complex, cyclic comprehensions.",
            "spof": true
          },
          {
            "path": "crates/ruff_notebook/resources/test/fixtures/jupyter/cell",
            "description": "This directory contains test fixtures specifically designed for Jupyter notebook cells within the `ruff_notebook` crate. These fixtures are used to provide example cell data for testing purposes, ensuring the correct handling and analysis of notebook cell content.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/doc_lines.rs",
            "description": "This file provides functionality to extract 'doc lines' from Python source code, which are defined as lines consisting of either standalone comments or constant string statements, using both token-based and AST-based analysis.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/checkers/ast/annotation.rs",
            "description": "This file defines an enum `AnnotationContext` and provides methods to determine the runtime context (e.g., `RuntimeRequired`, `TypingOnly`) of Python type annotations. This context is used by linting rules to identify how annotations are processed at runtime versus type-checking time.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/checkers/ast/deferred.rs",
            "description": "This file defines data structures (`Visit` and `Analyze`) used to store Abstract Syntax Tree (AST) nodes and their associated semantic context for deferred processing during linting, enabling multi-pass analysis. These structures allow for handling elements like function bodies or `for` loops after an initial AST traversal.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/checkers/ast/mod.rs",
            "description": "This file defines the core `Checker` responsible for traversing the Abstract Syntax Tree (AST) to build a semantic model and apply AST-based lint rules. It manages the state and logic for processing Python code in evaluation order to detect and report violations.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/checkers/ast/analyze/mod.rs",
            "description": "This file serves as a central module for organizing and re-exporting various AST analysis and linting functionalities from its sub-modules within the `ruff_linter` crate. It provides a structured way to access different AST-related checks and analysis functions.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/checkers/ast/analyze/deferred_scopes.rs",
            "description": "Applies a wide range of linting rules to deferred scopes (e.g., functions, classes, modules) within a Python file's semantic model to identify various issues like unused variables, undefined locals, and incorrect import usage.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/checkers/ast/analyze/bindings.rs",
            "description": "This file defines a function that iterates through the semantic bindings (variables, functions, classes, etc.) of the code and applies a variety of linting rules to each binding based on enabled checks. It serves as a central point for rules that analyze individual identifiers and their properties.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/checkers/ast/analyze/suite.rs",
            "description": "This file defines a function that analyzes a suite of Python AST statements, dispatching to various linting rules (e.g., `flake8_pie`, `flake8_pyi`, `refurb`) if they are enabled by the checker.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/checkers/ast/analyze/expression.rs",
            "description": "This file contains the core logic for analyzing Python expression (Expr) AST nodes within the Ruff linter. It dispatches to various lint rules based on the expression type and checker settings, particularly focusing on type annotations and subscript expressions.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/comments/snapshots",
            "description": "This directory contains test snapshots specifically for the comment-related functionality within the `ruff_linter` crate. These snapshots serve as golden masters to ensure consistent output and prevent regressions in how comments are processed and handled by the linter.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/cst/mod.rs",
            "description": "This file serves as the module declaration for the `cst` component within the `ruff_linter` crate. It aggregates helpers and matchers related to Concrete Syntax Tree (CST) processing.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/mccabe/rules/function_is_too_complex.rs",
            "description": "This file defines a linter rule that calculates the McCabe complexity of Python functions and reports violations for functions exceeding a configurable complexity threshold. It includes the logic for traversing the abstract syntax tree to count decision points in various Python control flow statements.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pycodestyle/rules/logical_lines/mod.rs",
            "description": "This module defines structures and utilities for representing and analyzing 'logical lines' of code, which may span multiple physical lines. It serves as a foundational component for various whitespace and line-structure related linting rules in the linter.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/ruff/rules/suppression_comment_visitor.rs",
            "description": "This file defines a visitor that traverses the Abstract Syntax Tree (AST) to identify and contextualize suppression comments (e.g., `# fmt: skip`). It captures details about each comment's position relative to AST nodes for further processing.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/src/linter/float.rs",
            "description": "This file provides utility functions to identify string literals in the Abstract Syntax Tree (AST) that represent special floating-point values like NaN or Infinity, including various formats and case insensitivity.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/project/project/file.py",
            "description": "This is a simple Python test file or placeholder, likely used within the ruff_linter's testing framework to validate file parsing or basic linting operations.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/project/python_modules/app/app",
            "description": "This directory represents a Python package within a test application, specifically designed for evaluating the `ruff_linter`'s analysis capabilities. It contains source files that the linter will process to ensure its correctness and functionality.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/control-flow-graph/for.py",
            "description": "This file contains a collection of Python functions, each demonstrating different control flow patterns within `for` loops, including `break`, `continue`, `else` clauses, and nested loops. It likely serves as a test fixture for control flow graph analysis in a linter or static analysis tool.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/control-flow-graph/raise.py",
            "description": "This file contains test fixtures for control flow graph analysis, specifically demonstrating Python functions that utilize the `raise` statement.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/control-flow-graph/match.py",
            "description": "This file contains a collection of Python functions demonstrating various use cases and patterns for the `match` statement, likely serving as test fixtures for control flow graph analysis or pattern matching functionality.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/control-flow-graph/if.py",
            "description": "This file serves as a test fixture for control-flow graph analysis within the ruff linter, specifically demonstrating various `if`, `elif`, and `else` statement structures.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/control-flow-graph/assert.py",
            "description": "This file provides various test cases for Python's `assert` statement, showcasing its usage with different arguments and within various control flow structures.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/control-flow-graph/try-finally-nested-if-while.py",
            "description": "This file serves as a test fixture for control flow graph analysis within the `ruff_linter`. It demonstrates a complex nested control flow structure, including `try-finally` blocks within `while` loops.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/control-flow-graph/try.py",
            "description": "This file contains a series of test cases demonstrating various `try` and `except`/`else`/`finally` block configurations in Python. It is used to test control flow graph generation and analysis, especially for complex exception handling scenarios.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/control-flow-graph/simple.py",
            "description": "This file contains a collection of simple Python functions, each demonstrating basic control flow constructs. It serves as a fixture for testing control-flow graph analysis within the ruff linter.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/control-flow-graph/while.py",
            "description": "This file contains a collection of Python functions demonstrating various `while` loop constructs and their control flow, serving as test fixtures for a linter's control-flow graph analysis.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/mccabe/C901.py",
            "description": "This file contains various Python function examples demonstrating different control flow structures and features, serving as a test fixture for McCabe complexity calculation in a linter (likely Ruff's C901 rule).",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/syntax_errors/yield_scope.py",
            "description": "This file is a test fixture demonstrating the expected scoping rules and syntax errors for 'yield' and 'await' expressions in various Python constructs, such as global scope, functions, lambdas, comprehensions, and classes.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/semantic_errors/rebound_comprehension.py",
            "description": "This file serves as a test fixture for semantic analysis, specifically to evaluate how the linter handles the walrus operator within a list comprehension where the loop variable is reassigned.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/semantic_errors/invalid_expression.py",
            "description": "This file contains intentionally invalid Python expressions, primarily involving 'yield' and 'yield from' in type annotations, type parameters, and class bases, to test the linter's ability to detect semantic errors.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/semantic_errors/multiple_case_assignment.py",
            "description": "Tests Ruff's semantic analysis of a `match` statement where the same variable is used multiple times within a list pattern.",
            "spof": true
          }
        ],
        "contributors": [
          {
            "name": "Brent Westbrook",
            "percent": 41
          },
          {
            "name": "GiGaGon",
            "percent": 6
          },
          {
            "name": "Charlie Marsh",
            "percent": 5
          }
        ]
      },
      "Import Sorting and Management (`isort`)": {
        "files": [
          {
            "path": "crates/ruff_linter/src/checkers/imports.rs",
            "description": "This file implements import analysis and enforcement of import-related linting rules, primarily using `isort` logic, for the Ruff linter.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_import_conventions/settings.rs",
            "description": "This file defines the settings structure for managing import conventions within the Ruff linter, including conventional aliases and mechanisms for banning specific aliases or imports. It provides data structures and default values for configuring import-related linting rules.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_import_conventions/mod.rs",
            "description": "This file is the root module for the `flake8-import-conventions` rule set within the `ruff_linter` crate, defining its sub-modules and containing unit tests for its functionality, including default and custom import alias conventions.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_import_conventions/rules/banned_import_from.rs",
            "description": "This file implements a lint rule (ICN003) that detects and flags `from module import member` statements for specified modules, encouraging users to import the entire module and access members via the module alias instead.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_import_conventions/rules/unconventional_import_alias.rs",
            "description": "This file implements a linter rule (`ICN001`) that identifies and fixes unconventional import aliases, ensuring that modules are imported with their commonly established aliases (e.g., `import pandas as pd`). It enforces consistency and readability in import statements.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_import_conventions/rules/mod.rs",
            "description": "This file acts as the module entry point, re-exporting and organizing individual rules related to Flake8 import conventions, such as banning specific import aliases or `from` imports, and identifying unconventional aliases.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_import_conventions/rules/banned_import_alias.rs",
            "description": "This file defines a linting rule (`ICN002`) that detects and reports the use of explicitly banned import aliases for modules or submodules, ensuring consistent and standard import conventions.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_import_conventions/snapshots",
            "description": "This directory stores snapshot test files for the `flake8_import_conventions` rule within the `ruff_linter` crate. These snapshots capture expected outputs or behaviors, ensuring consistent rule application during testing.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_tidy_imports/matchers.rs",
            "description": "This file defines structures and an enum for matching imported module and member names against a ban policy, supporting exact matches for members and parent-aware matches for modules. It provides the core logic for identifying problematic imports based on configured rules.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_tidy_imports/mod.rs",
            "description": "This file serves as the main module for the `flake8-tidy-imports` rules within the Ruff linter, defining its structure and containing comprehensive test cases for various `flake8-tidy-imports` rules like banned API usage and relative import restrictions.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_tidy_imports/rules/banned_api.rs",
            "description": "This file implements a Ruff linting rule (`TID251`) that detects and reports the use of explicitly banned modules or module members within a Python codebase. It enforces project-specific conventions by flagging both direct imports and attribute access to restricted APIs.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_tidy_imports/rules/mod.rs",
            "description": "This file acts as a module entry point, re-exporting rules related to banned APIs, banned module-level imports, and relative imports for the `flake8_tidy_imports` linter. It consolidates these individual rule modules for broader access within the crate.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_tidy_imports/rules/banned_module_level_imports.rs",
            "description": "This file implements the `banned-module-level-imports` rule (TID253) for the `flake8-tidy-imports` linter, which identifies and reports imports of expensive modules occurring at the module level rather than lazily within functions or other nested contexts.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_tidy_imports/snapshots",
            "description": "This directory stores snapshot test files specifically for the `flake8_tidy_imports` linter rule. These snapshots capture expected outputs or diagnostics, ensuring that future code changes do not inadvertently alter the rule's behavior.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/isort/settings.rs",
            "description": "This file defines the `isort` plugin's configuration settings for Ruff, including options for import sorting, grouping, and ordering. It also specifies enums for relative import order and error types for invalid settings.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/isort/helpers.rs",
            "description": "This file contains helper functions for `isort` rules within the Ruff linter, specifically for detecting trailing commas in import statements and identifying 'comment breaks' that separate code blocks.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/isort/format.rs",
            "description": "This file provides functions for formatting Python import statements (both `import` and `from ... import`) according to `isort` rules, handling single-line and multi-line output, comments, and line length constraints.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/src/rules/isort/order.rs",
            "description": "This file contains the logic for ordering and sorting import statements within a given block, applying different sorting strategies based on import type, section, and user settings for the `isort` rule.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/isort/mod.rs",
            "description": "This file implements the `isort` rules for the Ruff linter, focusing on analyzing, sorting, and formatting Python import statements. It orchestrates the process of annotating, normalizing, categorizing, and ordering imports to produce a reformatted output.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/isort/split.rs",
            "description": "This file provides functionality to split a single import block into multiple blocks based on a set of `forced_separate` patterns. It assigns imports matching specific patterns to designated blocks, while others go into a default block, likely for import sorting or organization.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/isort/annotate.rs",
            "description": "This file provides functionality to annotate abstract syntax tree (AST) import statements with associated comments (above, inline, and trailing) and other metadata. It processes `Stmt::Import` and `Stmt::ImportFrom` nodes to create a rich, annotated representation of imports for further processing, likely by the `isort` rule.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/isort/block.rs",
            "description": "This file defines structures and logic to identify and categorize import blocks within a Python module's abstract syntax tree. It processes statements to determine import block boundaries, including special handling for nested scopes and directives for import sorting.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/src/rules/isort/categorize.rs",
            "description": "This file is responsible for categorizing Python import statements into predefined or user-defined sections (e.g., standard library, third-party, first-party) within the `isort` rule for the Ruff linter. It provides functions to determine the appropriate section for a given module and to group a block of imports by their assigned section.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/src/rules/isort/sorting.rs",
            "description": "Defines data structures and logic for sorting import statements and their members according to `isort` rules. It generates comparable keys (`ModuleKey`, `MemberKey`) to determine the correct order based on type, length, and other criteria.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/isort/comments.rs",
            "description": "This file defines a `Comment` struct and a function to collect all comments within a specified text range, intended for use by the `isort` rule in the `ruff` linter for processing import blocks.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/isort/types.rs",
            "description": "This file defines data structures (structs, enums, and traits) for representing various types of Python import statements and their associated metadata, such as aliases, comments, and trailing commas. These types are used by the `isort` rule in the `ruff` linter to analyze and categorize imports.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/src/rules/isort/normalize.rs",
            "description": "This file contains the `normalize_imports` function, which processes a list of raw, annotated imports and organizes them into a structured `ImportBlock`. It applies sorting-related settings and preserves comments, preparing the imports for further formatting or ordering by the `isort` rule.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/isort/rules/mod.rs",
            "description": "This file serves as the module declaration for `isort` rules, re-exporting sub-modules that define specific rules for adding required imports and organizing existing imports.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/isort/rules/add_required_imports.rs",
            "description": "Implements a lint rule that identifies and automatically adds user-defined 'required imports' to the top of Python files. It checks if specified imports are missing and provides a fix to insert them.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/isort/rules/organize_imports.rs",
            "description": "This file implements the `isort` rule for organizing, de-duplicating, grouping, and sorting import statements in Python code within the Ruff linter. It detects unsorted or unformatted import blocks and provides a fix to reformat them according to specified settings.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/isort/snapshots",
            "description": "This directory stores snapshot test files for the `isort` linter rules within the `ruff_linter` crate. These snapshots capture expected outputs or behaviors, facilitating regression testing and ensuring consistent rule application. They are typically generated and updated by a testing framework.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/importer/mod.rs",
            "description": "This file defines a `Importer` struct and its methods for adding, modifying, and moving Python import statements within an AST, particularly for enforcing import-related rules and enabling automatic fixes.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/project/project/import_file.py",
            "description": "This file imports and utilizes functions/objects from external libraries like numpy and internal modules 'app' and 'core', likely serving as an integration test or example of module usage within the project.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_import_conventions/custom.py",
            "description": "This file serves as a test fixture for `flake8_import_conventions`, demonstrating various conventional and unconventional import aliases for common Python libraries to test linter rules.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_import_conventions/custom_banned_from.py",
            "description": "This file serves as a test fixture for the `flake8_import_conventions` linter, demonstrating examples of banned `from ... import ...` statements and acceptable `import ...` statements.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_import_conventions/custom_banned.py",
            "description": "This file is a test fixture for the `ruff_linter`'s `flake8_import_conventions` rule. It demonstrates custom banned and allowed import aliases for various modules like `typing`, `numpy`, `tensorflow`, and `torch`.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_import_conventions/defaults.py",
            "description": "This file serves as a test fixture for the `ruff` linter, demonstrating various import styles for common libraries, including unconventional and conventional aliases, to test import convention rules.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_import_conventions/override_default.py",
            "description": "This file is a test fixture for `flake8_import_conventions` in ruff_linter, demonstrating various import styles (conventional vs. unconventional aliases) for common libraries to test convention enforcement and overrides.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_import_conventions/tricky.py",
            "description": "This file contains test cases for the `flake8_import_conventions` linter, specifically examining its behavior with difficult global renames or import patterns.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_import_conventions/remove_default.py",
            "description": "This file is a test fixture for `flake8_import_conventions`, demonstrating and verifying the linting of conventional and unconventional import aliases for common Python libraries like altair, matplotlib, pandas, and seaborn.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_import_conventions/from_imports.py",
            "description": "This file serves as a test fixture for the 'flake8-import-conventions' linter, specifically testing its ICN001 rule regarding absolute and relative import aliasing. It includes examples that should trigger violations and examples that should pass, demonstrating the linter's behavior.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_import_conventions/same_name.py",
            "description": "Test cases for import convention linting, demonstrating imports where a module is aliased to its own name versus a different name.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_tidy_imports/TID253.py",
            "description": "This file serves as a test fixture for the `flake8-tidy-imports` linter rule TID253, demonstrating various module-level import patterns for 'banned' modules like `torch` and `tensorflow` to ensure correct linter detection.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_tidy_imports/TID252.py",
            "description": "This file serves as a test fixture for the `flake8_tidy_imports` linter plugin, specifically for rule `TID252`. It demonstrates various forms of relative imports, including deeply nested and syntactically varied ones, to ensure the linter correctly identifies and flags issues.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_tidy_imports/TID251.py",
            "description": "This file serves as a test fixture for the `ruff_linter`'s `flake8_tidy_imports` rule `TID251`. It demonstrates various scenarios of importing and accessing banned modules and module members to ensure the linter correctly identifies them.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_tidy_imports/TID/my_package/sublib/server",
            "description": "This directory provides a simulated Python package structure, specifically representing a 'server' module within 'my_package.sublib', used as a test fixture for the 'flake8_tidy_imports' linter rules in `ruff_linter`.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/isort/as_imports_comments.py",
            "description": "This file serves as a test fixture for `isort`, demonstrating how the linter handles various `from ... import (...)` statements, including 'as' aliases and inline comments within the import parentheses.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/isort/deduplicate_imports.py",
            "description": "This file is a test fixture for an 'isort' linter feature, demonstrating multiple import statements for the same module 'os' with and without aliases. It's likely used to test import deduplication logic.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/isort/force_sort_within_sections_future.py",
            "description": "This file is an `isort` test fixture for `ruff_linter`, specifically designed to test the sorting behavior of `__future__` imports within sections when `force_sort_within_sections` is enabled.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/isort/case_sensitive.py",
            "description": "This file serves as a test fixture for the `isort` functionality within the Ruff linter, specifically designed to evaluate its behavior when sorting import statements with varying case sensitivities.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/isort/bom_unsorted.py",
            "description": "This file is a test fixture for the ruff linter's isort functionality. It likely tests how the linter handles unsorted imports in a file potentially containing a Byte Order Mark (BOM).",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/isort/fit_line_length.py",
            "description": "This file is a test fixture for the 'isort' linter within the Ruff project, designed to evaluate its handling of import statements that exceed a specified line length, including cases with and without parentheses-based wrapping.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/isort/force_sort_within_sections_with_as_names.py",
            "description": "This file is an `isort` test fixture for Ruff, designed to verify the sorting behavior of import statements within sections, especially when `as` names are utilized.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/isort/bom_sorted.py",
            "description": "This file is a test fixture for the `ruff_linter`'s `isort` functionality, specifically to verify its behavior with a Python file containing a Byte Order Mark (BOM) and pre-sorted imports.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/isort/length_sort_from_imports.py",
            "description": "This file is a test fixture for ruff's isort integration, specifically designed to test sorting 'from import' statements based on the length of the imported module names.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/isort/length_sort_non_ascii_modules.py",
            "description": "This test fixture is used by Ruff's isort linter to verify sorting of module imports by length, including those with non-ASCII characters.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/isort/force_wrap_aliases.py",
            "description": "A test fixture for the `isort` linter, specifically demonstrating how aliased relative imports are handled.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/isort/import_from_after_import.py",
            "description": "This file is a test fixture for the ruff linter's isort functionality. It demonstrates a scenario where a 'from' import statement appears before a standard 'import' statement, likely to test sorting behavior.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/isort/force_sort_within_sections.py",
            "description": "This file is a test fixture demonstrating various import types, including absolute, aliased, star, and relative imports. It likely serves to test the `isort` or `ruff` sorting functionality.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/isort/combine_as_imports.py",
            "description": "This file serves as a test fixture for `ruff_linter`'s `isort` functionality, demonstrating how it handles combining multiple `from ... import ...` statements from the same module, including those with `as` aliases.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/isort/force_to_top.py",
            "description": "This file is a test fixture for the `ruff_linter`'s `isort` functionality, specifically designed to test how `isort` handles various import statements, likely in a scenario where certain imports are forced to the top.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/isort/length_sort_straight_and_from_imports.py",
            "description": "Tests `isort`'s ability to sort both straight and 'from' imports by length, ensuring correct ordering based on identifier length.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/isort/from_first.py",
            "description": "This file is an `isort` test fixture for `ruff_linter` demonstrating the correct placement of `from __future__` imports before other standard library imports.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/isort/line_ending_crlf.py",
            "description": "This file is a test fixture for Ruff's `isort` linter, specifically designed to test how long import lines are handled when the file uses CRLF line endings.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/isort/add_newline_before_comments.py",
            "description": "This file is a test fixture for the `ruff_linter`'s `isort` functionality. It demonstrates how newlines are added or not added before comments within import sections, validating specific formatting rules.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/isort/match_case.py",
            "description": "This file serves as a test fixture for the `isort` linter, demonstrating its behavior when sorting import statements nested within Python's `match-case` constructs.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/isort/length_sort_non_ascii_members.py",
            "description": "This file is a test fixture for Ruff's isort functionality, specifically demonstrating sorting of imported members by length, including non-ASCII characters.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/isort/forced_separate.py",
            "description": "This file is an `isort` test fixture demonstrating forced separation of first-party imports, specifically arranging 'tests' and 'experiments' modules in a predefined order.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/isort/future_from.py",
            "description": "This file serves as a test fixture for `ruff_linter`'s `isort` functionality, specifically demonstrating how it handles `__future__` imports, particularly `annotations`.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/isort/lines_after_imports_func_after.py",
            "description": "This file is a test fixture for the `isort` linter in Ruff, demonstrating the expected handling of blank lines between import statements and the subsequent function definition.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/isort/length_sort_with_star_import.py",
            "description": "Tests `ruff`'s `isort` import sorting behavior, specifically how it handles star imports and module name length ordering.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/isort/leading_prefix.py",
            "description": "This file is a test fixture for `ruff_linter`'s `isort` functionality, demonstrating its handling of import statements that are not at the beginning of a line, are preceded by other statements, or use line continuations.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/isort/isort_skip_file.py",
            "description": "This file is a test fixture for the `isort` linter in `ruff`, specifically demonstrating the effect of the `# isort: skip_file` directive, which prevents `isort` from reformatting imports within it. It also contains an `isort: split` directive within the skipped file.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/isort/insert_empty_lines.py",
            "description": "This file is a test fixture for the `isort` functionality within the `ruff_linter`, designed to test the insertion and placement of empty lines around imports, functions, and other code blocks.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/isort/default_section_user_defined.py",
            "description": "This file is a test fixture for the `isort` linter, demonstrating how it sorts a mix of standard, third-party, and local imports, likely in scenarios involving user-defined sections.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/isort/inline_comments.py",
            "description": "This file is a test fixture for the `isort` linter, demonstrating how it handles various `from ... import ...` statements with inline comments.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/isort/order_relative_imports_by_level.py",
            "description": "This file contains various relative import statements, serving as a test fixture to verify the correct sorting or ordering of such imports by tools like isort.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/isort/length_sort_with_relative_imports.py",
            "description": "This file is a test fixture for `ruff_linter`'s `isort` functionality. It specifically tests the sorting behavior of relative imports with varying path depths and module name lengths.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/isort/fit_line_length_comment.py",
            "description": "This test fixture for the `ruff_linter`'s `isort` functionality evaluates how different types of comments (standalone vs. inline) impact line length calculations for import statements, specifically testing line fitting behavior.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/isort/relative_imports_order.py",
            "description": "This file contains a series of relative imports at different levels, serving as a test fixture to verify the `isort` tool's handling and ordering of such imports.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/isort/star_before_others.py",
            "description": "This file is a test fixture for the 'isort' linter, specifically demonstrating imports where a wildcard import ('from .settings import *') appears before other named imports from the same module.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/isort/propagate_inline_comments.py",
            "description": "This file is an `isort` test fixture for `ruff_linter`, designed to verify how inline comments and long variable names within wrapped import statements are handled.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/isort/natural_order.py",
            "description": "This file is a test fixture for the ruff linter's `isort` functionality, specifically designed to test natural ordering of imports and multi-line `from ... import` statements.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/isort/no_lines_before_with_empty_sections.py",
            "description": "This file is a test fixture for the 'isort' linter, specifically designed to test import sorting behavior when no blank lines separate import sections, and some sections might be empty. It includes `__future__`, standard library, and relative imports.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/isort/preserve_indentation.py",
            "description": "Tests Ruff's `isort` linter to ensure it preserves the indentation of import statements within conditional blocks. It verifies that imports inside `if/else` statements maintain their original indent level after formatting.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/isort/preserve_tabs_2.py",
            "description": "This file is a test fixture for ruff's isort linter, demonstrating how it handles and preserves tab-indented, multi-line import statements.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/isort/preserve_tabs.py",
            "description": "This file serves as a test fixture for Ruff's isort functionality, specifically to verify that tab indentation is preserved when imports are sorted, even within nested blocks.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/isort/no_reorder_within_section.py",
            "description": "This file is a test fixture for ruff's isort functionality, demonstrating a scenario where imports within a section should not be reordered. It confirms that the linter correctly identifies this as an 'OK' state.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/isort/type_comments.py",
            "description": "This file is a test fixture for Ruff's isort linter, demonstrating how import statements with 'type: ignore' comments are handled.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/isort/reorder_within_section.py",
            "description": "This file is a test fixture for the ruff linter's isort functionality, specifically designed to test the reordering of imports within a section. It contains basic standard library imports.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/isort/split.py",
            "description": "This file is a test fixture for the ruff linter, specifically designed to test how `isort` handles multiple `isort: split` directives and conditional imports within a Python file.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/isort/order_by_type_with_custom_constants.py",
            "description": "This file is a test fixture for the `ruff_linter` project, specifically designed to evaluate `isort`'s import ordering capabilities when custom constants are present.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/isort/preserve_import_star.py",
            "description": "This file is a test fixture for Ruff's `isort` linter, designed to check if it correctly preserves the order and grouping of `import *` statements relative to other imports.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/isort/trailing_suffix.py",
            "description": "This file is an `isort` test fixture to check how the linter handles import statements with trailing code or semicolons on the same line, specifically in both global and indented blocks.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/isort/separate_future_imports.py",
            "description": "This file is a test fixture for `ruff_linter`'s `isort` functionality, specifically demonstrating how it handles separating future imports from standard library imports.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/isort/skip.py",
            "description": "This file serves as a test fixture for the `isort` linter, demonstrating various ways to disable or skip import sorting using `isort: off`, `isort: on`, and `isort: skip` comments.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/isort/unicode.py",
            "description": "This file is a test fixture for the 'isort' tool, demonstrating its ability to handle unicode characters used as aliases in import statements. It imports modules and assigns unicode aliases to them, then uses one of these aliases in a simple calculation.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/isort/sections.py",
            "description": "This file serves as a test fixture for ruff's `isort` functionality, demonstrating various import types and their expected sorting into different sections within a Python module.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/isort/lines_between_types.py",
            "description": "This file serves as a test fixture for Ruff's isort rule, demonstrating how it handles blank lines between different types of import statements (standard library, third-party, and local).",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/isort/ruff_skip_file.py",
            "description": "This file is a test fixture for the ruff linter, specifically demonstrating how it respects the 'isort: skip_file' directive, preventing import sorting from being applied to its contents.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/isort/order_by_type_with_custom_classes.py",
            "description": "This file serves as an `isort` test fixture, demonstrating import sorting behavior when dealing with various types of imported items, including custom classes, functions, and constants.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/isort/no_wrap_star.py",
            "description": "This file serves as a test fixture for the ruff linter's isort functionality. It specifically tests that a `from ... import *` statement with a long trailing comment is not wrapped.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/isort/trailing_comment.py",
            "description": "This file serves as a test fixture for the `ruff_linter`, specifically to evaluate its `isort` functionality's handling of various import statements with trailing and inline comments.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/isort/order_by_type_with_custom_variables.py",
            "description": "This file serves as a test fixture for `isort`, demonstrating how it handles import ordering for modules that include a mix of standard names and custom variables or constants, likely for type-based sorting.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/isort/separate_first_party_imports.py",
            "description": "This file serves as a test fixture for ruff's isort integration, demonstrating the expected sorting and separation of standard, third-party, and first-party imports.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/isort/lines_after_imports_nothing_after.py",
            "description": "This file is a test fixture for the `ruff_linter`'s `isort` rule, demonstrating a module with various import types followed by blank lines and no further code, used to test import sorting and line handling.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/isort/separate_local_folder_imports.py",
            "description": "This file is a test fixture for the `isort` functionality within `ruff_linter`, demonstrating how various import types, including local folder imports, are separated and ordered.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/isort/order_by_type.py",
            "description": "This file is a test fixture for ruff's `isort` functionality, demonstrating various import types and their expected ordering, including standard library, custom, and mixed-case imports.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/isort/main_first_party.py",
            "description": "This file is a test fixture for ruff_linter's `isort` functionality, demonstrating import sorting behavior with standard library, third-party, `__main__`, and first-party modules.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/isort/two_space.py",
            "description": "This file is a test fixture for the `isort` linter rule in Ruff. It verifies that two-space indentation within import statements is correctly detected and handled, even without other logical indent tokens.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/isort/sort_similar_imports.py",
            "description": "This file serves as a test fixture for the `isort` functionality within the `ruff_linter`. It specifically evaluates how similar imports from the same module, including those with different casing or aliases, are sorted and grouped.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/isort/no_sections.py",
            "description": "This file is a test fixture for the `isort` linter. It contains various import statements to test sorting behavior when no explicit import sections are defined, likely for a rule named 'no_sections'.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/isort/no_standard_library.py",
            "description": "This file is an `isort` test fixture for the `ruff` linter, designed to test import sorting rules. It contains a mix of standard library, third-party, and local imports, potentially simulating a scenario where standard library imports are not explicitly recognized or grouped by `isort`.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/isort/required_imports/docstring_future_import.py",
            "description": "This file is an `isort` test fixture to verify correct handling of a `from __future__ import annotations` import when it follows a docstring.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/isort/required_imports/docstring_with_multiple_continuations.py",
            "description": "This file is a test fixture for `isort` within the `ruff_linter` project, specifically designed to test how required imports are handled when a docstring ends with a backslash continuation before the main code block.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/isort/required_imports/existing_import.py",
            "description": "This file is a test fixture for Ruff's isort linter, demonstrating an existing Python file with `__future__` and standard library imports to test import sorting rules.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/isort/required_imports/docstring_with_semicolon.py",
            "description": "This file is a test fixture for `ruff`'s `isort` integration, specifically to verify its behavior with docstrings immediately followed by code on the same line, separated by a semicolon.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/isort/required_imports/docstring.py",
            "description": "This file serves as a test fixture for the ruff linter's isort functionality, specifically to test how required imports interact with Python files that begin with a docstring.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/isort/required_imports/future_import.py",
            "description": "This file is a test fixture for the `ruff_linter`'s `isort` functionality, specifically to test how it handles or orders a `from __future__ import annotations` statement.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/isort/required_imports/docstring_followed_by_continuation.py",
            "description": "Tests how ruff's isort functionality handles imports following a docstring immediately followed by a continuation line. This fixture is used to verify formatting or linting rules in such specific code structures.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/isort/required_imports/multiline_docstring.py",
            "description": "This file is a test fixture for the ruff linter's isort feature, specifically to test how required imports are handled with a multiline docstring.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/isort/required_imports/comment.py",
            "description": "This file is a test fixture for `ruff`'s `isort` linter, specifically designed for `required_imports` tests. It provides a minimal Python file with only a shebang and a variable assignment.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/isort/required_imports/docstring_with_continuation.py",
            "description": "This file is a test fixture for Ruff's `isort` rules, demonstrating how it handles a docstring immediately followed by code with a line continuation, specifically in the context of required imports.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/isort/required_imports/comments_and_newlines.py",
            "description": "This file is a test fixture for the `isort` linter, demonstrating its handling of comments, shebangs, and newlines in Python source code.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/isort/required_imports/multiple_strings.py",
            "description": "This file is a test fixture for the Ruff linter, specifically for `isort`'s `required_imports` feature, demonstrating how it handles multiple string literals at the top of a file, distinguishing them from the module docstring.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/isort/required_imports/whitespace.py",
            "description": "This file is a regression test for a `ruff` `isort` issue, specifically testing how a unicode formfeed character (`\\u000C`) embedded within a docstring is handled.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/isort/required_imports/docstring_only.py",
            "description": "This file is a test fixture for the `ruff_linter`'s `isort` plugin, designed to verify its behavior with Python files that contain only a docstring, ensuring no incorrect import modifications or errors occur.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/isort/required_imports/this_this.py",
            "description": "This file is an `isort` test fixture demonstrating an aliased import statement: `import this as this`.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/isort/required_imports/this_this_from.py",
            "description": "This is a test fixture for the `isort` linter, specifically designed to test handling of import statements where a module member is imported with an alias that is identical to its original name (`from module import this as this`). It likely verifies that `isort` correctly processes or ignores such redundant aliasing.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/isort/required_imports/off.py",
            "description": "This file is a test fixture for the Ruff linter, demonstrating the use of `isort: off` and `isort: on` directives to temporarily disable isort checks within a code block.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/isort/required_imports/plr0402_skips_required_import.py",
            "description": "This file is a test fixture for the ruff linter's isort functionality, specifically designed to test that rule plr0402 correctly skips flagging a 'required import'.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/isort/required_imports/unused.py",
            "description": "This file serves as a test fixture for the `ruff_linter`, specifically for `isort`'s handling of unused imports, differentiating between those explicitly marked as required and those not.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/isort/required_imports/plr0402_skip.py",
            "description": "This file is a test fixture for the `isort` linter within `ruff_linter`, specifically designed to test the `required_imports` functionality and how it interacts with or skips the `plr0402` rule. It contains a basic import statement to validate this test case.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/isort/detect_same_package/foo/bar.py",
            "description": "This file is a test fixture for `isort` within the `ruff` linter, specifically designed to test the detection and handling of imports from the same package ('foo'). It demonstrates importing an internal module `foo.baz` alongside standard libraries.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pycodestyle/E30_isort.py",
            "description": "This file is a test fixture for the ruff linter, likely used to evaluate its handling of import statements, blank lines (pycodestyle E30), and potentially `isort`-related issues in various code constructs.",
            "spof": true
          }
        ],
        "contributors": [
          {
            "name": "Dylan",
            "percent": 39
          },
          {
            "name": "Brent Westbrook",
            "percent": 14
          },
          {
            "name": "Charlie Marsh",
            "percent": 10
          }
        ]
      },
      "Security and Framework-Specific Rule Implementations": {
        "files": [
          {
            "path": "crates/ruff_linter/src/rules/flake8_bandit/helpers.rs",
            "description": "This file provides helper functions and constants for the `flake8_bandit` linter rules, including utilities for identifying potential password-related strings and checking for untyped exceptions.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_bandit/mod.rs",
            "description": "This file serves as the main module for integrating and testing the `flake8-bandit` rules within the Ruff linter, organizing rule implementations, helpers, settings, and comprehensive test cases for each rule.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_bandit/rules/hardcoded_bind_all_interfaces.rs",
            "description": "This file defines a linter rule (S104) for Ruff that identifies hardcoded bindings to '0.0.0.0' in Python code, which is considered a security vulnerability for binding to all network interfaces. It checks string literals and f-string parts for this specific value.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_bandit/rules/logging_config_insecure_listen.rs",
            "description": "This file implements a Ruff rule (S612) that detects insecure usage of `logging.config.listen` in Python code. It flags calls to `logging.config.listen` that lack a `verify` argument, as this function can execute arbitrary code.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_bandit/rules/assert_used.rs",
            "description": "This file implements a lint rule for `flake8_bandit` in Ruff, specifically `S101`, which detects and flags the use of the `assert` keyword in Python code. It advises against using `assert` for runtime validation due to its removal in optimized environments.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_bandit/rules/ssl_with_bad_defaults.rs",
            "description": "This file defines a lint rule (S503) that checks Python function definitions for default arguments specifying insecure SSL/TLS protocols.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_bandit/rules/paramiko_calls.rs",
            "description": "This file implements a linting rule for `ruff_linter` to detect potential shell injection vulnerabilities when using `paramiko.SSHClient.exec_command` in Python code. It flags calls to this function, advising users to sanitize inputs.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_bandit/rules/ssl_with_no_version.rs",
            "description": "Defines a lint rule (S504) for `flake8-bandit` that flags calls to `ssl.wrap_socket()` without an `ssl_version` argument, promoting secure TLS/SSL protocol usage.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_bandit/rules/exec_used.rs",
            "description": "This file defines a Ruff linter rule (S102) that detects the use of the `exec()` builtin function in Python code. It flags `exec` as a security vulnerability due to its ability to execute arbitrary code.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_bandit/rules/hardcoded_password_default.rs",
            "description": "Implements the `S107` rule for `flake8-bandit` to detect hardcoded password defaults in Python function arguments. It checks parameter names and string literal default values to identify potential security risks.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_bandit/rules/shell_injection.rs",
            "description": "This file defines the `flake8_bandit` rules in Ruff related to detecting potential shell injection vulnerabilities and other security risks associated with subprocess execution in Python code. It includes checks for using `shell=True`, starting processes without a shell, partial executable paths, and wildcard injections.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_bandit/rules/suspicious_function_call.rs",
            "description": "This file defines linting rules (violations) for detecting suspicious or insecure function calls in Python code, such as unsafe deserialization, weak cryptographic hashes/ciphers, and insecure temporary file creation.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_bandit/rules/django_raw_sql.rs",
            "description": "This file implements a linter rule (S611) that detects the use of Django's `RawSQL` function to prevent potential SQL injection vulnerabilities. It checks if `RawSQL` is called and flags non-literal `sql` arguments.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_bandit/rules/request_with_no_cert_validation.rs",
            "description": "This file implements a lint rule that detects Python `requests` or `httpx` calls where SSL certificate validation is explicitly disabled, flagging a potential security vulnerability.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_bandit/rules/hardcoded_password_string.rs",
            "description": "This file implements a linter rule (S105) for the `flake8_bandit` plugin that detects potential hardcoded passwords in string literals when they are assigned to or compared with variables or attributes named like passwords.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_bandit/rules/hardcoded_sql_expression.rs",
            "description": "Implements a lint rule (S608) that detects potential SQL injection vulnerabilities. It identifies hardcoded SQL expressions constructed using string formatting or concatenation in Python code.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_bandit/rules/bad_file_permissions.rs",
            "description": "This file implements a Ruff linter rule (S103) that detects and flags overly permissive or invalid file permissions set using `os.chmod` in Python code, particularly focusing on write-world and execute-group bits.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_bandit/rules/ssh_no_host_key_verification.rs",
            "description": "This file implements a lint rule (S507) for Ruff that detects insecure configurations in Paramiko SSH clients where host key verification is automatically added or warned against, rather than strictly rejected.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_bandit/rules/hardcoded_password_func_arg.rs",
            "description": "This file implements a `ruff` linter rule (S106) that detects hardcoded password values passed as function arguments. It flags potential security risks where sensitive credentials might be exposed directly in source code.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_bandit/rules/try_except_continue.rs",
            "description": "This file implements a linting rule (S112) for Ruff that detects the `try`-`except`-`continue` pattern in Python code, which can suppress exceptions and hide potential issues. It defines the `TryExceptContinue` violation and provides the logic to identify instances of this pattern.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_bandit/rules/hashlib_insecure_hash_functions.rs",
            "description": "Implements a linting rule (S324) for Ruff that detects the use of insecure cryptographic hash functions from Python's `hashlib` and `crypt` modules. It identifies weak algorithms like MD4, MD5, SHA, and SHA1, flagging them as potential security vulnerabilities.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_bandit/rules/snmp_insecure_version.rs",
            "description": "Implements a lint rule (S508) for Ruff to detect the use of insecure SNMPv1 or SNMPv2 configurations within Python code, specifically checking `pysnmp.hlapi.CommunityData` calls.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_bandit/rules/django_extra.rs",
            "description": "Implements a Ruff linting rule (S610) that detects potential SQL injection vulnerabilities in Django's `extra` function calls by identifying non-literal arguments in 'select', 'where', or 'tables' parameters.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_bandit/rules/suspicious_imports.rs",
            "description": "Defines rules and messages for detecting suspicious or insecure Python module imports, such as `telnetlib`, `ftplib`, `pickle`, `subprocess`, and various XML-related modules, as part of a static analysis linter.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_bandit/rules/mod.rs",
            "description": "This file serves as the module entry point for the `flake8_bandit` rules within the Ruff linter, aggregating and re-exporting individual security-related checks.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_bandit/rules/tarfile_unsafe_members.rs",
            "description": "This file implements a linting rule for Ruff (S202) that identifies potentially insecure uses of `tarfile.extractall()` in Python code. It flags instances where archives are extracted without appropriate filtering, which could lead to path traversal vulnerabilities.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_bandit/rules/ssl_insecure_version.rs",
            "description": "Detects and flags the use of insecure SSL/TLS protocol versions in Python code, specifically when configuring SSL contexts or wrapping sockets. It identifies outdated protocols like SSLv2, SSLv3, TLSv1, and TLSv1.1.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_bandit/rules/snmp_weak_cryptography.rs",
            "description": "This file implements a lint rule (`SnmpWeakCryptography`) for the `flake8_bandit` linter, which detects insecure usage of SNMPv3 without encryption by checking calls to `pysnmp.hlapi.UsmUserData` with insufficient arguments. It identifies potential vulnerabilities where SNMPv3 communication could be intercepted due to a lack of authentication and privacy keys.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_bandit/rules/try_except_pass.rs",
            "description": "Implements a linting rule (S110) for the `flake8-bandit` checker in Ruff, specifically identifying `try`-`except`-`pass` statements. It flags these constructs as potential issues that should instead log exceptions.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_bandit/rules/jinja2_autoescape_false.rs",
            "description": "This file defines a linter rule for Ruff that detects potential cross-site scripting (XSS) vulnerabilities in Jinja2 templates. It specifically flags cases where `autoescape=False` is used or implicitly set, which can expose applications to XSS attacks.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_bandit/rules/weak_cryptographic_key.rs",
            "description": "Implements a `ruff` lint rule (S505) that detects and reports the use of cryptographically weak keys, such as those with insufficient key sizes for DSA/RSA or vulnerable EC curves.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_bandit/rules/unsafe_yaml_load.rs",
            "description": "This file implements a linting rule for the Ruff linter to detect and report the insecure use of `yaml.load` in Python code, recommending `yaml.safe_load` instead.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_bandit/rules/unsafe_markup_use.rs",
            "description": "This file implements a linting rule (S704) for Ruff's `flake8-bandit` plugin that detects unsafe uses of `markupsafe.Markup` and similar functions. It flags instances where non-literal strings (e.g., f-strings, variables) are passed as arguments, which could lead to cross-site scripting (XSS) vulnerabilities.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_bandit/snapshots",
            "description": "This directory stores snapshot test files for the `flake8_bandit` rules within the `ruff_linter` crate. These snapshots are used to verify the expected behavior and output of the linter rules against recorded baselines during testing.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/airflow/mod.rs",
            "description": "This file defines the Airflow-specific linting rules module for Ruff. It declares sub-modules for helpers and rule implementations, and contains comprehensive test cases for various Airflow-related diagnostics.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/src/rules/airflow/helpers.rs",
            "description": "This file contains helper functions and data structures used by Ruff's Airflow linter rules to identify deprecated or internal Airflow API usage and generate corresponding fixes. It provides utilities for analyzing Python ASTs for specific Airflow patterns and constructing code edits.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/airflow/rules/suggested_to_update_3_0.rs",
            "description": "This file implements a Ruff rule (AIR311) that checks for and suggests updates to deprecated Airflow functions, arguments, and values that are scheduled for removal in Airflow 3.0 or later versions, offering replacements where available.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/airflow/rules/moved_to_provider_in_3.rs",
            "description": "This file implements a linting rule for Airflow that detects and suggests fixes for functions and values moved to provider packages in Airflow 3.0, guiding users to install the correct provider and update their import paths.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/src/rules/airflow/rules/mod.rs",
            "description": "This Rust `mod.rs` file aggregates and re-exports various rule definitions related to Airflow, likely for linting purposes. It serves as a central point to make these Airflow-specific rules accessible within the `ruff_linter` crate.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/airflow/rules/task_variable_name.rs",
            "description": "This file implements a linting rule for Airflow, specifically checking that the variable name assigned to an Airflow operator matches its `task_id` value for consistency.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/airflow/rules/dag_schedule_argument.rs",
            "description": "This file implements a Ruff linter rule (AIR002) that checks Airflow DAG definitions for the explicit presence of a `schedule` or `schedule_interval` argument. It aims to prevent unintended daily scheduling due to implicit defaults.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/airflow/rules/moved_in_3_1.rs",
            "description": "Implements a linter rule for Ruff to detect and suggest fixes for Airflow functions and values that were moved or deprecated in Airflow 3.1, primarily by updating import paths. It identifies specific moved components and generates diagnostics with suggested code modifications.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/src/rules/airflow/rules/function_signature_change_in_3.rs",
            "description": "This file implements Ruff linting rules to identify Airflow function calls and method definitions that use outdated signatures, which are incompatible with Airflow 3.0 and would lead to runtime errors. It checks for changes like positional-only arguments, parameter reordering, and type changes in Airflow-specific functions.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/src/rules/airflow/rules/removal_in_3.rs",
            "description": "This file implements a linter rule (AIR301) to detect and suggest fixes for deprecated Airflow functions, arguments, and attributes that have been removed in Airflow 3.0.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/airflow/rules/suggested_to_move_to_provider_in_3.rs",
            "description": "This file implements a Ruff linter rule (AIR312) that detects uses of Airflow components (hooks, operators, sensors) that have been moved to dedicated provider packages in Airflow 3.0, but still have a compatibility layer. It suggests migrating to the new provider-specific imports to avoid future deprecation.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/airflow/snapshots",
            "description": "This directory is intended to store snapshot test data for the `airflow` rules within the `ruff_linter` crate. Snapshot tests capture expected outputs to ensure rule consistency and prevent regressions. Although currently empty, it would typically contain `.snap` files defining the expected behavior of these rules.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_django/helpers.rs",
            "description": "This file provides helper functions for identifying and analyzing Django models, model forms, and model fields within Python abstract syntax trees. It uses semantic analysis to determine if a class or expression corresponds to a specific Django construct.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_django/mod.rs",
            "description": "This file serves as the main module for integrating `flake8-django` rules into the Ruff linter. It defines the module structure for helpers and rules, and includes unit tests for these Django-specific linting rules.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_django/rules/non_leading_receiver_decorator.rs",
            "description": "Implements a lint rule (DJ013) that checks for and flags Django's `@receiver` decorator when it is not the first decorator applied to a function. This ensures proper signal connection in Django applications.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_django/rules/mod.rs",
            "description": "Aggregates and re-exports all individual linting rules for the Flake8-Django plugin within the Ruff linter.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_django/rules/exclude_with_model_form.rs",
            "description": "This file implements a lint rule (DJ006) for Ruff that detects and flags the use of `exclude` within Django `ModelForm` Meta classes, recommending `fields` instead. It helps prevent unintended exposure of model fields by enforcing a safer form definition pattern.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_django/rules/all_with_model_form.rs",
            "description": "Implements a Ruff linter rule (DJ007) that flags the use of `fields = \"__all__\"` within Django `ModelForm` Meta classes to prevent unintended exposure of model fields.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_django/rules/nullable_model_string_field.rs",
            "description": "This file implements a Ruff lint rule (DJ001) that flags string-based Django model fields (e.g., `CharField`, `TextField`) which are defined with `null=True`, recommending the use of empty strings instead of `None`.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_django/rules/unordered_body_content_in_model.rs",
            "description": "Implements a linting rule for Ruff that checks and enforces the specified order of inner classes, methods, and fields within Django model definitions according to the Django Style Guide.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_django/snapshots",
            "description": "This directory stores snapshot test files specifically for the `flake8_django` linting rules within the `ruff_linter` crate. These snapshots are used to validate the expected output and behavior of these rules, ensuring consistency and preventing regressions during development.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_pytest_style/types.rs",
            "description": "This file defines Rust enums used to configure the expected formatting types (e.g., tuple, list, CSV) for parameter names, values, and value rows in pytest parametrization, specifically for the `flake8-pytest-style` linter.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_pytest_style/settings.rs",
            "description": "This file defines the configuration settings for the `flake8-pytest-style` linter rules within Ruff, including default values, data structures, and associated error types.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_pytest_style/mod.rs",
            "description": "This module defines and integrates the rules from the `flake8-pytest-style` linter into Ruff, and includes comprehensive test cases for each of these rules.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_pytest_style/helpers.rs",
            "description": "This file contains helper functions for `flake8_pytest_style` rules, providing utilities to identify Pytest-specific constructs like markers, fixtures, and test functions, and to analyze string expressions related to Pytest arguments.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_pytest_style/rules/fail.rs",
            "description": "This file implements a linting rule (PT016) for `ruff` that identifies and flags `pytest.fail()` calls made without an explicit message, promoting better test failure debugging. It defines the violation, its message, and the logic to detect these cases within Python abstract syntax trees.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_pytest_style/rules/imports.rs",
            "description": "This file implements a linting rule (PT013) for the ruff linter that checks for and flags incorrect ways of importing the `pytest` library, enforcing `import pytest` for consistency.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_pytest_style/rules/unittest_assert.rs",
            "description": "Defines an enum representing various `unittest` assertion methods in Python and provides utilities for converting between their string representations and the enum variants. It also includes helper functions for constructing AST nodes for comparisons and assertions, likely for a linter or code transformation tool.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_pytest_style/rules/mod.rs",
            "description": "This file acts as the main module for the `flake8_pytest_style` rules, aggregating and re-exporting all sub-modules that define individual linting rules related to pytest style.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_pytest_style/rules/marks.rs",
            "description": "This file implements linting rules for `pytest.mark` decorators, checking for incorrect parentheses usage in argument-free marks and for useless `pytest.mark.usefixtures` decorators without parameters.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_pytest_style/rules/parametrize.rs",
            "description": "This file implements various linting rules for the `pytest.mark.parametrize` decorator, checking for incorrect argument types, duplicate test cases, and stylistic inconsistencies in parameter names and values. It defines violations and their corresponding fix messages for `flake8-pytest-style` checks related to `parametrize`.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_pytest_style/rules/test_functions.rs",
            "description": "Implements the `PT028` rule from `flake8-pytest-style`, which identifies and flags test function parameters that have default arguments, as these can lead to unexpected behavior in pytest.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_pytest_style/rules/raises.rs",
            "description": "Implements linting rules for `pytest.raises` usage within the `flake8-pytest-style` plugin of the Ruff linter, addressing issues like overly broad exceptions, missing exception arguments, and complex `pytest.raises` context manager blocks.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_pytest_style/rules/fixture.rs",
            "description": "This file defines various linting rules and their associated metadata for `pytest` fixtures, checking for common issues and stylistic preferences related to `@pytest.fixture` decorators within the `ruff` linter.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_pytest_style/rules/warns.rs",
            "description": "This file implements several linting rules for `pytest.warns` usage within the `flake8-pytest-style` plugin for Ruff, detecting issues such as missing expected warnings, overly broad warning catches, and complex `pytest.warns` context manager bodies.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_pytest_style/rules/patch.rs",
            "description": "This file implements a `ruff` linter rule (PT008) that detects and flags the use of `lambda` functions in `mocker.patch` or `unittest.mock.patch` calls when `return_value` would be more appropriate, specifically when the lambda's arguments are not utilized.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_pytest_style/rules/assertion.rs",
            "description": "This file implements various linting rules for `flake8-pytest-style` within the `ruff` linter, focusing on enforcing idiomatic assertion practices for `pytest` tests.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/flake8_pytest_style/snapshots",
            "description": "This directory is intended to store 'snapshots' for the `flake8_pytest_style` rules within the `ruff_linter` crate. These snapshots would typically be used in testing to compare current outputs against expected, pre-recorded results. Its current emptiness might indicate that snapshot tests for these rules are not yet implemented or stored elsewhere.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/fastapi/mod.rs",
            "description": "This file defines the `fastapi` module for the `ruff_linter`, containing FastAPI-specific linting rules. It also includes comprehensive unit tests for these rules, covering various scenarios and Python versions.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/src/rules/fastapi/rules/fastapi_non_annotated_dependency.rs",
            "description": "This file implements a Ruff lint rule (FAST002) that identifies and suggests fixes for FastAPI route dependencies not using `typing.Annotated` for clarity and consistency. It aims to migrate `Depends`, `Query`, and similar parameters to the `Annotated` syntax.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/fastapi/rules/fastapi_unused_path_parameter.rs",
            "description": "This file implements a linting rule (FAST003) that identifies FastAPI routes where path parameters declared in the route path are not present in the corresponding function's signature.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/fastapi/rules/mod.rs",
            "description": "This file serves as the module declaration for FastAPI-related linting rules, importing and defining common utilities to identify FastAPI routes within a Python abstract syntax tree.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/fastapi/rules/fastapi_redundant_response_model.rs",
            "description": "This file implements a Ruff linting rule (FAST001) that identifies and flags redundant `response_model` arguments in FastAPI route decorators when they explicitly match the function's inferred return type.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/fastapi/snapshots",
            "description": "This directory is intended to store snapshot test files for the `ruff` linter rules that are specifically designed for the `fastapi` framework. These snapshots help ensure the consistent output and behavior of the linter's diagnostics during development and testing.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/numpy/helpers.rs",
            "description": "This file provides AST visitor utilities for the Ruff linter, specifically for detecting the presence of certain import statements or attribute usages within the code. It includes `ImportSearcher` to find specific `import from` statements and `AttributeSearcher` to locate qualified attribute expressions.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/src/rules/numpy/mod.rs",
            "description": "This module serves as the main entry point for NumPy-specific linting rules within the Ruff linter, organizing helper functions, rule implementations, and their corresponding unit tests.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/src/rules/numpy/rules/deprecated_type_alias.rs",
            "description": "This file defines a lint rule (`NPY001`) that detects and fixes deprecated NumPy type aliases (e.g., `np.int`, `np.float`), suggesting replacement with their equivalent built-in Python types.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/numpy/rules/deprecated_function.rs",
            "description": "This file implements a Ruff rule to detect and fix deprecated NumPy functions, such as replacing `np.alltrue` with `np.all`. It provides a diagnostic message and an automatic code fix for these instances.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/numpy/rules/numpy_2_0_deprecation.rs",
            "description": "This file implements a Ruff rule (NPY201) that detects and suggests fixes for NumPy functions and constants that have been removed or changed in NumPy 2.0. It helps migrate code to be compatible with the new NumPy API.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/numpy/rules/legacy_random.rs",
            "description": "This file implements a Ruff lint rule (NPY002) that detects and reports the use of legacy NumPy random number generation functions, suggesting a switch to `np.random.Generator` for improved performance and statistical properties.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/numpy/rules/mod.rs",
            "description": "This file serves as the module entry point for a collection of Ruff linter rules. It re-exports sub-modules that define rules for detecting deprecated functions, type aliases, legacy random number generation, and other NumPy 2.0 deprecations.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/src/rules/numpy/snapshots",
            "description": "This directory stores snapshot test data for the NumPy linting rules within the `ruff_linter` crate. These snapshots capture expected outputs or behaviors, ensuring that linter rule changes do not introduce regressions.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/ruff/rules/legacy_form_pytest_raises.rs",
            "description": "This Rust file implements a linter rule (RUF061) for the `ruff` project that detects and fixes legacy, non-context-manager usages of `pytest.raises`, `pytest.warns`, and `pytest.deprecated_call` by converting them to their context-manager form.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/src/rules/ruff/rules/pytest_raises_ambiguous_pattern.rs",
            "description": "Implements a Ruff linter rule (`RUF043`) that detects ambiguous regex patterns in the `match` argument of `pytest.raises()` calls, specifically when a non-raw string contains unescaped regex metacharacters.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/src/rules/ruff/rules/unsafe_markup_use.rs",
            "description": "This file defines a linter rule (`RuffUnsafeMarkupUse`) for Ruff that detects and flags unsafe uses of `markupsafe.Markup` (and similar objects) to prevent potential XSS vulnerabilities in Python code. It provides context, examples, and configuration options for the rule.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/src/rules/pygrep_hooks/mod.rs",
            "description": "This file defines the `pygrep_hooks` module within the Ruff linter, primarily containing test cases for the rules implemented from the `pre-commit/pygrep-hooks` project.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pygrep_hooks/rules/no_eval.rs",
            "description": "Defines a linting rule (PGH001) that flags the use of the `eval()` function due to security concerns, though it has been removed in favor of rule S307.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pandas_vet/mod.rs",
            "description": "This file acts as the root module for the `pandas-vet` rules within the Ruff linter, defining and aggregating the various pandas-specific linting rules and their associated tests. It ensures the correct detection of anti-patterns and potential issues in Python code using the pandas library.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pandas_vet/helpers.rs",
            "description": "This file provides utility functions for the `pandas_vet` linter rules, determining the relevance of Python expressions in the context of Pandas operations. It classifies expressions based on whether they resolve to a local variable, the `pandas` module itself, or an irrelevant type.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pandas_vet/rules/pd_merge.rs",
            "description": "Implements a lint rule (PD015) for Ruff's `pandas_vet` linter that checks for the use of `pd.merge` and suggests replacing it with the `.merge` method for better idiomatic Pandas code.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pandas_vet/rules/assignment_to_df.rs",
            "description": "This file defines a linter rule (PD901) for `ruff` that identifies assignments to the generic variable name `df` in Python code, although the rule has since been removed for being too opinionated.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pandas_vet/rules/mod.rs",
            "description": "This `mod.rs` file serves as the central aggregator for all individual linting rules within the `pandas_vet` rule set, making them publicly accessible within the crate.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pandas_vet/rules/nunique_constant_series_check.rs",
            "description": "Implements a linting rule to detect and flag inefficient uses of `series.nunique()` in Pandas code when checking if a series is constant. It provides an optimization suggestion for this specific pattern.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pandas_vet/rules/inplace_argument.rs",
            "description": "This file implements a Ruff rule (PD002) that detects and suggests fixes for the use of `inplace=True` in pandas function and method calls. It identifies common pandas methods that accept an `inplace` argument and provides a refactoring to assign the result to a variable instead.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pandas_vet/rules/attr.rs",
            "description": "This file implements a Ruff linter rule (PD011) that identifies and flags the use of the ambiguous `.values` attribute on Pandas Series and Index objects, recommending `.to_numpy()` or `.array` instead.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pandas_vet/rules/read_table.rs",
            "description": "This file defines a linting rule for the Ruff linter that identifies and flags the use of `pandas.read_table` with a comma separator, suggesting `pandas.read_csv` as a more idiomatic alternative for reading CSV files.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pandas_vet/rules/call.rs",
            "description": "This file implements a set of linting rules for the `ruff` linter's `pandas_vet` plugin, specifically checking for and flagging less-preferred Pandas method calls like `.isnull`, `.notnull`, `.pivot`, `.unstack`, and `.stack`.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/src/rules/pandas_vet/rules/subscript.rs",
            "description": "This file implements linter rules for `pandas_vet` that detect and flag the use of deprecated or less idiomatic Pandas indexing methods (`.ix`, `.at`, `.iat`). It suggests using `.loc`, `.iloc`, or NumPy alternatives for better clarity and performance.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/src/rules/pandas_vet/snapshots",
            "description": "This directory is intended to store test snapshots for the `pandas_vet` rules within the `ruff_linter` crate. Snapshots typically capture expected diagnostic messages or autofix outputs to ensure rule behavior remains consistent across changes.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/airflow/AIR302_docker.py",
            "description": "This file is a test fixture for Ruff's Airflow linter, specifically for rule AIR302. It demonstrates the usage and instantiation of Airflow's DockerHook and DockerOperator components.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/airflow/AIR002.py",
            "description": "This file contains various Apache Airflow DAG definitions, demonstrating different ways to specify scheduling parameters using both the DAG class and the @dag decorator. It appears to be a test fixture for validating Airflow DAG schedule configurations.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/airflow/AIR302_samba.py",
            "description": "This file is an Airflow test fixture for the Ruff linter, demonstrating the usage or a specific rule related to the `SambaHook`.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/airflow/AIR302_hive.py",
            "description": "This file is an Airflow test fixture demonstrating the usage and instantiation of various operators, hooks, and sensors that interact with Hive, MySQL, MSSQL, and S3.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/airflow/AIR302_daskexecutor.py",
            "description": "This file is a test fixture for the ruff linter, demonstrating the usage of `DaskExecutor` from Airflow. It is likely used to test or validate a specific linting rule related to Airflow executors.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/airflow/AIR302_oracle.py",
            "description": "This file is a test fixture for the 'AIR302' rule in ruff_linter, specifically demonstrating the usage of `OracleHook` from Airflow.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/airflow/AIR301_airflow_plugin.py",
            "description": "This file defines an `AirflowPlugin` class, `AirflowTestPlugin`, which serves as a test fixture for a linter rule (AIR301) to identify invalid extension declarations within an Airflow plugin.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/airflow/AIR302_pig.py",
            "description": "This file is an Airflow test fixture for the ruff linter's AIR302 rule. It demonstrates the usage of `PigCliHook` and `PigOperator` from Airflow.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/airflow/AIR311_args.py",
            "description": "This file serves as a test fixture for the Airflow linter, demonstrating various usages of `sla_miss_callback` in DAG definitions and `sla` in operators.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/airflow/AIR301_names_try.py",
            "description": "This is an Airflow test fixture that demonstrates conditional imports of `AssetManager` from different Airflow paths, handling `ModuleNotFoundError` for compatibility or testing purposes. It then instantiates the imported class.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/airflow/AIR301_provider_names_fix.py",
            "description": "This file serves as a test fixture or example demonstrating the usage of dataset-related functions across various Apache Airflow providers, including AWS, OpenLineage, Common IO, and Google Cloud. It specifically focuses on dataset creation and conversion to OpenLineage format.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/airflow/AIR302_try.py",
            "description": "This file is a test fixture for the Ruff linter, demonstrating a conditional import of Airflow's HttpOperator using a try-except block to handle potential ModuleNotFoundError, likely for compatibility between different Airflow versions or provider installations.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/airflow/AIR301_names.py",
            "description": "This file serves as a test fixture for a linter, specifically designed to demonstrate the import and usage of various Airflow components. It is used to test rules related to Airflow names (e.g., AIR301) by importing and referencing a wide range of objects from different Airflow modules.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/airflow/AIR302_papermill.py",
            "description": "This file is a test fixture for the Ruff linter, demonstrating the usage of Airflow's `PapermillOperator`.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/airflow/AIR301_names_fix.py",
            "description": "This file is an Airflow test fixture for the ruff linter, demonstrating imports and usage of various Airflow components to test linter rules, possibly related to name resolution or fixes.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/airflow/AIR302_presto.py",
            "description": "This file serves as a test fixture for the Airflow linter, specifically demonstrating the use of `PrestoHook` for a rule like AIR302.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/airflow/AIR302_celery.py",
            "description": "This file is a test fixture for the `AIR302` linter rule, demonstrating the import and usage of Airflow's Celery-related components like `DEFAULT_CELERY_CONFIG`, `app`, and `CeleryExecutor`.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/airflow/AIR302_sqlite.py",
            "description": "This file is a test fixture for the `ruff_linter` tool, demonstrating the usage of `airflow.hooks.sqlite_hook.SqliteHook`. It likely tests a specific linting rule (AIR302) related to Airflow's SQLite hook.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/airflow/AIR302_http.py",
            "description": "This file imports and instantiates Airflow HTTP-related components like HttpHook, SimpleHttpOperator, and HttpSensor. It serves as a test fixture for the Ruff linter, likely to check for specific linting rules related to these Airflow classes.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/airflow/AIR302_standard.py",
            "description": "This file is a test fixture for the Ruff linter rule AIR302, demonstrating the usage of various Airflow operators, sensors, and hooks to test for potential deprecation warnings or compatibility issues.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/airflow/AIR302_hdfs.py",
            "description": "This file is an Airflow test fixture, demonstrating the usage of `WebHDFSHook` and `WebHdfsSensor` for HDFS interactions within an Airflow context. It likely serves as a test case for a linter rule related to Airflow best practices or common issues.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/airflow/AIR302_amazon.py",
            "description": "This file tests or demonstrates the usage of various Apache Airflow operators and hooks for interacting with Amazon S3, Google Cloud Storage, Redshift, and Google APIs, primarily for data transfer.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/airflow/AIR302_slack.py",
            "description": "This file is a test fixture for the Ruff linter, demonstrating the instantiation of Airflow's Slack-related hooks and operators.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/airflow/AIR312.py",
            "description": "This file is a test fixture for the Ruff linter (AIR312) that imports and instantiates a wide variety of Airflow hooks, operators, sensors, and triggers to demonstrate their usage.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/airflow/AIR302_jdbc.py",
            "description": "This file is a test fixture for the Ruff linter, specifically for an Airflow rule (AIR302) related to JDBC usage. It demonstrates direct instantiation of `JdbcHook` and `jaydebeapi` from the `airflow.hooks.jdbc_hook`.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/airflow/AIR301_class_attribute.py",
            "description": "This file serves as a test fixture for the `ruff` linter rule `AIR301`, demonstrating the correct usage and access patterns for various Airflow classes, their attributes, and methods across different Airflow modules.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/airflow/AIR302_common_sql.py",
            "description": "This file serves as a test fixture for various Airflow SQL-related operators, hooks, and sensors. It imports and instantiates multiple components to demonstrate their usage or test their availability.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/airflow/AIR302_postgres.py",
            "description": "This file serves as a test fixture for the Ruff linter, demonstrating the usage of `PostgresHook` and `Mapping` from Airflow. It is likely used to test a specific linter rule (AIR302) related to Airflow's PostgreSQL integration.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/airflow/AIR302_fab.py",
            "description": "This file serves as a test fixture for the Ruff linter, demonstrating imports and usage of various Airflow authentication backends and security managers, particularly those related to Flask-AppBuilder (FAB) integration.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/airflow/AIR312_try.py",
            "description": "This file tests or demonstrates the flexible import of `FileTrigger` from Airflow, handling different provider module paths for compatibility, and then instantiates it.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/airflow/AIR321_names.py",
            "description": "This file is a test fixture for the ruff linter, demonstrating imports and usage of various classes, functions, and constants from multiple Airflow modules (e.g., utils, models, macros, hooks, secrets, io).",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/airflow/AIR001.py",
            "description": "This file serves as a test fixture for the `ruff` linter's `AIR001` rule, demonstrating incorrect instantiations of Airflow operators that are missing a required `callable` argument.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/airflow/AIR301_context.py",
            "description": "This file serves as a test fixture for an Airflow linter rule (AIR301), demonstrating various scenarios of accessing both valid and deprecated Airflow context variables within tasks, operators, and custom plugins.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/airflow/AIR302_kubernetes.py",
            "description": "This file serves as a test fixture for an Airflow linter rule (AIR302) related to Kubernetes. It imports and instantiates/calls various Kubernetes-related classes and functions from Airflow's internal modules to test their availability and basic usage.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/airflow/AIR302_smtp.py",
            "description": "This file is a test fixture for the Ruff linter, demonstrating different import paths for Airflow's `EmailOperator`. It likely checks for issues related to the `AIR302` rule, possibly involving deprecated modules or SMTP usage.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/airflow/AIR311_try.py",
            "description": "This file serves as a test fixture for the Ruff linter, specifically for rule AIR311, demonstrating conditional imports of the `Asset` class within an Airflow context.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/airflow/AIR303.py",
            "description": "This file serves as a test fixture for the Ruff linter, demonstrating various valid and invalid usages of Airflow APIs, including `HookLineageCollector.create_asset`, `Dataset` and `Asset` instantiation, and `BaseOperatorLink.get_link` method signatures. It tests scenarios related to argument handling and API deprecations.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/airflow/AIR302_mysql.py",
            "description": "This file serves as a test fixture for the ruff linter, demonstrating the instantiation of Airflow's MySqlHook and related Presto-to-MySql operators. It's likely used to validate a linter rule (AIR302) concerning these Airflow components.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/airflow/AIR302_zendesk.py",
            "description": "This file serves as a test fixture for the `ruff` linter, specifically for the `AIR302` rule related to Airflow. It demonstrates the instantiation of `ZendeskHook` from `airflow.hooks.zendesk_hook`.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/airflow/AIR311_names.py",
            "description": "This file serves as a test fixture for the `ruff` linter's AIR311 rule, demonstrating various imports and usages of Airflow API components across different modules. It is used to validate the linter's detection capabilities for Airflow-related code patterns.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/airflow/AIR301_args.py",
            "description": "This file serves as a test fixture for the Ruff linter, showcasing various Airflow DAG and operator argument configurations. It demonstrates different ways to define DAGs and instantiate operators, likely for testing a specific linter rule (AIR301) related to Airflow argument usage.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/fastapi/FAST002_2.py",
            "description": "This file contains test fixtures for FastAPI routes, demonstrating how parameters with ellipses (`...`) as placeholders for required values are handled by ruff_linter, and how they should be transformed or preserved when actual default values are present.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/fastapi/FAST002_1.py",
            "description": "This file is a test fixture for the Ruff linter, specifically for rule `FAST002`. It demonstrates various FastAPI endpoints using `Query` parameters with different default value definitions, ensuring the linter does not suggest invalid `Annotated` fixes.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/fastapi/FAST001.py",
            "description": "This file serves as a test fixture for a linter, demonstrating various FastAPI route definitions. It includes examples of potential errors related to `response_model` and return type annotations, as well as correctly defined routes, to test a FastAPI-specific linter rule (likely FAST001).",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/fastapi/FAST002_0.py",
            "description": "This file is a test fixture for the Ruff linter's FAST002 rule, demonstrating various ways to define parameters in FastAPI endpoint functions. It includes examples categorized as fixable errors, non-fixable errors, unchanged, and correct usage for parameter handling.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/fastapi/FAST003.py",
            "description": "This file serves as a test fixture for the Ruff linter's FAST003 rule, demonstrating various valid and invalid FastAPI route definitions concerning path parameters and their corresponding handler function signatures.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_async/ASYNC105.py",
            "description": "This file is a test fixture for the Ruff linter, specifically designed to check the ASYNC105 rule related to `trio` functions that must be awaited. It demonstrates both correct (awaited) and incorrect (non-awaited) uses of `trio` asynchronous operations.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_async/ASYNC212.py",
            "description": "This file is a test fixture for the `ASYNC212` rule in `flake8_async`, demonstrating how synchronous `httpx.Client` method calls within an asynchronous function are flagged, while their synchronous counterparts or `httpx.AsyncClient` calls are not.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_async/ASYNC22x.py",
            "description": "This file serves as a test fixture for the `ruff` linter's `flake8_async` rules, demonstrating various `ASYNC22x` violations triggered by blocking `subprocess` and `os` calls within asynchronous functions.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_bandit/S103.py",
            "description": "This file contains test cases for Flake8 Bandit rule S103, demonstrating various `os.chmod` calls with different permission settings to trigger or bypass the insecure file permissions warning.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_bandit/S301.py",
            "description": "This file serves as a test fixture for the `flake8_bandit` S301 rule, demonstrating insecure deserialization using `pickle.loads()` and `pickle.load()`.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_bandit/S102.py",
            "description": "This file contains test cases for the `flake8-bandit` S102 rule (use of `exec`) within the Ruff linter. It demonstrates scenarios where `exec` calls should and should not trigger a linting error, including cases involving explicit imports from `builtins`.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_bandit/S201.py",
            "description": "This file contains test fixtures for the `flake8-bandit` S201 rule, demonstrating `app.run()` calls with and without the `debug` parameter to show expected linting errors and non-errors.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_bandit/S104.py",
            "description": "Test fixture for the `flake8-bandit` S104 rule, demonstrating various cases of hardcoded '0.0.0.0' IP addresses as string literals and function arguments, including both errors and allowed formats.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_bandit/S504.py",
            "description": "This file is a test fixture for the `flake8_bandit` rule S504 within the Ruff linter, demonstrating correct and incorrect usage of `ssl.wrap_socket` related to insecure SSL/TLS versions.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_bandit/S108.py",
            "description": "This file is a test fixture for the `flake8-bandit` linter (specifically rule S108), demonstrating various patterns of opening temporary files. It includes examples of both compliant and non-compliant code, as well as correct usage of the `tempfile` module.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_bandit/S401.py",
            "description": "This file serves as a test fixture for the `flake8_bandit` linter, specifically designed to trigger and verify the `S401` warning related to the import of the `telnetlib` module.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_bandit/S311.py",
            "description": "This file serves as a test fixture for the `flake8_bandit` S311 rule, demonstrating both correct and incorrect usages of the `random` module for linter detection.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_bandit/S110.py",
            "description": "This file serves as a test fixture for the `flake8_bandit` linter, specifically for rule `S110`. It contains various `try-except` blocks to test the detection of broad exception catching, including `Exception` and bare `except` statements.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_bandit/S106.py",
            "description": "This test fixture demonstrates the S106 rule of Flake8 Bandit, showcasing both valid and erroneous uses of hardcoded secrets or passwords passed as function arguments for linter testing.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_bandit/S101.py",
            "description": "This file serves as a test fixture for the `S101` rule of `flake8-bandit` within the `ruff` linter, demonstrating how it flags `assert` statements and ignores them within `TYPE_CHECKING` blocks.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_bandit/S402.py",
            "description": "This file serves as a test fixture for the Ruff linter, specifically designed to trigger and verify the `S402` rule from Flake8-Bandit, which warns about the use of the `ftplib` module.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_bandit/S308.py",
            "description": "Test fixture for the `flake8_bandit` S308 rule, demonstrating both vulnerable and safe uses of `django.utils.safestring.mark_safe` with various string formatting methods and direct injection.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_bandit/S307.py",
            "description": "This file serves as a test fixture for the Ruff linter, specifically for the Bandit S307 rule. It demonstrates various uses of `eval()`, including those that should trigger a warning and those that should be considered safe.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_bandit/S502.py",
            "description": "This file serves as a test fixture for the `flake8_bandit` linter, specifically for rule S502. It demonstrates both insecure and acceptable uses of SSL/TLS protocols with `wrap_socket` and `OpenSSL.SSL.Context` to test the linter's detection capabilities.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_bandit/S112.py",
            "description": "This file serves as a test fixture for the Ruff linter, demonstrating various `try...except` blocks with different exception types (including bare `except` and `except Exception`) to test the `flake8-bandit` rule S112.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_bandit/S404.py",
            "description": "This file is a test fixture for the Ruff linter, designed to trigger the S404 rule from Flake8 Bandit by demonstrating various ways to import the `subprocess` module, which is flagged for potential security concerns.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_bandit/S113.py",
            "description": "This file serves as a test fixture for the `S113` Bandit rule in the Ruff linter, demonstrating correct and incorrect usage of the `timeout` parameter in `requests` and `httpx` HTTP calls.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_bandit/S411.py",
            "description": "This file is a test fixture for the Ruff linter, designed to trigger and test the `flake8-bandit` rule S411, which warns against importing the `xmlrpc` module due to potential security vulnerabilities.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_bandit/S508.py",
            "description": "This file serves as a test fixture for the Flake8-Bandit linter, specifically for rule S508. It demonstrates various uses of `pysnmp.hlapi.CommunityData` to check for insecure `mpModel` values (0 or 1) and valid ones (2).",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_bandit/S415.py",
            "description": "This file serves as a test fixture for the Ruff linter, specifically designed to trigger and verify the 'S415' flake8-bandit rule related to importing the 'pyghmi' library.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_bandit/S410.py",
            "description": "This file serves as a test fixture for the Bandit `S410` rule, demonstrating imports of the `lxml` library. It is used to verify that the linter correctly identifies potential security vulnerabilities related to `lxml` usage.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_bandit/S403.py",
            "description": "This file serves as a test fixture for the Ruff linter's `flake8_bandit` rule S403, demonstrating various imports of modules known for insecure deserialization.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_bandit/S408.py",
            "description": "This file is a test fixture for the `ruff_linter`, designed to trigger and test the Flake8-Bandit rule S408, which flags insecure use of `xml.dom.minidom`.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_bandit/S324.py",
            "description": "This file serves as a test fixture for a linter, demonstrating both insecure and secure uses of hashing functions from the `hashlib` module and cryptographic functions from the `crypt` module to detect potential security vulnerabilities.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_bandit/S501.py",
            "description": "This file is a test fixture for the `flake8-bandit` linter (specifically rule S501), demonstrating various `requests` and `httpx` calls with both secure (`verify=True`) and insecure (`verify=False`) SSL certificate verification settings.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_bandit/S412.py",
            "description": "This file serves as a test fixture for the `flake8-bandit` linter, specifically to trigger and verify the 'S412: Use of CGI Script' rule. It demonstrates the flagging of `twisted.web.twcgi.CGIScript` import.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_bandit/S701.py",
            "description": "This file serves as a test fixture for the 'S701' linting rule, demonstrating various valid and invalid configurations of Jinja2 `Environment` autoescape settings.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_bandit/S601.py",
            "description": "This file is a test fixture for the `ruff` linter, specifically designed to trigger the `flake8_bandit` rule S601 by demonstrating an unsafe use of `paramiko.exec_command`.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_bandit/S105.py",
            "description": "This file serves as a test fixture for the `flake8-bandit` S105 rule within the Ruff linter, demonstrating various assignments and comparisons of hardcoded passwords and sensitive strings to check for correct detection and non-detection.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_bandit/S409.py",
            "description": "This file serves as a test fixture for the Ruff linter, specifically designed to trigger the `S409` rule from Bandit. It demonstrates insecure usage of `xml.dom.pulldom` for XML parsing, which the linter should flag.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_bandit/S413.py",
            "description": "This file serves as a test fixture for the Ruff linter, demonstrating code that triggers the flake8-bandit S413 rule due to the use of deprecated 'Crypto' (PyCrypto) imports.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_bandit/S406.py",
            "description": "This file is a test fixture for the Ruff linter, designed to trigger the S406 Bandit rule by importing `xml.sax` in various ways.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_bandit/S606.py",
            "description": "This file serves as a test fixture for the Bandit S606 rule, demonstrating various `os.exec*` and `os.spawn*` function calls that execute external programs.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_bandit/S312.py",
            "description": "This file is a test fixture for the ruff linter, demonstrating various references to `telnetlib.Telnet` to ensure the linter correctly identifies insecure uses or imports related to Bandit rule S312.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_bandit/S107.py",
            "description": "This file contains Python function definitions designed as test cases for the Bandit S107 rule, which detects hardcoded passwords as default arguments in function definitions. It showcases various parameter types (positional, keyword-only) and default values to test linter behavior.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_bandit/S607.py",
            "description": "This file serves as a test fixture for a linter, specifically to check the detection of insecure external command execution functions from modules like `os`, `subprocess`, `popen2`, and `commands`, including cases with full paths.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_bandit/S405.py",
            "description": "This file serves as a test fixture for the Ruff linter, demonstrating code patterns that should trigger a `S405` (XML parsing vulnerability) diagnostic from the Flake8 Bandit plugin.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_bandit/S202.py",
            "description": "This file serves as a test fixture for the `flake8_bandit` linter (S202 rule), demonstrating various ways to extract `tarfile` archives, including unsafe methods and methods that mitigate directory traversal vulnerabilities through `members` filtering or the `filter` argument.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_bandit/S506.py",
            "description": "Tests various `yaml.load` and `json.load` scenarios, demonstrating both potentially insecure and explicitly safe YAML deserialization practices for linter rule S506.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_bandit/S407.py",
            "description": "This file is a test fixture for the ruff linter, designed to verify its detection of Bandit rule S407. It demonstrates imports of `xml.dom.expatbuilder`, which is flagged as insecure.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_bandit/S704.py",
            "description": "This file contains test cases for the `flake8-bandit` S704 rule, demonstrating both true and false positives for detecting unsafe `Markup` or `flask.Markup` usage.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_bandit/S605.py",
            "description": "This file serves as a test fixture for the `flake8-bandit` linter, specifically demonstrating various methods of executing shell commands via `os`, `subprocess`, `commands`, and `popen2`.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_bandit/S611.py",
            "description": "This file serves as a test fixture for the Flake8 Bandit S611 rule, demonstrating various uses of `django.db.models.expressions.RawSQL` that could lead to SQL injection vulnerabilities.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_bandit/S602.py",
            "description": "This file serves as a test fixture for the Ruff linter's `flake8_bandit` rule `S602`. It demonstrates various usage patterns of `subprocess` functions with `shell=True` to ensure the linter correctly identifies potential security vulnerabilities.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_bandit/S310.py",
            "description": "This file serves as a comprehensive test fixture for the `ruff` linter, specifically to test the detection of various patterns and methods for calling `urllib.request` functions (like `urlopen`, `Request`, `URLopener().open`, and `urlretrieve`) under the Bandit S310 rule.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_bandit/S604.py",
            "description": "Test fixture for the `flake8-bandit` S604 rule, demonstrating various truthy but non-boolean values passed to a 'shell' argument in function calls.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_bandit/S507.py",
            "description": "This file is a test fixture for a linter, demonstrating the detection of insecure `paramiko.SSHClient` host key policies (S507). It shows examples of `set_missing_host_key_policy` calls that should trigger a linting error (e.g., using `AutoAddPolicy` or `WarningPolicy`) versus those that are considered acceptable.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_bandit/S503.py",
            "description": "This file serves as a test fixture for the Ruff linter, specifically to check the detection of insecure SSL/TLS protocol versions by the flake8-bandit rule S503. It includes examples of insecure protocol usages that should trigger a warning and one secure example that should not.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_bandit/S610.py",
            "description": "This file serves as a test fixture for a linter, demonstrating both insecure and secure usages of Django's `QuerySet.extra()` method for detecting potential SQL injection vulnerabilities (S610).",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_bandit/S603.py",
            "description": "This file is a test fixture for `flake8_bandit` rule S603, showcasing various `subprocess` calls to test detection of insecure command execution, particularly when untrusted input is used or `shell=True` might be implied.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_bandit/S704_extend_markup_names.py",
            "description": "This test fixture demonstrates the S704 Flake8 Bandit rule, showing how untrusted content passed to `markupsafe.Markup` or `webhelpers.html.literal` can lead to security vulnerabilities. It serves as a test case for detecting these insecure practices.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_bandit/S702.py",
            "description": "This file is a test fixture for the `flake8-bandit` linter, specifically for rule `S702`. It demonstrates various ways to import and instantiate `mako.template.Template`.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_bandit/S704_whitelisted_markup_calls.py",
            "description": "This file serves as a test fixture for the `flake8-bandit` S704 rule within `ruff_linter`, demonstrating the safe and potentially unsafe usage of `markupsafe.Markup` after sanitizing content with `bleach.clean`.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_bandit/S609.py",
            "description": "This file serves as a test fixture for a linter, demonstrating various unsafe command execution patterns using `os.popen`, `subprocess.Popen` with `shell=True`, and `os.system` for the `flake8-bandit` S609 rule.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_bandit/S612.py",
            "description": "This file demonstrates the usage of `logging.config.listen`. It likely serves as a test fixture for the `flake8_bandit` S612 rule, which identifies potential security issues with insecure logging configurations.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_bandit/S608.py",
            "description": "This file serves as a test fixture for the Ruff linter, specifically for the Bandit S608 rule, demonstrating various patterns of SQL query construction to identify potential SQL injection vulnerabilities.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_bandit/S505.py",
            "description": "This file serves as a test fixture for the Ruff linter, demonstrating correct and incorrect usages of cryptographic key generation functions with respect to key size requirements, specifically for Bandit rule S505 (insufficient key size).",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_bandit/S509.py",
            "description": "This file serves as a test fixture for the `flake8-bandit` S509 rule, demonstrating insecure and secure instantiations of `pysnmp.hlapi.UsmUserData` for linter testing.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_django/DJ007.py",
            "description": "This file serves as a test fixture for the `flake8-django` linter, specifically for rule DJ007, demonstrating various ways to define `Meta.fields` in Django `ModelForm` classes, including both valid and invalid usage.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_django/DJ006.py",
            "description": "Defines Django ModelForms used as test fixtures for the flake8-django DJ006 rule, demonstrating the use of 'exclude' and 'fields' in Meta classes.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_django/DJ008.py",
            "description": "This file serves as a test fixture for the Ruff linter rule DJ008, which detects Django models missing a __str__ method. It includes various model definitions, both abstract and concrete, with and without __str__ implementations, to test the rule's behavior.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_django/DJ013.py",
            "description": "Tests the `flake8_django` DJ013 rule regarding the correct and incorrect ordering of `@receiver` decorators relative to other decorators on Django signal handlers.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_django/DJ012.py",
            "description": "This file contains Django model definitions designed as test fixtures for the `flake8-django` DJ012 rule, showcasing various scenarios of member ordering within models (e.g., fields, methods, managers) to test linter behavior.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_django/DJ001.py",
            "description": "This file serves as a test fixture for the `flake8-django` DJ001 rule in the Ruff linter, showcasing Django model field definitions with both incorrect (missing `blank=True` when `null=True`) and correct usages of `null` and `blank` parameters.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_pytest_style/PT007.py",
            "description": "This file contains Pytest test fixtures demonstrating various uses and structures for `pytest.mark.parametrize` decorators, including single and multiple parameters, and different parameter value types like tuples and lists.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_pytest_style/PT002.py",
            "description": "This file contains pytest fixture definitions with various argument configurations, serving as test cases for the flake8-pytest-style linter's PT002 rule. It demonstrates both valid and invalid ways of passing arguments to `@pytest.fixture`.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_pytest_style/PT006_and_PT007.py",
            "description": "This file is a test fixture for `ruff_linter`'s `flake8_pytest_style` rules, specifically designed to verify that PT006 and PT007 do not conflict or produce false positives for a parametrized test.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_pytest_style/PT024.py",
            "description": "This file provides test cases for the `PT024` rule of `flake8-pytest-style`, demonstrating incorrect placement of `@pytest.mark.asyncio` before `@pytest.fixture` in asynchronous fixtures.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_pytest_style/PT014.py",
            "description": "Test fixtures for the `flake8-pytest-style` linter, specifically designed to trigger and demonstrate the PT014 error related to duplicate values in `pytest.mark.parametrize` arguments. It includes examples with literals, expressions, and different formatting.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_pytest_style/PT019.py",
            "description": "This file contains test cases for the `flake8-pytest-style` rule PT019, demonstrating valid and invalid usage of test function parameters, especially with `pytest.mark.parametrize`.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_pytest_style/PT003.py",
            "description": "This file contains pytest fixture definitions designed as test cases for the `flake8-pytest-style` linter rule `PT003`. It demonstrates both correct and incorrect usages of `scope=\"function\"` in `@pytest.fixture` decorators.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_pytest_style/PT016.py",
            "description": "This file contains test cases for the `PT016` rule of the `flake8-pytest-style` linter, demonstrating correct and incorrect usages of `pytest.fail` without a message.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_pytest_style/PT022.py",
            "description": "This file contains test fixtures for the `flake8-pytest-style` linter rule `PT022`, demonstrating both correct usage and expected errors for fixtures that yield without a subsequent cleanup or return.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_pytest_style/PT029.py",
            "description": "This file is a test fixture for the `flake8-pytest-style` linter, specifically for rule PT029, demonstrating correct and incorrect usage of `pytest.warns()` without specifying a warning type.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_pytest_style/PT021.py",
            "description": "This file contains example pytest fixtures demonstrating various patterns for resource acquisition and cleanup, serving as a test case for the Flake8-Pytest-Style rule PT021, which likely concerns proper finalizer usage.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_pytest_style/PT030.py",
            "description": "This file contains `pytest` test cases for `pytest.warns` usage, likely serving as a fixture to test a linter rule (PT030) that flags specific patterns, such as `pytest.warns` without a `match` argument or with an empty `match`.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_pytest_style/is_pytest_test.py",
            "description": "This file serves as a test fixture for the `flake8_pytest_style` linter, demonstrating how it identifies pytest test functions and methods. It includes examples that should trigger linter errors for being recognized as tests and examples that should not.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_pytest_style/PT008.py",
            "description": "This file contains test cases for the `flake8-pytest-style` linter rule PT008, demonstrating correct and incorrect usages of `mocker.patch` and `mocker.patch.object` calls with lambda functions that return `None`.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_pytest_style/PT006.py",
            "description": "This file contains various test cases for `pytest.mark.parametrize`, demonstrating different valid and invalid ways to define parameterized arguments. It serves as a fixture for a linter to test its detection and fixing capabilities for `flake8-pytest-style` rule `PT006`.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_pytest_style/PT023.py",
            "description": "This file serves as a test fixture for the Ruff linter, showcasing various valid uses of `pytest.mark` decorators on functions and classes to ensure correct parsing and linting behavior for the PT023 rule.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_pytest_style/PT010.py",
            "description": "This file contains test cases for the `flake8-pytest-style` rule PT010, demonstrating various ways to use `pytest.raises()` to check for correct linter behavior.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_pytest_style/PT025.py",
            "description": "Test cases for the `flake8-pytest-style` PT025 rule, demonstrating incorrect usage of `@pytest.mark.usefixtures` on a function also decorated with `@pytest.fixture`.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_pytest_style/PT009.py",
            "description": "This file is a test fixture for the `flake8-pytest-style` linter, specifically for the PT009 rule. It demonstrates numerous `unittest.TestCase` assertion methods that are flagged as errors, indicating they should be refactored to use pytest's native `assert` statements.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_pytest_style/PT015.py",
            "description": "This file is a test fixture for the Ruff linter, specifically for the `flake8-pytest-style` rule PT015, which detects assertions of falsy values. It includes examples of `assert` statements that should trigger linting errors and those that should be considered valid.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_pytest_style/PT018.py",
            "description": "This file serves as a test fixture for the Ruff linter's `flake8_pytest_style` plugin, specifically for rule `PT018`. It showcases valid and invalid `pytest` assert statements involving complex boolean expressions using `and`, `or`, and `not`.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_pytest_style/PT026.py",
            "description": "This file serves as a test fixture for the `ruff_linter`'s `flake8_pytest_style` plugin, specifically for rule PT026. It demonstrates both valid and invalid uses of `@pytest.mark.usefixtures` to test the linter's detection capabilities.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_pytest_style/PT027_1.py",
            "description": "This file contains Python unit tests within a `unittest.TestCase` class, demonstrating various uses of `self.assertRaises` context managers, including aliasing, multiple managers, and nested scenarios. It likely serves as a fixture for testing a linter's `flake8_pytest_style` rules.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_pytest_style/PT001.py",
            "description": "This file provides various test cases for the `PT001` rule within the `flake8_pytest_style` linter, demonstrating different ways to define `pytest.fixture` decorators including direct import, aliased import, and variations with and without parentheses or parameters.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_pytest_style/PT020.py",
            "description": "This file contains test cases for the `PT020` rule of `flake8-pytest-style` in the `ruff` linter, demonstrating correct usage of `@pytest.fixture` and incorrect usage of `@pytest.yield_fixture`.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_pytest_style/PT027_0.py",
            "description": "This file serves as a test fixture for the `ruff_linter` project, specifically demonstrating various uses of `unittest.TestCase`'s `assertRaises` and `assertRaisesRegex` methods. It likely tests the detection of specific patterns or styles related to the `flake8-pytest-style` rule PT027.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_pytest_style/PT017.py",
            "description": "Test fixture for the `PT017` linter rule, demonstrating cases where an exception message is accessed directly via `e.message` (error) versus asserting on it correctly with `pytest.raises` (ok).",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_pytest_style/PT012.py",
            "description": "This file is a test fixture for the Ruff linter, specifically for the `flake8-pytest-style` rule PT012. It demonstrates various scenarios of `pytest.raises` usage, highlighting examples that should and should not trigger the linter rule for single statement checks.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_pytest_style/PT031.py",
            "description": "This file contains unit tests for the Flake8-Pytest-Style rule PT031, which likely checks for specific patterns or issues within `pytest.warns` contexts. It includes both `test_ok` cases that should not trigger the rule and `test_error` cases that should.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_pytest_style/PT028.py",
            "description": "This file serves as a test fixture for the `flake8-pytest-style` PT028 rule, demonstrating `pytest` test functions with and without default parameters to check for rule violations.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_pytest_style/PT011.py",
            "description": "This file contains pytest test cases for the `ruff` linter, specifically testing the `flake8_pytest_style` rule PT011. It demonstrates various valid and invalid usages of `pytest.raises`, focusing on cases where the exception, match pattern, or check function arguments are missing or improperly defined.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_pytest_style/PT013.py",
            "description": "This file is a test fixture for the Ruff linter's `flake8-pytest-style` plugin, specifically demonstrating valid and invalid import patterns for `pytest` and its `fixture` decorator related to rule PT013 (no aliasing of pytest fixtures).",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/numpy/NPY002.py",
            "description": "This file serves as a test fixture for Ruff's NPY002 rule, demonstrating both modern and legacy/deprecated usage patterns of NumPy's random number generation functions.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/numpy/NPY201.py",
            "description": "Test fixture for the Ruff linter, evaluating the handling of various NumPy attributes, functions, and import patterns, including deprecated features and conditional imports.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/numpy/NPY003.py",
            "description": "This file provides test cases for the `NPY003` linter rule, demonstrating the usage of deprecated or specific NumPy functions like `round_`, `product`, `cumproduct`, `sometrue`, and `alltrue`.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/numpy/NPY201_3.py",
            "description": "This file is a test fixture for the `ruff_linter` focused on NumPy. It imports NumPy and references various NumPy error types, warnings, and classes, likely to test how the linter handles or flags these specific elements (e.g., for rule NPY201).",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/numpy/NPY201_2.py",
            "description": "This file is a test fixture for a linter, showcasing various deprecated NumPy functions and attributes (NPY201) and specific `try-except` patterns for handling them.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pandas_vet/PD101.py",
            "description": "This file contains test cases for the `PD101` linter rule, demonstrating correct and incorrect usages of `pandas.Series.nunique()` comparisons for detecting constant values.",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pandas_vet/PD002.py",
            "description": "This file serves as a test fixture for the `PD002` rule in the `ruff` linter, demonstrating various `pandas.DataFrame.drop` method calls with `inplace=True` to be detected or ignored by the linter.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/pandas_vet/pandas_use_of_dot_read_table.py",
            "description": "This file is a test fixture for the Ruff linter's `pandas_vet` plugin, demonstrating cases where `pd.read_table` is used with a comma separator, which should ideally be `pd.read_csv` (errors), and valid uses (non-errors).",
            "spof": false
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/ruff/RUF061_deprecated_call.py",
            "description": "This file contains unit tests for the `RUF061` rule, which identifies incorrect usages of `pytest.deprecated_call` when catching deprecation warnings.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/ruff/RUF061_raises.py",
            "description": "This file contains pytest test cases demonstrating various correct and incorrect usages of `pytest.raises` and `pytest.raises().match` for exception testing. It serves as a fixture for a linter rule (RUF061) that likely checks for common issues or patterns related to `pytest.raises`.",
            "spof": true
          }
        ],
        "contributors": [
          {
            "name": "Wei Lee",
            "percent": 40
          },
          {
            "name": "Kevin Yang",
            "percent": 11
          },
          {
            "name": "Micha Reiser",
            "percent": 10
          }
        ]
      }
    },
    "stats": {
      "totalFiles": 2500,
      "spofCount": 900
    },
    "busFactor": 10,
    "authorCount": 177
  },
  "Ecosystem & Performance Tooling": {
    "description": "A suite of internal tools for running performance benchmarks and compatibility checks against thousands of open-source Python projects. This ensures the tool remains fast, reliable, and non-disruptive across the wider Python ecosystem.",
    "functions": {
      "Ecosystem Comparison & Reporting": {
        "files": [
          {
            "path": "docs/faq.md",
            "description": "This file provides a Frequently Asked Questions (FAQ) section for Ruff, detailing its compatibility and comparison with other Python linting, formatting, and type-checking tools like Black, Flake8, and Pylint.",
            "spof": false
          },
          {
            "path": "python/ruff-ecosystem/README.md",
            "description": "This README.md file describes the ruff-ecosystem tool, which is used to compare lint and format results between two different Ruff versions on real-world projects. It covers installation, usage examples, and development tips for the tool.",
            "spof": true
          },
          {
            "path": "python/ruff-ecosystem/ruff_ecosystem/__init__.py",
            "description": "Initializes the logger for the 'ruff-ecosystem' package. This file serves as the package's entry point for logging configuration.",
            "spof": true
          },
          {
            "path": "python/ruff-ecosystem/ruff_ecosystem/__main__.py",
            "description": "This file serves as the main entry point for the `ruff_ecosystem` package, allowing it to be executed directly as a module (`python -m ruff_ecosystem`). It delegates the execution to the package's command-line interface (CLI) entrypoint.",
            "spof": true
          },
          {
            "path": "python/ruff-ecosystem/ruff_ecosystem/defaults.py",
            "description": "This file defines a list of default open-source projects used for `ruff` ecosystem checks, specifying their repositories and configuration options for linting and formatting.",
            "spof": false
          },
          {
            "path": "python/ruff-ecosystem/ruff_ecosystem/check.py",
            "description": "This file is responsible for processing and rendering the results of `ruff check` ecosystem runs into a markdown summary. It calculates and displays changes in linter violations and fixes across projects and by individual rules.",
            "spof": true
          },
          {
            "path": "python/ruff-ecosystem/ruff_ecosystem/markdown.py",
            "description": "This file provides utility functions for generating Markdown-formatted output, particularly for creating collapsible sections (using HTML `<details>` tags) to display project-related information and command details.",
            "spof": true
          },
          {
            "path": "python/ruff-ecosystem/ruff_ecosystem/projects.py",
            "description": "This file defines data structures and utilities for managing projects, their configuration overrides, and command options used in Ruff ecosystem checks. It includes abstractions for projects, repositories, and specific check/format options, along with methods for cloning repositories and patching configuration files.",
            "spof": true
          },
          {
            "path": "python/ruff-ecosystem/ruff_ecosystem/format.py",
            "description": "This file implements the logic for executing, comparing, and summarizing the results of `ruff format` ecosystem checks, including interactions with Black and different comparison strategies, and rendering these results in Markdown.",
            "spof": true
          },
          {
            "path": "python/ruff-ecosystem/ruff_ecosystem/cli.py",
            "description": "This script provides a command-line interface to compare the behavior of two different Ruff executables against a corpus of open-source projects, serving as an ecosystem test harness.",
            "spof": true
          },
          {
            "path": "python/ruff-ecosystem/ruff_ecosystem/types.py",
            "description": "This file defines data structures for representing text differences and for storing and serializing the results of ecosystem comparisons between project versions, including a base class for JSON-serializable objects.",
            "spof": true
          },
          {
            "path": "python/ruff-ecosystem/ruff_ecosystem/main.py",
            "description": "This file implements the main asynchronous logic for the Ruff ecosystem comparison tool, orchestrating the parallel execution of Ruff's `check` or `format` commands across multiple projects using two different Ruff executables and outputting the comparison results.",
            "spof": true
          },
          {
            "path": "scripts/check_ecosystem.py",
            "description": "This script is used to compare the output of two different versions of the `ruff` linter against a predefined corpus of open-source Python repositories. It identifies differences in reported issues between the two `ruff` versions, although it is marked as deprecated.",
            "spof": false
          },
          {
            "path": "scripts/ecosystem_all_check.py",
            "description": "This script iterates through a list of GitHub repositories, runs the 'ruff' linter/formatter on each checked-out project, and saves the output for analysis of potential errors or panics. It serves as a large-scale ecosystem checker for ruff.",
            "spof": false
          },
          {
            "path": "assets/svg",
            "description": "This directory is intended to store SVG (Scalable Vector Graphics) image assets. As part of the 'assets' folder, these SVGs likely serve as visual resources or graphics for the 'ruff' project's benchmark analysis.",
            "spof": false
          }
        ],
        "contributors": [
          {
            "name": "Zanie Blue",
            "percent": 40
          },
          {
            "name": "Charlie Marsh",
            "percent": 17
          },
          {
            "name": "Dhruv Manilawala",
            "percent": 6
          }
        ]
      },
      "Developer Tooling & Code Generation": {
        "files": [
          {
            "path": "python/py-fuzzer/README.md",
            "description": "This README describes a Python fuzzer script designed to test Ruff executables by generating and using random, syntactically valid Python source code. It also provides instructions on how to run the fuzzer.",
            "spof": true
          },
          {
            "path": "python/py-fuzzer/fuzz.py",
            "description": "This script is a fuzzer that generates random, syntactically valid Python code to test the robustness of Ruff's parser or a type-checking tool (`ty`) by checking for unexpected crashes or errors.",
            "spof": true
          },
          {
            "path": "scripts/update_schemastore.py",
            "description": "This script automates the process of updating the `ruff.json` schema in the `SchemaStore` repository. It clones `SchemaStore`, updates the Ruff JSON schema, and pushes the changes to a new branch for a pull request.",
            "spof": false
          },
          {
            "path": "scripts/update_ambiguous_characters.py",
            "description": "This script generates the `confusables.rs` Rust file, which defines a mapping of ambiguous Unicode characters, by fetching and processing data from a VS Code Unicode data repository.",
            "spof": false
          },
          {
            "path": "scripts/check_docs_formatted.py",
            "description": "This script checks if code snippets embedded within documentation files are correctly formatted according to Ruff. It identifies formatting violations, parsing errors, and malformed internal links in the documentation.",
            "spof": false
          },
          {
            "path": "crates/ruff_dev/src/round_trip.rs",
            "description": "This file implements a utility to perform round-trip source code generation on a given Python or Jupyter notebook file.",
            "spof": false
          },
          {
            "path": "crates/ruff_dev/src/format_dev.rs",
            "description": "This file implements a development tool for the Ruff Python formatter. It provides functionalities for formatting files, checking formatter stability, and calculating statistics like similarity indices between original and formatted code across single or multiple projects.",
            "spof": false
          },
          {
            "path": "fuzz/README.md",
            "description": "This README provides an overview and usage instructions for the fuzzing utilities designed for automatic testing of the Ruff linter, detailing how to set up and run various fuzzer harnesses.",
            "spof": false
          }
        ],
        "contributors": [
          {
            "name": "Alex Waygood",
            "percent": 35
          },
          {
            "name": "konsti",
            "percent": 14
          },
          {
            "name": "Micha Reiser",
            "percent": 11
          }
        ]
      },
      "Performance Benchmarking Framework": {
        "files": [
          {
            "path": "scripts/benchmarks/README.md",
            "description": "This README provides documentation for the Ruff benchmarking utilities, including instructions for setting up, running benchmarks, and generating performance plots.",
            "spof": true
          },
          {
            "path": "scripts/ty_benchmark/src/benchmark/projects.py",
            "description": "This file defines benchmark projects, including their repository details, Python versions, installation arguments, and specific incremental edits for performance testing. It provides the setup and configuration for a suite of projects used in benchmarking.",
            "spof": true
          },
          {
            "path": "scripts/ty_benchmark/src/benchmark/__init__.py",
            "description": "This file defines data structures and logic to configure and execute system benchmarks using the `hyperfine` tool, including command definitions, setup steps, and output options.",
            "spof": true
          },
          {
            "path": "crates/ruff_benchmark/README.md",
            "description": "This README.md file documents how to run and compare performance benchmarks for the Ruff linter and formatter using `cargo bench`.",
            "spof": false
          },
          {
            "path": "crates/ruff_benchmark/benches/formatter.rs",
            "description": "This file contains benchmarks for the `ruff` Python formatter. It measures the performance of formatting various Python code samples using `ruff`'s internal formatter.",
            "spof": false
          },
          {
            "path": "crates/ruff_benchmark/benches/parser.rs",
            "description": "This file contains benchmarks for Ruff's Python parser, measuring its performance when parsing various Python code samples using the `criterion` benchmarking harness. It parses Python code, then traverses the generated Abstract Syntax Tree (AST) to count statements.",
            "spof": true
          },
          {
            "path": "crates/ruff_benchmark/benches/linter.rs",
            "description": "This file contains benchmarks for the Ruff linter, measuring its performance with default rules, all available rules, and all rules including preview features. It uses the `criterion` crate to evaluate linting speed across various Python code test cases.",
            "spof": false
          },
          {
            "path": "crates/ruff_benchmark/benches/ty_walltime.rs",
            "description": "This file defines benchmarks for measuring the performance of a linter or static analyzer (`ruff-db`) by running it against various real-world Python projects. It sets up individual benchmarks for each project and also includes a multi-threaded benchmark.",
            "spof": true
          },
          {
            "path": "crates/ruff_benchmark/benches/lexer.rs",
            "description": "This file contains benchmarks for the `ruff` lexer, measuring its performance on various Python code samples. It uses the `criterion` benchmarking library to evaluate lexing speed.",
            "spof": false
          },
          {
            "path": "crates/ruff_benchmark/resources/README.md",
            "description": "This README documents the purpose of the vendored files in this directory, which are used to benchmark Ruff's performance against real-world code. It lists the specific files included from various open-source projects.",
            "spof": true
          },
          {
            "path": "crates/ruff_benchmark/resources/pypinyin.py",
            "description": "This module provides functions to handle special cases and transformations in Hanyu Pinyin, converting various pinyin forms back to their original rime/final forms based on standard Pinyin rules.",
            "spof": true
          },
          {
            "path": "crates/ruff_benchmark/resources/tomllib/_types.py",
            "description": "This file defines type aliases using Python's `typing` module, specifically for parsing floating-point numbers, representing keys as tuples of strings, and denoting positions as integers. It provides type annotations for internal use within the `tomllib` package.",
            "spof": true
          },
          {
            "path": "crates/ruff_benchmark/resources/tomllib/_re.py",
            "description": "This file provides regular expressions and associated utility functions for parsing numbers, local times, and datetimes from strings into their respective Python objects. It is likely used as part of a TOML parsing library.",
            "spof": true
          },
          {
            "path": "crates/ruff_benchmark/resources/tomllib/__init__.py",
            "description": "This file serves as the public interface for the `tomllib` package, exposing TOML parsing functions (`loads`, `load`) and its associated error type (`TOMLDecodeError`) imported from an internal parser module.",
            "spof": true
          },
          {
            "path": "crates/ruff_benchmark/resources/tomllib/_parser.py",
            "description": "This file implements the core parsing logic for TOML (Tom's Obvious, Minimal Language) documents, converting TOML strings or binary file objects into Python dictionaries. It handles various TOML syntax elements including keys, values, tables, and arrays of tables.",
            "spof": true
          },
          {
            "path": "crates/ruff_benchmark/resources/numpy/ctypeslib.py",
            "description": "This file provides utility functions for interfacing NumPy arrays with C libraries using the `ctypes` module. It includes tools for loading C libraries, creating array-checking argument types (`ndpointer`), and converting between NumPy arrays and ctypes arrays.",
            "spof": true
          },
          {
            "path": "crates/ruff_benchmark/resources/numpy/globals.py",
            "description": "This module defines global singleton classes and enumerations, such as `_NoValue` and `_CopyMode`, for NumPy. It prevents reloading to ensure the identities of these crucial objects remain constant across potential NumPy reloads.",
            "spof": true
          },
          {
            "path": "crates/ruff_benchmark/resources/large/dataset.py",
            "description": "This file contains a comprehensive suite of pytest unit tests for the `mikeio.Dataset` class, validating its initialization, data manipulation, indexing, subsetting, and error handling with various dataset configurations, including large ones.",
            "spof": true
          },
          {
            "path": "crates/ruff_benchmark/resources/pydantic/types.py",
            "description": "This file defines Pydantic V2-style custom types and constrained types for various data types (e.g., integers, floats, strings, collections, UUIDs, decimals, paths). It leverages `typing.Annotated` and `annotated_types` to add validation rules and metadata to standard Python types.",
            "spof": true
          },
          {
            "path": "crates/ruff_benchmark/src/real_world_projects.rs",
            "description": "This file provides infrastructure in Rust for setting up and preparing real-world Python projects for benchmarking. It handles cloning repositories, checking out specific commits, and installing dependencies using `uv`.",
            "spof": true
          },
          {
            "path": "crates/ruff_benchmark/src/lib.rs",
            "description": "This file defines data structures (`TestFile`, `TestCase`, `TestCaseSpeed`) and provides static instances of test files used for benchmarking the `ruff` project. It serves as a central point for managing test cases and their associated code for performance analysis.",
            "spof": true
          },
          {
            "path": "crates/ruff_benchmark/src/criterion.rs",
            "description": "This file provides a compatibility layer for benchmarking in Ruff, conditionally re-exporting either the `criterion` crate or `codspeed_criterion_compat` based on whether benchmarks are built for local execution or with CodSpeed.",
            "spof": true
          },
          {
            "path": "crates/ruff_memory_usage/src/lib.rs",
            "description": "This file provides utilities for calculating the heap memory usage of objects, employing a thread-local `StandardTracker` to accurately measure memory by avoiding double-counting shared objects.",
            "spof": true
          },
          {
            "path": ".claude/hooks",
            "description": "This empty directory is likely intended to store configuration or scripts related to 'hooks' for the Claude AI assistant, specific to the `ruff` benchmark analysis. It would typically contain automated tasks or integration points for Claude within this project context.",
            "spof": false
          }
        ],
        "contributors": [
          {
            "name": "Micha Reiser",
            "percent": 93
          },
          {
            "name": "David Peter",
            "percent": 2
          },
          {
            "name": "Alex Waygood",
            "percent": 1
          }
        ]
      },
      "Type Checker & LSP Tooling": {
        "files": [
          {
            "path": "scripts/ty_benchmark/README.md",
            "description": "This README.md file provides instructions for setting up and running various type-checking benchmarks, including cold/warm check times and LSP-related diagnostics, for Python projects using tools like `uv` and `ty`.",
            "spof": true
          },
          {
            "path": "scripts/ty_benchmark/snapshots",
            "description": "This directory stores snapshot files, likely representing expected outputs or golden masters for type-checking benchmarks within the `ruff` project. These snapshots are crucial for verifying the correctness and consistency of benchmark results over time, ensuring that changes to the type checker do not inadvertently alter expected behaviors.",
            "spof": false
          },
          {
            "path": "scripts/ty_benchmark/src/benchmark/lsp_client.py",
            "description": "This file implements a simple Language Server Protocol (LSP) client designed for benchmarking diagnostic response times. It handles both pull and push diagnostic methods and includes custom serialization hooks for notebook document types.",
            "spof": true
          },
          {
            "path": "scripts/ty_benchmark/src/benchmark/snapshot.py",
            "description": "This file defines utilities for running shell commands, normalizing their output by replacing dynamic paths, and managing snapshots of that output for testing or benchmarking purposes. It can compare current output against saved snapshots, display diffs, and update snapshots.",
            "spof": true
          },
          {
            "path": "scripts/ty_benchmark/src/benchmark/run.py",
            "description": "This script orchestrates benchmarking different type-checking tools (like ty, mypy, pyright) against a set of projects, either by measuring their performance using Hyperfine or by capturing their output as snapshots.",
            "spof": true
          },
          {
            "path": "scripts/ty_benchmark/src/benchmark/test_lsp_diagnostics.py",
            "description": "This file contains pytest benchmarks for Language Server Protocol (LSP) servers, measuring their performance in providing diagnostics upon initial file open and after incremental file edits.",
            "spof": true
          },
          {
            "path": "scripts/ty_benchmark/src/benchmark/tool.py",
            "description": "Defines an abstract base class for static type checking tools and implements concrete classes for specific tools (e.g., Mypy, Pyright, Ty, Pyrefly), managing their configuration and command generation for benchmarking purposes.",
            "spof": true
          },
          {
            "path": "crates/ty/docs/mypy_primer.md",
            "description": "This document provides instructions and examples for running and configuring `mypy_primer` with `ruff`'s type checker (`ty`). It covers installation, comparing Git revisions, optimizing runs, and working with local repositories.",
            "spof": true
          },
          {
            "path": "crates/ty_test/src/parser.rs",
            "description": "Parses Markdown files to extract embedded code blocks (e.g., Python) and structure them into a test suite (`MarkdownTestSuite`). It provides functionality to iterate over individual tests (`MarkdownTest`) and map line numbers within the embedded code back to the original Markdown file.",
            "spof": false
          },
          {
            "path": "crates/ty_test/src/db.rs",
            "description": "Defines the core Salsa database (`Db`) for the `ty_test` crate, handling source code analysis, module resolution, semantic analysis, and abstracting file system interactions for testing purposes.",
            "spof": true
          },
          {
            "path": "crates/ty_completion_bench/README.md",
            "description": "This README describes a command-line tool for ad hoc benchmarking and profiling of 'ty's completion feature. It includes examples for testing completions in both new and existing Python projects.",
            "spof": true
          },
          {
            "path": "crates/ty_completion_bench/src/main.rs",
            "description": "This file implements a command-line tool for ad hoc benchmarking of code completion functionality within a project, measuring the time taken for initial and subsequent completion requests. It discovers project metadata and sets up the environment using `uv sync`.",
            "spof": true
          },
          {
            "path": "crates/ruff_benchmark/benches/ty.rs",
            "description": "This file contains Rust benchmarks for the `ty` (type checking/analysis) component of Ruff. It measures the performance of type checking in scenarios such as incremental changes, cold starts, and specific type inference challenges using real-world and synthetic code examples.",
            "spof": false
          },
          {
            "path": "crates/ty_completion_eval/README.md",
            "description": "This README describes a framework for evaluating completion suggestions returned by the `ty` Language Server Protocol (LSP) using Mean Reciprocal Rank (MRR), detailing how to run evaluations, debug tasks, and manage related continuous integration failures.",
            "spof": true
          },
          {
            "path": "crates/ty_completion_eval/truth/higher-level-symbols-preferred/main.py",
            "description": "This file serves as a test case for type completion evaluation, highlighting a scenario where an auto-import symbol finder fails to suggest a symbol that a type checker successfully identifies.",
            "spof": true
          },
          {
            "path": "crates/ty_completion_eval/truth/higher-level-symbols-preferred/sub1/__init__.py",
            "description": "This `__init__.py` file imports and exposes the `ZQZQZQ_SOMETHING_IMPORTANT` symbol from its sibling `sub2` module directly into the `sub1` package's namespace. This facilitates easier access to the symbol for users of the `sub1` package.",
            "spof": true
          },
          {
            "path": "crates/ty_completion_eval/truth/higher-level-symbols-preferred/sub1/sub2.py",
            "description": "This file defines a simple constant, `ZQZQZQ_SOMETHING_IMPORTANT`, likely serving as a test case for type completion evaluation within the `ruff` project. It is specifically located in a benchmark path related to preferring higher-level symbols.",
            "spof": true
          },
          {
            "path": "crates/ty_completion_eval/src/main.rs",
            "description": "This file implements a command-line tool for evaluating the quality of code completions provided by the `ty` engine. It can run a full evaluation across all tasks, calculating metrics like Mean Reciprocal Rank (MRR), or display completions for a single task for debugging.",
            "spof": true
          }
        ],
        "contributors": [
          {
            "name": "Micha Reiser",
            "percent": 52
          },
          {
            "name": "Andrew Gallant",
            "percent": 29
          },
          {
            "name": "Alex Waygood",
            "percent": 7
          }
        ]
      }
    },
    "stats": {
      "totalFiles": 65,
      "spofCount": 46
    },
    "busFactor": 2,
    "authorCount": 17
  },
  "Utility": {
    "description": "",
    "functions": {
      "General Utility": {
        "files": [
          {
            "path": "docs/js/extra.js",
            "description": "This script provides functionality for cleaning up and setting text to be copied to the clipboard from code blocks in documentation. It uses an IntersectionObserver to lazily prepare the clipboard text for 'copy' buttons as they become visible.",
            "spof": true
          },
          {
            "path": "scripts/_utils.py",
            "description": "This file provides various utility functions for string manipulation, including case conversions, and a helper for directory path resolution, intended for internal use by other scripts in the project.",
            "spof": false
          },
          {
            "path": "crates/ty/src/printer.rs",
            "description": "This file defines a `Printer` struct and related utilities for managing application output, including verbosity levels, progress bars, and custom `Stdout` streams that can be enabled or disabled based on message importance.",
            "spof": true
          },
          {
            "path": "crates/ruff/src/stdin.rs",
            "description": "This file provides utility functions for reading data from standard input (stdin) and for echoing stdin content to standard output (stdout).",
            "spof": false
          },
          {
            "path": "crates/ruff_dev/src/print_cst.rs",
            "description": "This file provides a utility to parse a given Python file and print its Concrete Syntax Tree (CST) using the `libcst_native` library.",
            "spof": true
          },
          {
            "path": "crates/ruff_annotate_snippets/examples/expected_type.rs",
            "description": "This file is an example demonstrating the `ruff_annotate_snippets` crate. It constructs and renders a formatted error message with code annotations, simulating an 'expected type' mismatch within a source code snippet.",
            "spof": true
          },
          {
            "path": "crates/ruff_annotate_snippets/tests/rustc_tests.rs",
            "description": "This file contains unit tests for the `ruff_annotate_snippets` crate, adapted from Rust's parser tests. It verifies the correct rendering of code snippets with various error and warning annotations, including cases with overlapping or nested spans.",
            "spof": true
          },
          {
            "path": "crates/ruff_annotate_snippets/tests/fixtures/main.rs",
            "description": "This file implements a test harness for `ruff_annotate_snippets`, processing TOML-defined fixtures to render annotated code snippets and compare the generated SVG output.",
            "spof": true
          },
          {
            "path": "crates/ruff_annotate_snippets/src/lib.rs",
            "description": "This file defines a library for formatting and annotating text or programming code snippets, primarily to build ASCII-graphical representations.",
            "spof": true
          },
          {
            "path": "crates/ruff_annotate_snippets/src/renderer/mod.rs",
            "description": "This file defines the `Renderer` responsible for formatting and displaying structured messages and code snippets, often used for error reporting. It provides methods to configure styling, terminal width, and other presentation options for the rendered output.",
            "spof": true
          },
          {
            "path": "crates/ruff_index/src/idx.rs",
            "description": "Defines the `Idx` trait for creating newtype wrappers used as indices into vectors or slices, ensuring type safety and efficient access. It also includes unit tests for a concrete `Idx` implementation.",
            "spof": true
          },
          {
            "path": "crates/ruff_index/src/lib.rs",
            "description": "This file provides new-type wrappers for collections, enabling indexing by a custom `Idx` type instead of `usize`, inspired by `rustc_index`.",
            "spof": false
          },
          {
            "path": "crates/ruff_index/src/slice.rs",
            "description": "This file defines `IndexSlice`, a custom slice type that allows indexing elements using a generic `Idx` type instead of `usize`, providing type safety and domain-specific indexing for contiguous data.",
            "spof": true
          },
          {
            "path": "crates/ruff_index/src/vec.rs",
            "description": "This file defines `IndexVec`, a generic vector type that wraps `std::vec::Vec` and provides strongly typed indexing using a `PhantomData<I>` marker, ensuring elements are accessed via a specific index type `I`.",
            "spof": false
          },
          {
            "path": "crates/ruff_db/src/display.rs",
            "description": "This file provides a utility trait and struct to efficiently format a sequence of `Display`able items into a `std::fmt::Formatter` with a specified separator, without allocating intermediate strings.",
            "spof": true
          },
          {
            "path": "crates/ruff_db/src/system/walk_directory.rs",
            "description": "This file defines traits and structures for configuring and executing a recursive directory traversal, including filtering options, error handling, and visitor patterns for processing directory entries.",
            "spof": true
          },
          {
            "path": "crates/ruff_db/src/system/path.rs",
            "description": "Defines the `SystemPath` struct, a UTF-8 aware type for representing and manipulating file system paths within the system module, providing methods for path analysis and transformation.",
            "spof": false
          },
          {
            "path": "crates/ruff_db/src/system/memory_fs.rs",
            "description": "This file implements an in-memory file system (`MemoryFileSystem`) that stores all file and directory content in memory. It provides basic file system operations like reading, writing, and metadata retrieval, designed for use cases that do not require full OS file system features like symlinks or permissions.",
            "spof": true
          },
          {
            "path": "crates/ruff_db/src/system/test.rs",
            "description": "This file defines `TestSystem`, a customizable in-memory file system implementation designed specifically for testing purposes, allowing manipulation of file system state and environment variables.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/src/fs.rs",
            "description": "This file provides utility functions for filesystem path manipulation, including obtaining the current working directory, normalizing paths to absolute forms, relativizing paths, and applying per-file ignore rules based on file paths.",
            "spof": true
          },
          {
            "path": "crates/ruff_python_literal/src/float.rs",
            "description": "This file provides utility functions for working with floating-point numbers, primarily focused on converting `f64` values into a human-readable string representation, including handling scientific notation for very large or small numbers.",
            "spof": true
          },
          {
            "path": "crates/ruff_macros/src/kebab_case.rs",
            "description": "This file provides a utility function for procedural macros that converts a Rust identifier to its kebab-case string representation, returning it as a `TokenStream`.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_trivia/src/textwrap.rs",
            "description": "Provides utility functions for adding, removing, and adjusting the indentation of text blocks, handling various newline formats and whitespace trimming.",
            "spof": true
          },
          {
            "path": "crates/ruff_text_size/src/range.rs",
            "description": "This file defines the `TextRange` struct, which represents a range within text using `TextSize` values. It provides methods for creating, querying, manipulating, and comparing text ranges, such as checking for containment, intersection, and covering other ranges.",
            "spof": false
          },
          {
            "path": "crates/ruff_text_size/tests/auto_traits.rs",
            "description": "This test file verifies that the `TextSize` and `TextRange` types implement a set of required auto traits and common traits, such as `Send`, `Sync`, `Copy`, `Debug`, and `Default`.",
            "spof": true
          },
          {
            "path": "crates/ty_project/src/glob/exclude.rs",
            "description": "This module provides an `ExcludeFilter` that uses gitignore-like glob patterns to determine if a given file or directory path should be excluded. It includes custom logic for handling absolute paths, directory-only matches, and negation patterns.",
            "spof": true
          },
          {
            "path": "crates/ty_combine/src/lib.rs",
            "description": "This file defines the `Combine` trait for merging two values, where the `self` instance's values take precedence over `other`. It includes implementations for various data structures like `Option`, `Vec`, `HashMap`, and `OrderMap`, aligning with configuration merging logic similar to Cargo's `config.toml`.",
            "spof": true
          }
        ],
        "contributors": [
          {
            "name": "Micha Reiser",
            "percent": 53
          },
          {
            "name": "Andrew Gallant",
            "percent": 18
          },
          {
            "name": "Zanie Blue",
            "percent": 6
          }
        ]
      }
    },
    "stats": {
      "totalFiles": 27,
      "spofCount": 20
    },
    "busFactor": 2,
    "authorCount": 11
  },
  "Python Type Checker": {
    "description": "Performs static type checking on Python code to identify type-related errors before runtime. This module helps improve code reliability and prevent bugs by validating type annotations.",
    "functions": {
      "Type Checker Testing Framework": {
        "files": [
          {
            "path": "scripts/conformance.py",
            "description": "This script runs typing conformance tests and compares diagnostic results between two versions of a type checker, `ty`. It classifies the diagnostics to evaluate changes in how errors are reported.",
            "spof": true
          },
          {
            "path": "crates/ty/tests/file_watching.rs",
            "description": "This file contains integration tests for the file watching and change detection mechanisms within the type checking (ty) component of the Ruff project, ensuring the project database correctly reacts to file system modifications.",
            "spof": false
          },
          {
            "path": "crates/ty/tests/cli/fixes.rs",
            "description": "This file contains integration tests for the `ruff ty` command-line interface, specifically verifying the functionality of adding `ty: ignore` comments to suppress type-checking diagnostics.",
            "spof": true
          },
          {
            "path": "crates/ty/tests/cli/main.rs",
            "description": "This file contains command-line interface (CLI) integration tests for the `ty` type checker, verifying its behavior with various arguments, configuration options, and file system interactions.",
            "spof": false
          },
          {
            "path": "crates/ty/tests/cli/exit_code.rs",
            "description": "This file contains Rust integration tests for the `ruff` CLI, specifically verifying its exit code behavior under various conditions, such as the presence of warnings, errors, info messages, and the use of `--error-on-warning` or `--exit-zero` flags.",
            "spof": false
          },
          {
            "path": "crates/ty_test/README.md",
            "description": "This README describes how to write type-checking and type-inference tests using a Markdown-based test framework, detailing assertion types, multi-file tests, and structured test suites.",
            "spof": false
          },
          {
            "path": "crates/ty_test/src/config.rs",
            "description": "This file defines Rust data structures for deserializing `ty` configuration options from TOML, primarily used to configure `ty` tests within Markdown files. It includes settings for the Python environment, logging, analysis, and project dependencies.",
            "spof": false
          },
          {
            "path": "crates/ty_test/src/diagnostic.rs",
            "description": "This file provides utilities to sort and group diagnostic messages by their starting line number, enabling easier correlation with source code assertions within a given file.",
            "spof": false
          },
          {
            "path": "crates/ty_test/src/assertion.rs",
            "description": "Parses and handles type and type-error assertion comments found in Python test files, extracting them into structured representations for validation. It identifies comments like `# revealed: SomeType` and `# error: 8 [rule-code] \"message text\"`.",
            "spof": false
          },
          {
            "path": "crates/ty_test/src/matcher.rs",
            "description": "This file contains logic for matching diagnostics (errors/warnings) against assertions found in source code, generating test failure messages for any mismatches. It's a core component for verifying expected diagnostic behavior in a testing context.",
            "spof": false
          },
          {
            "path": "crates/ty_test/src/lib.rs",
            "description": "This file implements the core logic for running markdown-based test suites (`mdtest`) for the `ruff-ty` type-checking system. It parses markdown files, executes embedded code blocks as tests, and reports any failures with detailed output.",
            "spof": false
          },
          {
            "path": "crates/ruff/tests/cli/analyze_graph.rs",
            "description": "This file contains integration tests for the `ruff analyze graph` CLI command, specifically verifying how it handles type-checking-only imports based on command-line flags and configuration settings.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/README.md",
            "description": "This README.md explains that markdown files in the `mdtest/` subdirectory are used for type inference and type checking tests, executed by an integration test.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/intersection_types.md",
            "description": "This file is a test suite and documentation for Python's intersection types, demonstrating their properties, simplification strategies, and interactions with negation, unions, Never, and object types.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/mdtest_config.md",
            "description": "This file contains tests for `ty_test`'s ability to parse and apply TOML configuration blocks hierarchically. It demonstrates how settings like `python-version` are inherited, overwritten, and managed across different sections.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/decorators.md",
            "description": "This document provides examples and explanations of Python decorators, covering their basic usage, advanced patterns, type annotation considerations, and common error scenarios for both function and class decorators.",
            "spof": true
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/literal_promotion.md",
            "description": "This document describes the rules for 'literal promotion' in Python type checking, detailing when literal types are promoted to their common supertype and under what conditions promotion is avoided, such as in contravariant positions or with explicit Literal annotations.",
            "spof": true
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/enums.md",
            "description": "This markdown file serves as a comprehensive test and documentation for the type analysis of Python `enum` classes, detailing how various enum features like members, aliases, `auto()`, and non-member attributes are handled and revealed by a type checker (likely 'ruff').",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/mdtest_custom_typeshed.md",
            "description": "This file documents how to configure and use custom typeshed directories for Markdown-based tests, including providing stub files, managing the `VERSIONS` file, and handling `reveal_type`.",
            "spof": true
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/pep695_type_aliases.md",
            "description": "This file contains examples and tests for PEP 695 type aliases, demonstrating their behavior, including basic usage, generics, cyclic references, and their interaction with `TypeAliasType`.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/properties.md",
            "description": "This document provides an in-depth explanation and examples of Python's `property` built-in, covering its usage as a descriptor for custom getters, setters, and deleters, along with type-checking implications and internal mechanisms.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/classes.md",
            "description": "This markdown file serves as a test resource or documentation for class definition behavior within the `ty_python_semantic` crate of the Ruff project. It specifically details and provides examples for deferred resolution of class bases and the handling of starred base classes.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/implicit_type_aliases.md",
            "description": "This markdown document describes implicit type aliases in Python, focusing on the behavior of the union (`|`) operator with various types and constructs, including basic types, None, Unions, Any, Never, Unknown, Literal, LiteralString, Annotated, Optional, TypeVar, and Callable.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/final.md",
            "description": "This file contains tests and documentation for the `@final` decorator in Python, demonstrating its behavior when applied to classes and methods to prevent inheritance and overriding, and exploring various edge cases.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/protocols.md",
            "description": "This markdown document provides a detailed explanation of Python's `typing.Protocol`, covering its definition, inheritance rules, generic usage, and how type checkers interpret protocol conformance.",
            "spof": true
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/del.md",
            "description": "This file documents and tests the behavior of Python's `del` statement, covering its impact on variable resolution, attributes, and various types of items. It includes examples demonstrating type checker interactions and expected errors related to `del`.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/statically_known_branches.md",
            "description": "This document describes how Ruff's semantic analysis handles statically known branches, such as `sys.version_info`, `sys.platform`, and `typing.TYPE_CHECKING`, to perform precise type inference and boundness checks. It includes various test cases for if/elif/else statements, nested conditionals, and combinations with try/except/finally blocks.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/async.md",
            "description": "This file documents and demonstrates the type behavior of `async` and `await` in Python, including basic usage, generic async functions, common `asyncio` patterns, and underlying type inference for a type checker.",
            "spof": true
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/union_types.md",
            "description": "This file is a test suite documenting the behavior and simplification strategies for union types in Python's type system, covering various cases like `Never`, `object`, literals, and generic containers.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/known_constants.md",
            "description": "This markdown document serves as a test suite detailing the behavior and inference rules for the `TYPE_CHECKING` constant in a Python type checker. It illustrates how `TYPE_CHECKING` is consistently inferred as `Literal[True]` during type-checking, regardless of its source or explicit assignment, and covers various valid and invalid usage patterns.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/sys_platform.md",
            "description": "This markdown file documents and tests the type inference behavior of `sys.platform` in Python, demonstrating how its type changes based on the configured `python-platform` environment setting and showing type reveals for platform comparisons.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/t_strings.md",
            "description": "This markdown file documents and provides examples for Python 3.14 template strings (t-strings), including their type and usage, likely for testing or documentation within the `ruff` project's semantic analysis.",
            "spof": true
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/typed_dict.md",
            "description": "This file provides examples and detailed explanations of `TypedDict` usage, type checking, and validation behavior in Python.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/struct_unpack.md",
            "description": "This file contains test cases for the `struct.unpack` function, demonstrating how a static type checker infers return types for various format strings, including simple unpacking, large repetition counts, whitespace, and unknown format codes.",
            "spof": true
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/exhaustiveness_checking.md",
            "description": "This file contains a collection of Python code examples demonstrating and testing exhaustiveness checking for type unions and enums. It covers various scenarios including literal values, enum members, class instances (with and without generics), and different control flow constructs like `if/elif/else` and `match/case` statements.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/named_tuple.md",
            "description": "This markdown document demonstrates and tests the type-checking behavior of `typing.NamedTuple` in Python, covering various syntax forms, field definitions, and expected type inference results and errors.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/unpacking.md",
            "description": "This file provides a comprehensive set of test cases and examples demonstrating how Python's type checker infers types during various unpacking operations, including tuples, lists, nested structures, starred expressions, and custom iterables, as well as error conditions like uneven unpacking.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/override.md",
            "description": "This markdown file serves as a test suite or documentation for the `typing.override` decorator, illustrating various valid and invalid usage patterns that a type checker should detect. It demonstrates how `override` interacts with inheritance, decorators, properties, class methods, static methods, and conditional definitions, including cases that should trigger `invalid-explicit-override` errors.",
            "spof": true
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/pep613_type_aliases.md",
            "description": "This file contains a series of test cases and examples demonstrating the behavior, capabilities, and limitations of PEP 613 type aliases in Python. It covers various scenarios such as basic usage, generic aliases, cyclic definitions, and error conditions.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/terminal_statements.md",
            "description": "This file documents and tests how terminal statements like `return`, `continue`, and `break` affect control-flow analysis and variable binding in Python, with examples illustrating their impact on type revelation.",
            "spof": true
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/overloads.md",
            "description": "This file documents and tests various aspects of Python's `typing.overload` functionality, including its usage with functions, methods, constructors, version-specific behaviors, generics, and invalid scenarios. It serves as a test resource for a type checker, demonstrating expected type inference and error diagnostics related to overloads.",
            "spof": true
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/sys_version_info.md",
            "description": "This file documents and tests the type inference behavior of `sys.version_info` in a type checker. It covers how literal types are derived from comparisons, attribute access, and indexing, based on a specified Python version (3.9).",
            "spof": true
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/cycle.md",
            "description": "This file contains test cases and examples demonstrating how a type checker handles cyclic type definitions and self-references in Python code, such as those found in function signatures, type aliases, and default parameter values. It showcases various scenarios where type resolution might lead to `Unknown` or `Divergent` types to prevent infinite recursion.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/unreachable.md",
            "description": "This document describes the approach to detecting and handling unreachable code, including various scenarios that lead to unreachable code, and ensuring that incorrect diagnostics are not emitted in such code.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/annotations/any.md",
            "description": "This markdown test file documents and tests the behavior of `typing.Any` in Python type checking. It covers various scenarios including aliasing, shadowing, subclassing, runtime properties, and invalid usages of `Any`.",
            "spof": true
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/annotations/annotated.md",
            "description": "This document explains the `Annotated` type from `typing_extensions`, detailing its usage, parameterization rules, and inheritance behavior with code examples and type revelation outputs.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/annotations/optional.md",
            "description": "This markdown file serves as a test case and documentation for `typing.Optional` annotations in Python, demonstrating its usage, behavior, assignments, and invalid forms.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/annotations/literal_string.md",
            "description": "This document provides a comprehensive explanation and test cases for `LiteralString`, a type from `typing_extensions` (or `typing` in Python 3.11+). It covers its usage, constraints (e.g., cannot be parameterized or used within `Literal`), inference rules, assignability, and narrowing behavior.",
            "spof": true
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/annotations/callable.md",
            "description": "This file documents and tests various forms of `typing.Callable` annotations, illustrating valid usage, invalid syntax, and interactions with other type features like `ParamSpec`, `Concatenate`, and `Unpack` within the `ruff` type-checking context.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/annotations/union.md",
            "description": "This file documents and provides examples for `typing.Union` and new-style union types (`|`) in Python type annotations, covering their usage, assignment rules, and edge cases.",
            "spof": true
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/annotations/never.md",
            "description": "This document explains the `NoReturn` and `Never` types in Python, detailing their usage in type annotations for functions and assignments, and highlighting their compatibility with different Python versions.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/annotations/int_float_complex.md",
            "description": "This markdown file documents Ruff's type checking behavior for special Python annotations such as `float` (which implies `int | float`) and `complex` (implying `int | float | complex`), including its unique approach to revealing these union types. It provides examples for assignment, function arguments, and type narrowing.",
            "spof": true
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/annotations/starred.md",
            "description": "This file is a markdown-formatted test case for Ruff's type-checking semantic analysis, specifically demonstrating and testing type annotations involving starred expressions (`*args`) and `TypeVarTuple` as per PEP 646.",
            "spof": true
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/annotations/string.md",
            "description": "This file contains test cases and examples for string-based type annotations in Python, demonstrating their various forms, expected type revelations, and error handling for invalid syntax within the Ruff linter's type checker.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/annotations/unsupported_special_types.md",
            "description": "This markdown document details how the type checker handles and avoids false positives for specific unsupported Python type features, such as functional TypedDict/Enum creation and TypeVarTuple usage in type annotations.",
            "spof": true
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/annotations/deferred.md",
            "description": "This file contains tests and examples demonstrating the behavior of deferred type annotations in Python, comparing how they are resolved in regular source files versus stub files, and the effect of `from __future__ import annotations`.",
            "spof": true
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/annotations/new_types.md",
            "description": "This file is a markdown document detailing the behavior and usage of `NewType` in Python, including its subtyping rules, callable nature, argument constraints, and interactions with arithmetic operations, with special attention to `float` and `complex` bases.",
            "spof": true
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/annotations/stdlib_typing_aliases.md",
            "description": "This file documents how type checkers should handle `typing` module aliases for standard library collections like `List`, `Dict`, and `Set`. It demonstrates type correspondence, error reporting for incorrect type arguments, and inheritance behavior for these legacy aliases.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/annotations/invalid.md",
            "description": "This file contains tests and examples demonstrating various forms of invalid type expressions and AST nodes within Python type annotations. It showcases scenarios that should produce `invalid-type-form` errors in a type checker or linter.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/annotations/literal.md",
            "description": "This file is a test resource or documentation showcasing various aspects of Python's `typing.Literal` type, including valid and invalid parameterizations, usage with type aliases, and behavior in union types. It also covers the distinction between `Literal` from `typing`/`typing_extensions` and other sources.",
            "spof": true
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/annotations/self.md",
            "description": "This file contains test cases and documentation for the `typing.Self` annotation in Python, demonstrating its behavior in various method types, class structures, and generic contexts for type checking.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/binary/tuples.md",
            "description": "This file is a Markdown test resource demonstrating how the type checker analyzes binary operations, specifically concatenation, on various types of tuples (heterogeneous, homogeneous, and with type aliases).",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/binary/instances.md",
            "description": "This markdown document describes and demonstrates the type inference rules for Python's binary operations (like `+`, `-`, `*`) on instances, including handling of `__add__`, `__radd__`, operator precedence, return types, and interactions with special types like `Any` and literal types.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/binary/custom.md",
            "description": "This file contains test cases for a type checker, demonstrating the type inference for custom binary operations defined through dunder methods in Python classes. It covers how these operations work with inheritance and the precedence of reflected dunder methods.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/binary/unions.md",
            "description": "This markdown file documents how binary operations are handled for union types in Python, illustrating supported and unsupported scenarios, resulting union types, and specific cases like `float` operations and division by zero.",
            "spof": true
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/binary/booleans.md",
            "description": "This file is a markdown test resource demonstrating how the `ruff` type checker infers types for binary operations (arithmetic and bitwise) involving boolean values, including interactions with integer types and both literal and variable operands.",
            "spof": true
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/binary/classes.md",
            "description": "This markdown file serves as a test or documentation resource for the `ty_python_semantic` crate. It demonstrates the behavior of binary union operations (`|`) on Python classes, including version-specific differences and generics, using `reveal_type` examples.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/binary/integers.md",
            "description": "This file is a markdown test resource that demonstrates type checking for Python's binary operations on integers. It covers expected type inference and error handling for arithmetic, bitwise, power, and division/modulus operations, including specific cases like division by zero.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/call/getattr_static.md",
            "description": "This file provides a detailed explanation and examples of Python's `inspect.getattr_static` function, focusing on its behavior regarding type inference, descriptor protocol bypass, error handling, and interaction with gradual types.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/call/annotation.md",
            "description": "This file is a markdown-based test resource or documentation for `ruff`'s type checker, demonstrating the behavior and expected type inference for various `typing.Callable` annotations, including valid forms, error conditions, and the use of ellipsis for parameters.",
            "spof": true
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/call/invalid_syntax.md",
            "description": "This file documents and tests various scenarios of invalid Python function signatures, demonstrating how the type checker handles syntax errors like duplicate parameters, incorrect parameter order, and non-defaulted parameters after defaulted ones.",
            "spof": true
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/call/builtins.md",
            "description": "This file is a test resource documenting how a type checker handles calls to Python built-in functions like `bool`, `str`, and `isinstance`, along with the `NotImplemented` constant. It demonstrates expected type-checking errors and type inference for various call scenarios.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/call/callable_instance.md",
            "description": "This file contains a collection of test cases and examples demonstrating various scenarios and error conditions related to Python's `__call__` method and callable instances, used for type analysis and checking.",
            "spof": true
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/call/function.md",
            "description": "This file contains examples and explanations for type checking various Python function call expressions, including simple calls, async, generic, decorated, and those involving PEP-484 positional-only parameters and splatted arguments. It serves as a test resource or documentation for the `ty` type checker within the `ruff` project.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/call/open.md",
            "description": "This markdown file documents how Ruff's type checker handles type inference for various Python file-opening functions, such as `open()`, `os.fdopen()`, `Path.open()`, and `tempfile.NamedTemporaryFile()`. It showcases the inferred return types for different modes and confirms correct behavior for common use cases like `pickle.load()`.",
            "spof": true
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/call/never.md",
            "description": "This file demonstrates that the `Never` type in Python is callable and always returns `Never`, irrespective of the arguments. It serves as a test case or documentation for the `ty_python_semantic` crate.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/call/methods.md",
            "description": "This document explains how methods work in Python, detailing concepts like functions as descriptors, bound methods, method calls on various types (literals, unions), and the interaction with metaclasses. It also includes test cases and error scenarios for method binding.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/call/subclass_of.md",
            "description": "This file contains markdown documentation and test cases for how the type checker handles calling `type[...]` expressions, particularly focusing on the constructor arguments and the inferred return type when instantiating a class or a union of classes via its type object.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/call/replace.md",
            "description": "This file documents and tests the type checking behavior of the `replace` function and the `__replace__` protocol introduced in Python 3.13, demonstrating its use with `datetime.time`, dataclasses, and NamedTuples.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/call/union.md",
            "description": "This file provides examples and test cases demonstrating how type checkers, specifically Ruff's semantic analyzer, handle union types in various call contexts. It covers scenarios like union return types, calling non-callable elements in unions, signature mismatches, and the behavior of literal unions exceeding size limits.",
            "spof": true
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/call/constructor.md",
            "description": "This document describes and demonstrates the behavior of Python class constructors (`__new__` and `__init__`), detailing their mechanics, special cases, and providing code examples with expected type-checking errors for various constructor definitions.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/call/dunder.md",
            "description": "This document describes and tests the lookup and calling behavior of Python's 'dunder' methods, using `__getitem__` as a primary example. It illustrates how these methods are handled differently from regular methods, including their interaction with types, instances, and the descriptor protocol.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/call/type.md",
            "description": "This document details the type-checking behavior of Python's built-in `type()` function, focusing on dynamic class creation. It describes how a type checker should infer types for dynamically created classes, their instances, attribute access, inheritance, and interactions within the type system.",
            "spof": true
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/comprehensions/invalid_syntax.md",
            "description": "This markdown test file demonstrates `ruff`'s semantic analysis for Python comprehensions containing various types of invalid syntax, showing the expected linter errors and type inference results for each case.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/comparison/enums.md",
            "description": "This file contains a test case demonstrating and verifying the type checking behavior of comparison operators (`==`, `!=`, `is`, `is not`) when applied to Python Enum members.",
            "spof": true
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/comparison/tuples.md",
            "description": "A markdown document detailing the behavior and type inference for tuple comparisons in Python, covering various scenarios like heterogeneous tuples, ambiguity, and operator overloading.",
            "spof": true
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/comparison/identity.md",
            "description": "This file contains Python code snippets demonstrating and testing the type inference of identity comparisons (`is`, `is not`) for different object types, including class instances and `None`, using `reveal_type`.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/comparison/non_bool_returns.md",
            "description": "This file documents and demonstrates the type inference behavior of chained comparison operators in Python when they involve non-boolean return types, using examples with custom classes and `reveal_type` outputs.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/comparison/unsupported.md",
            "description": "This file provides test cases for the `ruff` linter's type-checking, specifically demonstrating how it identifies and reports `unsupported-operator` errors for various incompatible type comparisons and operations in Python. It showcases different scenarios where operators are used with types that do not support them.",
            "spof": true
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/comparison/intersections.md",
            "description": "This file documents and tests how comparison operators behave with Python's intersection types (e.g., `A & B`, `~A`) in the Ruff type checker. It illustrates both type inference for positive and negative contributions, and diagnostics for unsupported operations.",
            "spof": true
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/comparison/integers.md",
            "description": "This file contains test cases and documentation examples for type inference of comparison operations involving integer literals and instances in Python, likely for the `ruff` linter's type-checking feature. It demonstrates expected `reveal_type` outputs for various integer comparison scenarios.",
            "spof": true
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/comparison/strings.md",
            "description": "This file provides Python code examples demonstrating how `ruff`'s type checker evaluates and infers types for various string comparison operations (e.g., `==`, `<=`, `in`, `is`). It serves as a test resource or documentation for the semantic analysis of string comparisons.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/assignment/augmented.md",
            "description": "This file contains test cases and examples demonstrating the type inference behavior of augmented assignment operations (e.g., `+=`, `-=`) in Python, covering various scenarios including dunder methods, type unions, and error handling.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/assignment/unbound.md",
            "description": "Documents how `ruff`'s type checker handles assignments to unbound variables, specifically the `unresolved-reference` diagnostic and the resulting `Unknown` type inference for such variables.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/assignment/walrus.md",
            "description": "This file contains markdown-formatted test cases demonstrating and verifying the type inference behavior of the walrus operator (assignment expression) in Python.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/assignment/annotations.md",
            "description": "This file contains a collection of test cases and examples demonstrating how type annotations for assignments, collections, and generics are interpreted and validated by a Python type checker. It illustrates both correct usage and various scenarios that lead to type errors.",
            "spof": true
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/conditional/if_statement.md",
            "description": "This file contains Python code examples demonstrating various `if`, `elif`, and `else` statement structures. It illustrates how type inference (`reveal_type`) behaves with different conditional logic and variable assignments.",
            "spof": true
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/conditional/if_expression.md",
            "description": "This file contains markdown test cases demonstrating type inference for various Python if-expressions, including nested conditions, walrus operators, and `None` handling, for the `ruff` type checker.",
            "spof": true
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/conditional/match.md",
            "description": "This file is a test resource for a Python type checker, demonstrating various scenarios and expected type inference behaviors for Python's `match` statement. It covers different pattern types, exhaustiveness checks, and interactions with `reveal_type`.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/doc/README.md",
            "description": "This file provides user-facing documentation and also functions as an extended test suite to ensure the documentation remains current.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/dataclasses/fields.md",
            "description": "This file provides various examples and test cases demonstrating the usage and type-checking behavior of `dataclasses.field` in Python, covering features like defaults, `init=False`, `default_factory`, `kw_only`, descriptors, and inheritance.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/class/super.md",
            "description": "This file provides detailed documentation and type-checking examples for Python's `super()` function, illustrating its various forms (bound, unbound, explicit, implicit) and their behaviors.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/diagnostics/no_matching_overload.md",
            "description": "This file contains test cases demonstrating the `no-matching-overload` diagnostic in a Python type checker, showcasing scenarios where function, method, or constructor calls do not match any defined overloads.",
            "spof": true
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/diagnostics/invalid_argument_type.md",
            "description": "This file contains a collection of test cases for the `invalid-argument-type` diagnostic in Ruff's Python semantic type checker. It demonstrates how the diagnostic behaves across various scenarios, including different argument types, function definitions, and file structures.",
            "spof": true
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/diagnostics/invalid_assignment.md",
            "description": "This file provides Python code examples to test and demonstrate the `invalid-assignment` diagnostic. It showcases different scenarios where type annotations are violated by incorrect value assignments.",
            "spof": true
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/diagnostics/unsupported_bool_conversion.md",
            "description": "This file provides examples and explanations of different scenarios that trigger the `unsupported-bool-conversion` diagnostic in Ruff, specifically when a class's `__bool__` method or attribute is incorrectly defined.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/diagnostics/single_matching_overload.md",
            "description": "This file demonstrates `ruff`'s type checking diagnostics for `invalid-argument-type` errors when calling overloaded functions. It includes examples for a limited number of overloads and a large number where the diagnostic message might be truncated.",
            "spof": true
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/diagnostics/special_form_attributes.md",
            "description": "This file contains a test case demonstrating and documenting diagnostic messages for invalid attribute access on Python's special forms (e.g., Any, Final, LiteralString, Self). It highlights 'unresolved-attribute' errors generated by the type checker.",
            "spof": true
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/diagnostics/unresolved_reference.md",
            "description": "This file contains diagnostic tests for unresolved references in Python code, specifically demonstrating `unresolved-reference` errors for new builtins on older Python versions and for typing builtins across different Python versions.",
            "spof": true
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/diagnostics/same_names.md",
            "description": "This file demonstrates how the `ty` type checker disambiguates objects with identical names by using their fully qualified names in diagnostic messages. It provides examples across various Python constructs like nested classes, different modules, enums, protocols, and TypedDicts.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/diagnostics/too_many_positionals.md",
            "description": "This file documents and provides examples for the 'too-many-positional-arguments' diagnostic. It explains when this diagnostic is triggered in Python code and how it is presented, particularly for non-union callables.",
            "spof": true
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/diagnostics/missing_argument_paramspec.md",
            "description": "This file is a test case or documentation for a diagnostic related to missing arguments when calling a function wrapped by a `ParamSpec` callable. It demonstrates that `*args` and `**kwargs` are required due to the unknown underlying signature.",
            "spof": true
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/diagnostics/attribute_assignment.md",
            "description": "This file is a test suite documenting various diagnostics emitted by Ruff's semantic analysis when encountering different scenarios of `obj.attr = value` attribute assignments in Python code, including type mismatches and access violations.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/diagnostics/legacy_typevars.md",
            "description": "This file documents and provides examples of various incorrect ways to create legacy `typing.TypeVar` instances, leading to `invalid-legacy-type-variable` diagnostic errors.",
            "spof": true
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/diagnostics/invalid_type_parameter_order.md",
            "description": "This file provides test cases and documentation demonstrating errors that occur when legacy type parameters in `Generic` or `Protocol` definitions are ordered incorrectly, specifically when a `TypeVar` without a default follows one with a default.",
            "spof": true
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/diagnostics/unsupported_base_dynamic_type.md",
            "description": "This file documents and tests various types that are unsupported as base classes when dynamically creating new classes using the `type()` constructor. It provides examples for `@final` classes, `Generic`, `Protocol`, `TypedDict`, and `Enum` types, demonstrating the diagnostic errors raised in each case.",
            "spof": true
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/diagnostics/union_call.md",
            "description": "This file contains test cases and examples demonstrating how the type checker handles calls to functions that are part of a union type. It illustrates the diagnostic messages generated for various call-time errors, such as incorrect arguments or non-callable types within the union.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/directives/assert_never.md",
            "description": "This markdown document explains the `assert_never` function, demonstrating its basic functionality, diagnostic output, and practical application for type narrowing and exhaustiveness checking in Python.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/directives/assert_type.md",
            "description": "This file provides test cases and documentation for the `assert_type` directive, illustrating its behavior and expected type-checking diagnostics across various Python typing scenarios.",
            "spof": true
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/expression/yield_and_yield_from.md",
            "description": "This markdown document provides examples and explanations for `yield` and `yield from` expressions in Python, focusing on their type inference, behavior with generators and custom iterables, and error cases for type checking.",
            "spof": true
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/expression/lambda.md",
            "description": "This document provides examples and tests for type inference of `lambda` expressions in Python, covering various parameter types, nesting, assignment compatibility, and introspection.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/expression/assert.md",
            "description": "This markdown test file demonstrates an `assert` statement encountering an 'unsupported-bool-conversion' error when used with an object whose `__bool__` method is incorrectly implemented as an integer.",
            "spof": true
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/expression/len.md",
            "description": "This file contains test cases and examples demonstrating how the `len()` built-in function behaves with various literal and constructed iterable types, including custom classes with `__len__` methods, and how its return type is inferred.",
            "spof": true
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/expression/if.md",
            "description": "This file contains markdown-formatted test cases and examples for the type checking behavior of Python `if` expressions. It demonstrates union types, static condition evaluation, and a specific issue related to type narrowing within `if` expressions.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/expression/attribute.md",
            "description": "This file provides test cases and documentation for type analysis of class attribute access in Python, specifically demonstrating type inference and error detection for bound, union, and possibly unbound attributes within a class context.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/expression/boolean.md",
            "description": "This file contains `reveal_type` tests for various Python boolean expressions and `bool()` function calls. It demonstrates type inference for `or`/`and` operators, and how truthiness/falsiness is determined for literals, custom classes with `__len__` or `__bool__` methods, and uncallable `__bool__` attributes.",
            "spof": true
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/import/conditional.md",
            "description": "This file documents and tests the type checker's behavior regarding conditional imports and assignments in Python, demonstrating how `reveal_type` handles potentially unbound, annotated, or reimported names under different conditions.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/import/invalid_syntax.md",
            "description": "This file contains test cases and expected diagnostics for various invalid Python import syntax scenarios, demonstrating how the type checker handles errors like missing module names and incorrect nested imports.",
            "spof": true
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/import/module_getattr.md",
            "description": "This file provides test cases and documentation for analyzing Python's module-level `__getattr__` functionality, including its basic behavior, interaction with imports, and precedence rules with explicit attributes and submodules for type checking purposes.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/import/errors.md",
            "description": "This file serves as a markdown test resource for documenting expected error messages and type inference behavior related to various import-related issues in Python, such as unresolved imports, missing members, and import cycles.",
            "spof": true
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/import/stubs.md",
            "description": "Tests and documents type inference for imported variables, demonstrating how `reveal_type` behaves when importing from Python stub files (`.pyi`) and regular Python files with type declarations.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/import/cyclic.md",
            "description": "This markdown file documents various test cases and examples related to cyclic imports and self-referential imports in Python, including regression tests for known issues and illustrations of how a type checker handles such scenarios.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/import/relative.md",
            "description": "This file contains a collection of test cases written in Markdown to verify the type checker's behavior and error reporting for various scenarios involving Python relative imports.",
            "spof": true
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/import/tracking.md",
            "description": "This markdown document describes and tests the module import tracking behavior of the type checker, highlighting design decisions like per-file and flow-insensitive analysis, and providing examples for various import scenarios.",
            "spof": true
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/import/basic.md",
            "description": "This file contains a series of test cases and examples demonstrating the behavior of Python import statements, including basic, nested, renamed, and long path imports, as well as scenarios involving unresolved modules, standard library versioning, and module shadowing for type checking.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/import/conflicts.md",
            "description": "This file demonstrates Python's behavior when import statements encounter name conflicts between package attributes and submodules. It also highlights a specific case where the type checker's inference deviates from Python's runtime behavior.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/import/partial_stub_packages.md",
            "description": "This document explains and demonstrates the concept of partial stub packages in Python type checking, detailing their behavior regarding module resolution when a stub package is incomplete. It illustrates how `py.typed` files determine partiality and the implications for type checkers.",
            "spof": true
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/import/star.md",
            "description": "A test resource or documentation file for Ruff's type checker, demonstrating the behavior of Python's wildcard (`from ... import *`) imports across various scenarios, including basic functionality, esoteric definitions, redefinitions, and public symbol export rules.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/exception/except_star.md",
            "description": "This file is a Markdown test resource for the `ruff` linter's type semantic analysis, demonstrating various uses and expected type inference for the Python 3.11 `except*` syntax.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/narrow/boolean.md",
            "description": "This markdown file serves as a test case for type narrowing in Python boolean expressions. It demonstrates how `and` and `or` operators affect type inference based on their short-circuiting behavior.",
            "spof": true
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/narrow/hasattr.md",
            "description": "This markdown document explains how the `hasattr()` function is used for type narrowing in Python, demonstrating its effects on nominal, structural, and final types, as well as its interaction with existing attributes and attributes inherited from `object`.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/narrow/while.md",
            "description": "This file provides test cases and examples demonstrating type narrowing behavior within various forms of Python `while` loops, including basic, with `else`, nested, and with `break` statements.",
            "spof": true
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/narrow/assert.md",
            "description": "This file provides Python code examples and type revelation outputs to demonstrate how `assert` statements influence type narrowing in various scenarios, including checking for `None`, truthiness, type instance, and membership. It serves as a test resource for type analysis regarding assert statements.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/narrow/type_guards.md",
            "description": "This file contains test cases and examples demonstrating the usage, behavior, and type-checking rules for user-defined `TypeGuard` and `TypeIs` functions in Python, including narrowing, parameter validation, and return type constraints.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/narrow/type.md",
            "description": "This file documents how `type(x)` expressions are handled for type narrowing in Python, including various scenarios like `is` vs. `==`, `@final` classes, generic types, and other edge cases. It provides examples demonstrating when narrowing occurs and when it does not.",
            "spof": true
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/narrow/callable.md",
            "description": "This file documents the type narrowing behavior of the `callable()` built-in function in Python's type system. It details how `callable()` transforms types, especially concerning `Top[Callable[..., object]]`, and its implications for type checking and assignment.",
            "spof": true
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/narrow/post_if_statement.md",
            "description": "This file contains markdown documentation and code examples illustrating how type narrowing in Python works after `if`, `if-else`, and `if-elif` statements, especially concerning variable mutations within conditional branches.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/narrow/assignment.md",
            "description": "This markdown test file contains examples demonstrating Python's type narrowing behavior based on assignments, covering attributes, subscripts, and complex targets. It includes scenarios for built-in types, custom classes, properties, and descriptors, illustrating how different assignment contexts affect type inference.",
            "spof": true
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/narrow/issubclass.md",
            "description": "This file contains test cases demonstrating how type narrowing behaves for `issubclass` checks under various conditions, including different `classinfo` arguments, Python versions, and special cases. It explores scenarios such as single types, tuple-based `classinfo`, PEP-604 unions, and `typing.Union`.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/narrow/isinstance.md",
            "description": "This file documents and tests type narrowing behavior for Python's `isinstance()` function, covering various scenarios for the `classinfo` argument including single types, tuples, PEP-604 unions, and special forms. It illustrates how type checkers interpret and narrow types based on these checks under different conditions and Python versions.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/narrow/match.md",
            "description": "This document provides examples and explanations of type narrowing behavior within Python's `match` statements, demonstrating how `ruff`'s type checker infers types under various pattern matching scenarios.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/narrow/truthiness.md",
            "description": "This document explains and demonstrates type narrowing behavior in Python when using truthiness checks (`if x` or `if not x`). It covers various data types and scenarios, including literals, functions, classes, and complex type unions.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/narrow/conditionals/elif_else.md",
            "description": "This file provides examples and tests for type narrowing in Python using conditional statements, specifically focusing on `if/elif/else` blocks and assignment expressions. It demonstrates how types are refined based on these conditions using `reveal_type`.",
            "spof": true
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/narrow/conditionals/not.md",
            "description": "This markdown file serves as a test or documentation for type narrowing behavior in Python, specifically demonstrating how the `not` operator in conditional statements affects type inference for variables.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/narrow/conditionals/is_not.md",
            "description": "This file provides examples and explanations of how type narrowing works in Python when using the `is not` operator in conditional statements. It demonstrates its effects on various types, including singletons, non-singletons, and in complex expressions.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/narrow/conditionals/eq.md",
            "description": "This file contains examples and tests demonstrating type narrowing behavior in Python for `==` and `!=` conditionals. It covers various scenarios including comparisons with `None`, singleton types (like `bool` and `Enum` members), literal values, and handling of custom `__eq__`/`__ne__` methods.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/narrow/conditionals/in.md",
            "description": "This file contains a collection of Python code examples and `reveal_type` annotations to demonstrate how type narrowing behaves for the `in` operator across various Python types, including literals, unions, enums, strings, and tuples.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/narrow/conditionals/boolean.md",
            "description": "This file contains test cases and examples demonstrating type narrowing behavior in Python conditional statements involving boolean expressions (`and`, `or`, `not`). It illustrates how `reveal_type` reflects type changes in different branches.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/narrow/conditionals/is.md",
            "description": "This markdown file serves as a test resource demonstrating various type narrowing behaviors for the `is` operator in Python conditionals. It covers cases like `is None`, chained comparisons, enums, `EllipsisType`, and interaction with assignment expressions and function calls.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/literal/boolean.md",
            "description": "This file documents and tests how boolean literals (`True`, `False`) are type-checked by `ruff`, showing they are interpreted as literal types.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/literal/bytes.md",
            "description": "This file contains markdown tests demonstrating how Python's type checker infers the literal types of byte strings, including concatenation and special characters. It serves as a test case for `bytes` literal type revelation.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/literal/complex.md",
            "description": "This file is a markdown test case demonstrating how complex number literals are type-hinted or revealed in Python code, specifically showing `2j` as a `complex` type.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/literal/integer.md",
            "description": "This file demonstrates how the `ruff` type checker infers types for various integer literals in Python, including edge cases like large numbers, negated values, and distinguishing them from other numeric types.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/literal/ellipsis.md",
            "description": "This file tests how the `ellipsis` literal is type-hinted or revealed by the type checker in different Python versions (3.9 and 3.10). It demonstrates the varying revealed types for `...` across these versions.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/literal/string.md",
            "description": "This file contains markdown tests for the Python semantic type checker, specifically demonstrating and verifying the inferred literal types of various string literals, including simple strings, concatenated strings, and strings with nested quotes.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/literal/collections/list.md",
            "description": "This file contains a series of Python code examples demonstrating how a type checker infers types for lists in different scenarios, including empty lists, lists of tuples, functions, mixed types, and list comprehensions. It serves as a test or documentation for type inference capabilities.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/literal/collections/set.md",
            "description": "This file contains markdown-formatted test cases demonstrating type inference for Python set literals and set comprehensions, including sets of various element types and mixed types, within the `ruff` linter's type semantic analysis framework.",
            "spof": true
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/literal/collections/tuple.md",
            "description": "This file contains markdown tests for `reveal_type` on various tuple literals, including empty, heterogeneous, and nested tuples, demonstrating how Ruff's type checker infers their types using `Literal`.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/literal/collections/dictionary.md",
            "description": "This file serves as a test case for type inference of Python dictionaries. It demonstrates how `reveal_type` analyzes various dictionary constructs, including creation, unpacking, comprehensions, and key narrowing.",
            "spof": true
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/scopes/annotate_global.md",
            "description": "This file describes how the `__annotate__` implicit global is version-gated, appearing only in Python 3.14 and later, and discusses its behavior with and without annotations.",
            "spof": true
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/scopes/class_implicit_attrs.md",
            "description": "This document describes the implicit attributes (e.g., `__qualname__`, `__module__`, `__doc__`, `__firstlineno__`) that are automatically available within Python class body scopes, including their version-specific availability, scoping rules, and a real-world use case.",
            "spof": true
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/scopes/nonlocal.md",
            "description": "This file provides comprehensive examples and explanations of Python's `nonlocal` keyword, illustrating its behavior with variable scoping, type inference, and common errors across different nesting levels and contexts.",
            "spof": true
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/scopes/global-constants.md",
            "description": "This file documents and tests the type semantic analysis of the `__debug__` global constant within Python, ensuring its `bool` type is correctly recognized across different scopes.",
            "spof": true
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/scopes/unbound.md",
            "description": "This markdown file documents and provides examples for the analysis of 'unbound' variables within different Python scopes (class, global, function local) by a type checker. It demonstrates how Ruff's type checker handles type inference and reports potential errors for such cases.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/scopes/builtin.md",
            "description": "This file documents and tests the type checker's behavior when built-in function names are conditionally shadowed by local or global variables within different scopes. It illustrates the expected and current type inference results using `reveal_type`.",
            "spof": true
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/scopes/moduletype_attrs.md",
            "description": "This file documents and tests how a type checker handles implicit global variables in Python modules, particularly those inherited from `types.ModuleType`. It illustrates their behavior when interacting with explicit assignments, declarations, and different scopes.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/libraries/numpy.md",
            "description": "This markdown file documents how `ruff` models NumPy's `DTypeLike` type, demonstrating its usage with example type definitions and function calls in a `mini_numpy` context.",
            "spof": true
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/suppressions/no_type_check.md",
            "description": "This file provides examples and explanations for how the `@no_type_check` decorator influences type checking in Python, including its effect on function bodies, nested structures, interactions with other decorators, and unsupported use cases like class decoration.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/stubs/ellipsis.md",
            "description": "This document explains the special handling of the ellipsis literal (`...`) in Python type stub files (`.pyi`), contrasting its behavior with regular Python files and the `Ellipsis` symbol.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/shadowing/class.md",
            "description": "This file is a markdown test case demonstrating how Python type checkers handle the shadowing of class names by subsequent variable assignments, differentiating between implicit and explicit shadowing scenarios.",
            "spof": true
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/shadowing/variable_declaration.md",
            "description": "This markdown test file within the ruff project demonstrates and validates the behavior of variable shadowing, specifically when a variable is declared with incompatible types in different branches before being shadowed by a final declaration.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/shadowing/function.md",
            "description": "This file contains test cases and examples for Python type semantic analysis related to function shadowing. It demonstrates scenarios where function names, parameters, or other variables are shadowed by new function definitions or assignments, and specifies the expected diagnostic behavior.",
            "spof": true
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/loops/while_loop.md",
            "description": "This file provides examples and test cases for various Python `while` loop constructs, including `else` clauses, `break` statements, nested loops, and variable boundness, to verify semantic analysis and type inference within the `ruff` project.",
            "spof": true
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/loops/async_for.md",
            "description": "This markdown document demonstrates the behavior of `async for` loops in Python, including basic usage, unpacking, and various error conditions related to the asynchronous iteration protocol (e.g., missing or malformed `__aiter__` and `__anext__` methods), along with type inference examples.",
            "spof": true
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/loops/iterators.md",
            "description": "This file contains a markdown-formatted test case demonstrating that the type checker correctly identifies when `yield from` is used with a non-iterable object, specifically showing an error when yielding from a `NotIterable` class.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/loops/for.md",
            "description": "This file contains a series of Python code examples demonstrating various scenarios of `for` loops, including different iterable types, union types, and intersection types, primarily for testing type inference and error detection in a semantic analysis context.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/type_compendium/tuple.md",
            "description": "This file documents and tests various aspects of Python tuple type checking, including instantiation, subtyping, and special cases involving `Never` and empty tuples. It serves as a reference and test suite for the type-semantic analysis of tuples in the Ruff project.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/regression/1377_iteration_count_mismatch.md",
            "description": "This file is a regression test case for `ty` issue #1377, demonstrating an iteration count mismatch with highly cyclic type variables using excerpts from the `steam.py` library.",
            "spof": true
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/subscript/stepsize_zero.md",
            "description": "This file documents the expected behavior of the `zero-stepsize-in-slice` diagnostic in Ruff, specifically noting that it should not be raised when custom types are sliced with a zero step size, unlike built-in types.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/subscript/string.md",
            "description": "This file serves as a Markdown test resource for the type checker, demonstrating the type inference behavior of string indexing and slicing operations in Python. It includes examples for `Literal` string results, `LiteralString` usage, and expected type errors for invalid subscripts.",
            "spof": true
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/subscript/bytes.md",
            "description": "This file tests and documents the type inference behavior and error reporting for `bytes` indexing and slicing operations within a Python type checker, specifically focusing on `reveal_type` outputs and `index-out-of-bounds` and `zero-stepsize-in-slice` errors.",
            "spof": true
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/subscript/lists.md",
            "description": "This file contains markdown documentation and Python code examples demonstrating type inference and error checking for list indexing, slicing, and assignments with subscripts.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/subscript/instance.md",
            "description": "This file contains Python code examples designed to test a static analysis tool's ability to diagnose correct and incorrect usage of `__getitem__` and `__setitem__` (subscript access) on custom classes, including type errors and missing methods.",
            "spof": true
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/subscript/alias.md",
            "description": "This file demonstrates how type aliases, defined through various methods (implicit, PEP 613, PEP 695), are expanded and correctly analyzed when used in subscript operations on types like tuples and literals.",
            "spof": true
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/subscript/tuple.md",
            "description": "This file documents and tests type inference for tuple indexing and slicing in Python, including heterogeneous tuples, tuple subclasses, and built-in tuple-like objects like `os.stat_result` and `sys.version_info`.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/subscript/assignment_diagnostics.md",
            "description": "This file provides diagnostic test cases and examples for various invalid subscript assignment scenarios in Python, covering issues like incorrect key or value types for lists, dictionaries, and TypedDicts, as well as missing '__setitem__' methods and union type complexities.",
            "spof": true
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/subscript/typevar.md",
            "description": "This file contains test cases and examples demonstrating the type inference behavior of Python type checkers, particularly concerning `TypeVar` (including bounds and constraints) and `ParamSpec` when used with subscripts and function signatures.",
            "spof": true
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/subscript/class.md",
            "description": "This file contains markdown-formatted test cases and explanations for Python's `__class_getitem__` and `__getitem__` methods, focusing on their type-checking behavior, error scenarios, and interactions with union, intersection, and metaclass types.",
            "spof": true
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/type_properties/str_repr.md",
            "description": "This file is a markdown test demonstrating type inference for `str()` and `repr()` calls on various `Literal` types, `LiteralString`, and basic Python types. It uses `reveal_type` to show the expected inferred types for each case.",
            "spof": true
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/type_properties/tuples_containing_never.md",
            "description": "This file demonstrates and explains that a Python tuple type containing `Never` (or `NoReturn`) as one of its type arguments simplifies to `Never`, effectively making the tuple type uninhabited. It provides examples using `static_assert` and `reveal_type`.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/type_properties/is_subtype_of.md",
            "description": "This document describes and demonstrates the `is_subtype_of` relation in Python type checking, providing examples for various type categories such as basic built-in types, class hierarchies, literal types, and different tuple types.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/type_properties/truthiness.md",
            "description": "This file provides test cases and documentation for how a type checker determines the truthiness (evaluation to boolean) of various Python types, including literals, class instances, enums, and TypedDicts. It demonstrates when `bool()` conversion results in `Literal[True]`, `Literal[False]`, or `bool`.",
            "spof": true
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/type_properties/is_equivalent_to.md",
            "description": "This markdown document describes and demonstrates the `is_equivalent_to` function, which implements an equivalence relation for various Python type constructs, including static, gradual, union, intersection, tuple, generic, and callable types. It provides numerous code examples to illustrate cases where types are considered equivalent or not equivalent.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/type_properties/is_assignable_to.md",
            "description": "This document defines and demonstrates the 'assignable-to' type relation in Python, showing various scenarios where one type can be assigned to another. It includes examples for basic types, gradual types, literal types, and class literals to illustrate the rules of type assignability.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/type_properties/is_singleton.md",
            "description": "This file documents and tests the `is_singleton` type check function, demonstrating which Python types are considered singleton types across different Python versions and scenarios. It provides examples for literals, enums, built-in types, and special typing constructs.",
            "spof": true
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/type_properties/satisfied_by_all_typevars.md",
            "description": "This file tests the satisfaction of type constraint sets, particularly how it's evaluated for inferable versus non-inferable type variables and different types of bounds. It demonstrates scenarios with unbounded, bounded, and gradually bounded type variables.",
            "spof": true
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/type_properties/is_disjoint_from.md",
            "description": "This document provides examples and explanations for the `is_disjoint_from` type-checking utility in Python, demonstrating how the disjointness relation applies to various type constructs, including built-in types, class hierarchies, dataclasses, tuples, unions, and intersections.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/type_of/typing_dot_Type.md",
            "description": "This markdown file serves as a test resource documenting the behavior and usage of `typing.Type` in Python type hinting. It demonstrates `typing.Type` as an annotation and its inheritance characteristics within the `ruff` type checker context.",
            "spof": true
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/type_of/basic.md",
            "description": "This file contains a series of Markdown-formatted test cases for the `type[]` special form in Python, demonstrating its behavior with class literals, unions, modules, and `@final` classes. It also includes tests for subtyping rules involving `type[]` with different variance annotations.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/type_of/dynamic.md",
            "description": "This file contains tests and explanations for the behavior of dynamic `type[]` annotations, specifically `type[Any]` and `type[Unknown]`. It explores their properties, assignability, and how they differ from `type` (bare) and `type[object]` in a type system.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/type_display/callable.md",
            "description": "This document provides examples and explanations for how callable types and type aliases are displayed by the type checker, covering parenthesization rules, overloaded callables, and `Top` types.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/type_qualifiers/classvar.md",
            "description": "This file is a markdown-based test and documentation for `typing.ClassVar` within a Python type inference system. It demonstrates various scenarios, correct type inference, and error handling related to `ClassVar` usage.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/type_qualifiers/initvar.md",
            "description": "This markdown file demonstrates the behavior and type-checking implications of `dataclasses.InitVar` in Python, covering valid usages, default values, overwriting, and various error conditions related to its syntax and placement.",
            "spof": true
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/unary/not.md",
            "description": "This file contains a series of test cases demonstrating the type inference behavior of the unary 'not' operator across various Python types, including built-in literals, collections, functions, modules, and custom classes with __bool__ and __len__ methods.",
            "spof": true
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/unary/integers.md",
            "description": "This file provides test cases and examples for unary operations (addition, subtraction, bitwise inversion) on integer and boolean literals, likely for Python type checking or semantic analysis.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/with/async.md",
            "description": "This file contains a series of examples and tests demonstrating the type checking and error reporting for `async with` statements in Python, including custom asynchronous context managers and built-in ones like `asyncio.timeout` and `asyncio.TaskGroup`.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/with/sync.md",
            "description": "This file contains test cases and examples for synchronous `with` statements, demonstrating valid and invalid implementations of Python context managers. It illustrates various scenarios for type checking and error reporting related to the `__enter__` and `__exit__` methods.",
            "spof": true
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/snapshots",
            "description": "This directory is intended to store test snapshots for markdown-based tests within the `ty_python_semantic` crate of the Ruff project. It would typically contain expected output or parsed structures used to validate changes in semantic analysis during development and testing.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/02_expr_subscr.py",
            "description": "This file contains simple Python subscript expressions for use as a test corpus in semantic analysis or type checking.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/05_funcall_method_multiline.py",
            "description": "This file contains a Python code snippet demonstrating a multiline method call on a string literal. It likely serves as a test case or corpus example for a type checker or semantic analysis tool to verify its handling of such constructs.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/10_if_true.py",
            "description": "This file contains examples of 'if' statements using various truthy expressions (integer, boolean, string) to test their evaluation. It likely serves as a test case within a semantic analysis corpus for Python type checking.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/24_func_if_ret.py",
            "description": "Tests type inference for a function with an if statement conditionally returning different variables.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/25_func_annotations_starred.py",
            "description": "This file is a regression test for Ruff, specifically designed to ensure the `ty_python_semantic` crate handles invalid starred return type annotations without crashing.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/26_func_const_defaults.py",
            "description": "This file contains a simple function definition with a constant default argument (None), likely serving as a test case for type analysis or semantic understanding of function defaults.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/25_func_annotations_nested.py",
            "description": "This file contains a nested class within a function, demonstrating type annotations for a class method that references a variable from the outer function's scope. It serves as a test case for semantic analysis of nested scopes and type annotations.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/25_func_annotations.py",
            "description": "This file contains a Python function definition demonstrating various types of function annotations, including type hints for arguments, return values, `*args`, and `**kwargs`. It likely serves as a test case or example within a larger semantic analysis or type checking system for Python.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/31_func_global_annotated_later.py",
            "description": "This file likely serves as a test case for type checkers or static analyzers, demonstrating a global variable declared within a function before its actual definition and annotation at the module level. It explores the interaction between `global` keyword usage and subsequent module-level type hints.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/67_with_cond_return.py",
            "description": "This file defines a Python function named `foo` that demonstrates the use of a `with` statement alongside conditional `return` statements, likely serving as a test case for semantic analysis or type checking tools.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/85_match_attr.py",
            "description": "This file contains a Python code snippet demonstrating pattern matching with a class attribute. It likely serves as a test case for a type checker or static analysis tool.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/70_class_base.py",
            "description": "This file contains test cases demonstrating class inheritance, specifically for a type checker or semantic analyzer. It shows examples of a class inheriting from a single base class and from multiple base classes.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/81_func_kwonlyargs_defaults.py",
            "description": "This file defines a Python class and method showcasing keyword-only arguments with complex default expressions involving attribute access. It likely serves as a test case for semantic analysis or type checking of such language features.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/74_class_super.py",
            "description": "This file defines a class `Foo` with methods demonstrating the use and non-use of `super().__init__()`. It likely serves as a test case for static analysis or type checking related to inheritance.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/95_annotation_assign_subscript_no_rhs.py",
            "description": "This file likely serves as a test case for a linter or type checker, demonstrating a type annotation for a subscripted expression without an explicit assignment to its right-hand side.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/95_annotation_fstring_invalid.py",
            "description": "This file is a corpus example for type analysis, demonstrating an invalid f-string used within a type annotation.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/88_regression_tuple_type_short_circuit.py",
            "description": "Regression test ensuring that type inference correctly processes all elements of a tuple, specifically preventing short-circuiting when an earlier element has a `Never` type.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/95_annotation_module.py",
            "description": "This file defines a simple type-annotated variable assignment. It likely serves as a test case or example for type analysis within the `ty_python_semantic` crate.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/95_annotation_class.py",
            "description": "This file defines a simple Python class with a type-annotated class variable, likely serving as a test case for type annotation analysis within the `ty_python_semantic` crate of the Ruff project.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/95_annotation_union.py",
            "description": "This file demonstrates the use of `typing.Union` to specify that a variable can hold values of multiple types, specifically an integer or a string.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/95_annotation_func.py",
            "description": "This file defines a simple Python function with a type annotation for its parameter. It likely serves as a test case for semantic analysis or type checking in the 'ruff' project.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/95_annotation_global_simple.py",
            "description": "This file tests the analysis of a simple type annotation for an uninitialized global variable within a function scope. It declares `some_global: int` and then attempts to print it, likely to observe how type checkers handle such a scenario.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/callable_invalid.py",
            "description": "This file provides test cases for `Callable` type annotations, specifically demonstrating invalid or incomplete usages. It is part of a corpus used for semantic analysis in a Python type checker.",
            "spof": true
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/cyclic_implicit_tuple_alias.py",
            "description": "This file is a regression test case for `ty` issue #1848, demonstrating a scenario involving cyclic implicit tuple aliases and type definitions.",
            "spof": true
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/cyclic_pep613_typevar.py",
            "description": "This file demonstrates a cyclic type definition involving `TypeVar` and `TypeAlias`, where `T` is bound to `A[0]` and `A` is an alias for `T`. It likely serves as a test case for type checkers handling PEP 613 and cyclic type dependencies.",
            "spof": true
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/callable_with_concatenate.py",
            "description": "This file defines a higher-order function `f` using `Concatenate` and `ParamSpec` to transform a callable's signature by removing its first parameter. It serves as a type-hinting example for advanced function transformations.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/98_ann_assign_simple_annotation.py",
            "description": "This file demonstrates a simple type annotation for a variable assigned to a built-in function, using `Callable` for the annotation. It serves as a test case for type checking `AnnotatedAssign` nodes.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/sub_exprs_not_found_in_evaluate_expr_compare.py",
            "description": "This file is a regression test for the `infer_expression_types` function, specifically examining how it handles sub-expressions not found during evaluation within a class context.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/ty_extensions.py",
            "description": "This file is a regression test for the `ty` type inference system. It verifies that types are correctly inferred for subexpressions within annotations using `ty_extension` special forms like `Not`, `Intersection`, `TypeOf`, and `CallableTypeOf`.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/cyclic_pep695_typevars_invalid_bound2.py",
            "description": "This file contains an example of an invalid cyclic type variable bound definition within a function signature, likely used as a test case for type analysis or validation (e.g., for PEP 695 compliance).",
            "spof": true
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/self_referential_function_annotation.py",
            "description": "This file contains a Python function with a self-referential type annotation, likely serving as a test case for type checking behavior with `from __future__ import annotations`.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/literal_slices.py",
            "description": "This file demonstrates the usage of `typing.Literal` for type hinting, specifically with a class attribute and an integer literal, likely serving as a test case for type analysis.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/cyclic_pep695_typevars_invalid_constraints.py",
            "description": "This file contains an invalid PEP 695 TypeVar definition with a cyclic constraint, likely serving as a test case for type checkers or semantic analysis tools like Ruff to identify such errors.",
            "spof": true
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/cyclic_implicit_attr_union.py",
            "description": "This file is a regression test case for a specific issue (astral-sh/ty#2085) related to how a type checker handles cyclic implicit attribute unions within a class. It defines a class with attributes that are swapped and conditionally reassigned.",
            "spof": true
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/inner_expression_inference_state.py",
            "description": "This file is a regression test for `store_expression_type`, specifically addressing issues related to the handling of generic type aliases. It ensures that the type inference system correctly processes such constructs.",
            "spof": true
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/cycle_negative_narrowing_constraints.py",
            "description": "This file is a regression test designed to reproduce a dependency graph cycle panic in Ruff's type analysis, specifically when querying negative narrowing constraints for expressions within complex conditional logic.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/98_ann_assign_annotation_future_annotations.py",
            "description": "This file provides a type annotation for the built-in `__import__` function, using `from __future__ import annotations` to support forward references in type hints. It clarifies the expected signature of the import mechanism for static analysis tools.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/classliteral_decorators_cycle.py",
            "description": "This file is a test case or corpus example for a type checker or semantic analyzer, featuring complex control flow, circular dependencies between decorators and decorated items (functions/classes), and type aliases to test its robustness.",
            "spof": true
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/cyclic_type_alias.py",
            "description": "This file contains various type alias definitions, including cyclic and conditionally defined ones. It appears to be a test case for a type checker or semantic analyzer to evaluate its handling of complex type alias scenarios.",
            "spof": true
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/except_handler_with_Any_bound_typevar.py",
            "description": "This file serves as a test case for a Python semantic or type analyzer, specifically to evaluate its handling of `except` clauses involving an `Any`-bound type variable in an invalid context (using a variable `x` directly as an exception type).",
            "spof": true
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/invalid_typevar_constraints.py",
            "description": "This file demonstrates invalid usage of a TypeVar, specifically attempting to use a type variable as an exception type in an 'except' clause. It serves as a test case for type checking or static analysis tools to identify such errors.",
            "spof": true
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/95_annotation_assign_tuple.py",
            "description": "This file contains a test case for Ruff's type semantic analysis, demonstrating an advanced or non-standard type annotation syntax applied to multiple unpacked variables in an item assignment context.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/primer",
            "description": "This directory is intended to hold foundational or introductory resources for the `ty_python_semantic` crate. It likely contains simple examples or initial data used to 'prime' or demonstrate the type-aware semantic analysis functionalities.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/tests/mdtest.rs",
            "description": "This file defines a test harness for running markdown-based tests (`.md` files) to validate the `ty_python_semantic` crate's functionality, utilizing the `datatest_stable` and `ty_test` frameworks.",
            "spof": true
          },
          {
            "path": "crates/ty_python_semantic/src/types/property_tests.rs",
            "description": "This module contains quickcheck-based property tests for the type system's `Type` implementations, verifying properties like reflexivity, symmetry, transitivity, and relationships (e.g., subtyping, assignability).",
            "spof": false
          },
          {
            "path": "crates/ty_completion_eval/truth/import-deprioritizes-sunder/main.py",
            "description": "This file is a test case to verify that module prioritization favors modules without preceding underscores over those with them.",
            "spof": true
          },
          {
            "path": "crates/ty_completion_eval/truth/import-deprioritizes-sunder/zqzqzq",
            "description": "This directory contains a Python source file used as a 'truth' or ground truth test case for evaluating type completion within the `ruff` project. Specifically, it tests how import prioritization interacts with a 'sunder' scenario in the type completion evaluation system. The unusual directory name `zqzqzq` likely serves as a unique identifier for this specific test case.",
            "spof": false
          },
          {
            "path": "crates/ty_completion_eval/truth/import-deprioritizes-dunder/main.py",
            "description": "This file tests that module import prioritization logic correctly favors modules without leading double underscores over those with them.",
            "spof": true
          },
          {
            "path": "crates/ty_completion_eval/truth/import-deprioritizes-dunder/zqzqzq",
            "description": "This directory serves as a test fixture or a specific test case for the type completion evaluation within the `ruff` linter's `ty_completion_eval` crate. It likely demonstrates and validates `ruff`'s behavior regarding how imports are handled when deprioritizing dunder methods or attributes. The `__init__.py` file indicates it is a Python package used for this specific testing scenario.",
            "spof": false
          },
          {
            "path": "crates/ty_completion_eval/truth/none-completion/main.py",
            "description": "This file appears to be a test case for evaluating type completion in the `ruff` project, specifically demonstrating `None` completion.",
            "spof": true
          },
          {
            "path": "crates/ty_completion_eval/truth/tstring-completions/main.py",
            "description": "This file appears to be a test case for f-string completion or evaluation, specifically demonstrating how an identifier within an f-string might be handled.",
            "spof": true
          },
          {
            "path": "crates/ty_completion_eval/truth/scope-simple-long-identifier/main.py",
            "description": "This file appears to be a test case for type completion or symbol resolution within the 'ruff' project, specifically checking how a long identifier is handled.",
            "spof": true
          },
          {
            "path": "crates/ty_completion_eval/truth/import-deprioritizes-type_check_only/module.py",
            "description": "Defines classes and functions, some marked with `@type_check_only`, serving as a test case to evaluate how `type_check_only` declarations are handled or deprioritized during analysis or import.",
            "spof": true
          },
          {
            "path": "crates/ty_completion_eval/truth/import-deprioritizes-type_check_only/main.py",
            "description": "This file is a test case for type completion evaluation in Ruff, specifically demonstrating scenarios where 'type-check-only' import semantics are incorrectly handled or deprioritized, highlighting known bugs related to bound methods and auto-imports.",
            "spof": true
          },
          {
            "path": "crates/ty_completion_eval/truth/ty-extensions-lower-stdlib/main.py",
            "description": "This file serves as a test case or example for type completion and inference within the `ty` project, specifically demonstrating the use of `typing.reveal_type`. It likely verifies `ty`'s behavior with standard library type extensions.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_type_checking/typing_modules_2.py",
            "description": "Tests type checking for a locally-imported type hint (DataFrame from pandas) within a function, ensuring `ruff`'s type-checking linter correctly handles such scoping. It also includes `typing_extensions` and `annotations` for context.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_type_checking/runtime_evaluated_base_classes_1.py",
            "description": "This file serves as a test fixture for a linter, demonstrating various Pydantic models with type-hinted attributes, some of which use types conditionally imported for type checking. It specifically tests how the linter handles runtime-evaluated base classes and type-checking-only imports.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_type_checking/runtime_evaluated_decorators_2.py",
            "description": "This file is a test fixture for `flake8-type-checking`, demonstrating how the linter handles type annotations within decorated classes (e.g., `attrs.define`, `dataclass`) where the types might be considered runtime-evaluated.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/flake8_type_checking/module/undefined.py",
            "description": "This file serves as a test fixture for the `flake8_type_checking` linter, demonstrating a class with an undefined base class (`MyBaseClass`). It likely tests the linter's ability to identify and flag such type-checking issues.",
            "spof": true
          },
          {
            "path": "crates/ruff_linter/resources/test/fixtures/ruff/RUF020.py",
            "description": "This file contains test cases for Ruff's type annotation analysis, specifically focusing on the `Never` and `NoReturn` types within `Union` expressions. It includes regression tests for an issue related to these types in type hints.",
            "spof": true
          }
        ],
        "contributors": [
          {
            "name": "Alex Waygood",
            "percent": 25
          },
          {
            "name": "Charlie Marsh",
            "percent": 15
          },
          {
            "name": "David Peter",
            "percent": 15
          }
        ]
      },
      "CLI and Analysis Orchestration": {
        "files": [
          {
            "path": "crates/ty/README.md",
            "description": "This README.md file introduces the 'ty' crate, describes it as a fast type checker, and provides links for contributing to it and accessing its main documentation and releases.",
            "spof": false
          },
          {
            "path": "crates/ty/docs/cli.md",
            "description": "This file provides a comprehensive reference for the command-line interface (CLI) of the 'ty' tool, detailing its commands, arguments, and options. It is auto-generated from source code documentation.",
            "spof": false
          },
          {
            "path": "crates/ty/docs/configuration.md",
            "description": "This document describes the configuration options for the `ty` tool, including settings for rules, analysis, environment, and file-specific overrides. It details how users can customize `ty`'s behavior through various settings in `pyproject.toml` or `ty.toml` files.",
            "spof": false
          },
          {
            "path": "crates/ty/docs/tracing.md",
            "description": "This document explains how to use and configure tracing in the 'ty' system, covering verbosity levels, environment variables for filtering, integration with Salsa queries, testing, and profiling for debugging and performance analysis.",
            "spof": true
          },
          {
            "path": "crates/ty/src/main.rs",
            "description": "This file serves as the main entry point for the `ty` application, orchestrating its execution, handling potential errors gracefully by printing them to stderr, and managing the application's exit status.",
            "spof": true
          },
          {
            "path": "crates/ty/src/args.rs",
            "description": "This file defines the command-line interface (CLI) arguments and subcommands for the 'ty' type checker using the `clap` crate. It structures the parsing of arguments for various operations like checking projects, starting a language server, and generating shell completions.",
            "spof": false
          },
          {
            "path": "crates/ty/src/lib.rs",
            "description": "This file serves as the main entry point and core application logic for the `ty` tool. It handles command-line arguments, orchestrates project analysis and checking (including a watch mode), and manages the application's lifecycle.",
            "spof": true
          },
          {
            "path": "crates/ty/tests/cli/file_selection.rs",
            "description": "This file contains integration tests for the command-line interface's file selection logic, specifically verifying the `--exclude` argument and the `include`/`exclude` configuration options, including their precedence rules.",
            "spof": true
          },
          {
            "path": "crates/ty/tests/cli/analysis_options.rs",
            "description": "This file contains integration tests for the `ty` CLI tool's analysis options, specifically verifying the behavior of `respect-type-ignore-comments` and the precedence and inheritance of configuration overrides for different files.",
            "spof": true
          },
          {
            "path": "crates/ty/tests/cli/config_option.rs",
            "description": "This Rust test file verifies the command-line interface's configuration handling, specifically how `--config` arguments, configuration files (`ty.toml`), and environment variables interact to set and override tool options like `terminal.error-on-warning`.",
            "spof": true
          },
          {
            "path": "crates/ty/tests/cli/rule_selection.rs",
            "description": "This file contains integration tests for verifying how the `ty` command-line tool processes and applies rule severity configurations from `pyproject.toml` and command-line arguments, including rule overrides and error handling for unknown rules.",
            "spof": false
          }
        ],
        "contributors": [
          {
            "name": "Micha Reiser",
            "percent": 73
          },
          {
            "name": "Feiyang472",
            "percent": 8
          },
          {
            "name": "Jack O'Connor",
            "percent": 6
          }
        ]
      },
      "Type-Checking Diagnostics and Rules": {
        "files": [
          {
            "path": "crates/ty/docs/rules.md",
            "description": "This file documents the various lint rules enforced by the `ruff` type checker, detailing what each rule checks for, its rationale, and examples. It is auto-generated from the lint declarations within the project.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/annotations/unsupported_type_qualifiers.md",
            "description": "This markdown document explains the current support status of various Python type qualifiers (e.g., `Final`, `ReadOnly`, `ClassVar`) within the 'ty' type checker, detailing which usages are unsupported or lead to errors.",
            "spof": true
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/function/return_type.md",
            "description": "This document describes the rules and behaviors for Python function return type checking, covering scenarios such as explicit annotations, stub functions, conditional returns, implicit returns, and special cases like `NotImplemented` and generator functions.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/suppressions/ty_ignore.md",
            "description": "This Markdown document details how to use `ty: ignore` comments to suppress type-checking errors in Python code. It covers various suppression patterns, including specific codes, and illustrates valid and invalid usage scenarios.",
            "spof": true
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/suppressions/type_ignore.md",
            "description": "This markdown document demonstrates and compares the behavior of `type: ignore` comments in Python for suppressing type-checking errors across various scenarios, with a focus on how Ruff's 'ty' type checker implements them compared to Mypy and Pyright.",
            "spof": true
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/stubs/locals.md",
            "description": "This Markdown file explains how type checkers should handle module-global variable declarations in stub files (e.g., `CONSTANT: Literal[42]`) as if they were initialized, preventing 'undefined variable' errors. It clarifies that such declarations are considered bindings for type checking purposes.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/src/suppression.rs",
            "description": "This file defines lint rules and implements the logic for parsing, validating, and checking the usage of `ty: ignore` and `type: ignore` comments within the type-checking analysis.",
            "spof": true
          },
          {
            "path": "crates/ty_python_semantic/src/types/diagnostic.rs",
            "description": "This file defines and registers a comprehensive set of type-checking diagnostics (lints) for the Ruff linter, covering a wide range of Python type-related issues such as invalid calls, type mismatches, and incorrect class definitions.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/src/types/overrides.rs",
            "description": "This file contains checks for invalid method overrides in subclasses, including violations of the Liskov Substitution Principle, prohibited NamedTuple attribute overrides, and overriding `@final` methods.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/src/types/string_annotation.rs",
            "description": "This file defines several lints for invalid or problematic string literal type annotations in Python, such as f-strings, byte-strings, raw strings, and malformed forward references. It also provides a function to parse these string annotations and report any detected issues.",
            "spof": true
          },
          {
            "path": "crates/ty_python_semantic/src/suppression/add_ignore.rs",
            "description": "This file provides functions to generate code fixes for suppressing Python lint violations by adding `ty: ignore` comments. It intelligently handles appending to existing suppressions or inserting new ones, considering single and multiple violations.",
            "spof": true
          }
        ],
        "contributors": [
          {
            "name": "Alex Waygood",
            "percent": 33
          },
          {
            "name": "Micha Reiser",
            "percent": 28
          },
          {
            "name": "Charlie Marsh",
            "percent": 14
          }
        ]
      },
      "Python Type System Modeling": {
        "files": [
          {
            "path": "crates/ty_python_semantic/resources/mdtest/liskov.md",
            "description": "This markdown file explains the Liskov Substitution Principle (LSP) and demonstrates its application in Python type checking, focusing on how method return types, parameters, and attributes must be overridden covariantly or contravariantly in subclasses.",
            "spof": true
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/ty_extensions.md",
            "description": "This document describes the internal `ty_extensions` API, which provides advanced type constructors (e.g., `Not`, `Intersection`), static assertion functionalities, and type predicates (`is_subtype_of`, `is_equivalent_to`) for Ruff's type checker.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/annotations/unsupported_special_forms.md",
            "description": "This markdown file documents which `typing` special forms are currently unsupported by 'ruff' and how they are handled, including examples of their use in annotations, type expressions, inheritance, and subscriptability.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/type_compendium/any.md",
            "description": "This document explains the `Any` type in Python's gradual type system, detailing its properties, assignability, and behavior in unions, intersections, and tuples with code examples.",
            "spof": true
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/type_compendium/README.md",
            "description": "This README serves as an introduction and table of contents for the 'type compendium', which provides detailed fact sheets on various Python types and their interpretation within the 'ty' type system. It acts as both an educational reference and a consistency guide for developers.",
            "spof": true
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/type_properties/implies_subtype_of.md",
            "description": "This file tests the `implies_subtype_of` relationship between types, which determines if one type is a subtype of another given a set of constraints. It demonstrates this behavior for concrete types, type variables, and compound types.",
            "spof": true
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/type_properties/constraints.md",
            "description": "This file defines and explains the concept of type constraints for type variables, detailing different kinds of constraints (range, negated range) and how they are combined (intersection) to manage type specialization in a type system.",
            "spof": true
          },
          {
            "path": "crates/ty_python_semantic/src/types/relation.rs",
            "description": "This file defines the `TypeRelation` enum, which enumerates and describes various relationships between types within ruff's Python type system, including subtyping, assignability, redundancy, and constraint implication, essential for type checking and inference.",
            "spof": true
          },
          {
            "path": "crates/ty_python_semantic/src/types/function.rs",
            "description": "This file defines the data structures and logic for representing Python function types, including handling generics, overloads, specializations, and decorators within the type analysis system.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/src/types/newtype.rs",
            "description": "This file defines the `NewType` struct, representing a Python `typing.NewType` declaration, and provides methods for managing its base types, relationships, and transformations within the type checking system.",
            "spof": true
          },
          {
            "path": "crates/ty_python_semantic/src/types/variance.rs",
            "description": "This file defines the `TypeVarVariance` enum and associated logic for computing, composing, and inferring type variance for type variables within a Python semantic analysis context. It provides methods for common variance operations and a trait for inferring variance within custom types.",
            "spof": true
          },
          {
            "path": "crates/ty_python_semantic/src/types/protocol_class.rs",
            "description": "This file defines the data structures and logic for representing and analyzing Python protocol classes. It includes functionality for identifying protocol classes, extracting their interfaces, validating their members, and integrating with the type-checking system.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/src/types/display.rs",
            "description": "Provides `Display` implementations and utility structures for rendering Python types and signatures, including options for formatting and capturing detailed information about the displayed elements.",
            "spof": false
          }
        ],
        "contributors": [
          {
            "name": "Douglas Creager",
            "percent": 26
          },
          {
            "name": "Alex Waygood",
            "percent": 20
          },
          {
            "name": "Micha Reiser",
            "percent": 17
          }
        ]
      },
      "Type Inference and Semantic Analysis": {
        "files": [
          {
            "path": "crates/ty_python_semantic/resources/mdtest/bidirectional.md",
            "description": "This document explains and demonstrates bidirectional type inference in the `ty` type checker. It illustrates how `ty` propagates type context through various Python constructs, such as assignments, function parameters, class attributes, constructors, and dunder calls.",
            "spof": true
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/attributes.md",
            "description": "This file documents and tests type inference rules for various ways attributes (class and instance variables) are defined and accessed within Python classes, covering different assignment and declaration scenarios.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/mro.md",
            "description": "This document provides tests and explanations for how the type checker infers the Method Resolution Order (MRO) for Python classes. It details various inheritance scenarios, including complex MROs, handling of `Unknown` types, and error conditions.",
            "spof": true
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/call/callables_as_descriptors.md",
            "description": "This document explores the descriptor behavior of Python callables, particularly how type checkers handle bound methods and `Callable` types. It discusses type-checking challenges and heuristics related to decorators, dunder methods, classmethods, and type objects.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/call/overloads.md",
            "description": "This document describes the algorithm used by the `ty` type checker for resolving overloaded function calls in Python, detailing steps such as arity checks, type checking, and argument type expansion.",
            "spof": true
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/call/str_startswith.md",
            "description": "This file demonstrates the type inference behavior for `str.startswith` in `ruff`, showing how it special-cases string literals to infer precise `Literal[True]` or `Literal[False]` types. It also illustrates when the inference falls back to a general `bool` type, such as for non-literal arguments or complex usage.",
            "spof": true
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/doc/public_type_undeclared_symbols.md",
            "description": "This document describes Ruff's unique approach to type inference for undeclared symbols, specifically its use of `Unknown | T_inferred` as a \"public type\" to prevent false positives and adhere to the gradual guarantee. It contrasts this behavior with Mypy and Pyright and clarifies the definition of a public type based on access scope.",
            "spof": true
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/directives/cast.md",
            "description": "This markdown file documents the behavior of Python's `typing.cast()` function, including how its type arguments are inferred, various error conditions it can raise (e.g., redundant casts, invalid type forms), and specific interactions with `Any`, `Unknown`, and `Todo` types within a type checking context.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/function/parameters.md",
            "description": "This document details the rules for inferring and validating Python function parameter types. It covers scenarios with annotations, default values, variadic parameters, TypedDicts, and special cases for type stubs and protocols.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/narrow/bool-call.md",
            "description": "This markdown file serves as a test case for type narrowing behavior when `bool()` is used with various arguments in Python code. It demonstrates how `bool()` calls, both valid and invalid, affect the inferred types of variables.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/narrow/len.md",
            "description": "This document describes how type narrowing is applied in the context of `len()` checks, explaining how the type of a variable can be refined based on whether `len(x)` evaluates to a truthy (non-zero) or falsy (zero) value across various Python types and scenarios.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/narrow/conditionals/nested.md",
            "description": "This file provides examples and explanations of type narrowing in Python, focusing on how it behaves within nested conditionals, comprehensions, and across different scope types, including the impact of assignments and `nonlocal` declarations.",
            "spof": true
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/scopes/eager.md",
            "description": "This document explains the concept of 'eager' and 'lazy' scopes in Python, detailing how variable references are resolved in different constructs like functions, classes, and comprehensions, with examples using `reveal_type` for type analysis. It also covers the behavior of nested scopes and annotation evaluation.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/95_annotation_func_future.py",
            "description": "This file demonstrates the use of `from __future__ import annotations` to enable postponed evaluation of type annotations. It includes a simple function with a type hint to showcase this feature.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/95_annotation_local_attr.py",
            "description": "This file tests how type annotations for new attributes on built-in types (e.g., 'int.new_attr: int') are handled within a local function scope, likely for a type checker or linter.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/resources/corpus/cycle_narrowing_constraints.py",
            "description": "This file is a regression test for a specific bug (GitHub issue #17215) related to a dependency graph cycle that caused a panic during type narrowing or constraint analysis, likely within nested conditional statements.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/src/pull_types.rs",
            "description": "This file defines a visitor that traverses an AST and attempts to infer the type for every sub-node. It is used for testing the type inference system, particularly in integration tests like 'corpus' and 'mdtest'.",
            "spof": true
          },
          {
            "path": "crates/ty_python_semantic/src/semantic_index/predicate.rs",
            "description": "This file defines the concept of 'predicates' in the type inference system, which are Python expressions whose runtime values affect type narrowing and static reachability analysis. It includes structures for various predicate types, such as expressions, patterns, and placeholder predicates for star imports.",
            "spof": true
          },
          {
            "path": "crates/ty_python_semantic/src/types/context.rs",
            "description": "This file defines the `InferContext` struct, which manages the state and diagnostics during type inference for a single file in a Python project. It provides methods for reporting type-checking diagnostics and handling specific inference scenarios like `@no_type_check` regions.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/src/types/infer.rs",
            "description": "This file implements a type inference system using Salsa queries, supporting inference at scope, definition, and expression granularities. It also handles deferred type evaluation and includes mechanisms for cycle recovery during inference.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/src/types/mro.rs",
            "description": "This file defines the `Mro` struct and implements the logic for computing the Method Resolution Order (MRO) of Python classes, including handling generic types and the C3-merge algorithm.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/src/types/subscript.rs",
            "description": "This file handles type inference for Python subscript expressions (e.g., `x[0]`, `list[int]`). It defines various errors and diagnostic reporting related to subscripting, such as out-of-bounds indices, invalid arguments, or non-subscriptable types.",
            "spof": true
          },
          {
            "path": "crates/ty_python_semantic/src/types/bound_super.rs",
            "description": "This file implements the logic for inferring the types and behavior of `super()` calls, including handling implicit arguments. It defines different error conditions for invalid `super()` usage and provides mechanisms to report associated diagnostics.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/src/types/list_members.rs",
            "description": "This file provides routines and types for listing all members (attributes, methods, variables) present on a given Python type or within a specific semantic scope, handling various type structures like unions, intersections, and class literals.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/src/types/call.rs",
            "description": "This file defines the logic for attempting to call Python methods, specifically handling binary operations by implementing Python's dunder method lookup rules, and provides error types for various calling failures within a type inference system.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/src/types/signatures.rs",
            "description": "This file defines data structures and logic for representing and manipulating function and callable signatures, including overloads and type mappings, within Ruff's Python semantic type analysis.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/src/types/narrow.rs",
            "description": "This file implements type narrowing logic, inferring type constraints on variables based on conditional expressions and patterns in Python code. It determines how predicates, such as `isinstance()` checks, refine the known types of variables within specific scopes.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/src/types/call/bind.rs",
            "description": "This file handles the binding and type-checking of arguments at a call site against the parameters of a callable in Python's type system. It manages potential unions of types and overloads to ensure correct argument-to-parameter matching and type compatibility.",
            "spof": false
          },
          {
            "path": "crates/ty_python_semantic/src/types/infer/tests.rs",
            "description": "This file contains unit tests for the Python type inference engine, verifying its behavior for various scenarios, including literal string types, string multiplication, type variables (PEP 695), and handling of unbound symbols.",
            "spof": false
          },
          {
            "path": "crates/ruff_python_semantic/src/analyze/type_inference.rs",
            "description": "This file defines analysis rules and structures for performing basic type inference on Python expressions within the Ruff linter. It includes logic to resolve expression types, handle type unions, and detect type errors.",
            "spof": false
          }
        ],
        "contributors": [
          {
            "name": "Carl Meyer",
            "percent": 27
          },
          {
            "name": "Alex Waygood",
            "percent": 15
          },
          {
            "name": "Charlie Marsh",
            "percent": 10
          }
        ]
      },
      "Module and Typeshed Resolution": {
        "files": [
          {
            "path": "crates/ty_python_semantic/resources/mdtest/call/dunder_import.md",
            "description": "This markdown document describes how the `__import__` global function and `importlib.import_module()` are handled in the `ruff` type checker for dynamic imports. It illustrates which call patterns are resolved to specific module types versus the general `ModuleType` fallback.",
            "spof": true
          },
          {
            "path": "crates/ty_python_semantic/resources/mdtest/import/conventions.md",
            "description": "This document outlines import conventions for Python, detailing how a type checker (referred to as 'ty') handles various import scenarios, including re-exports, built-in scopes, and conditional imports in stub files.",
            "spof": false
          },
          {
            "path": "crates/ty_module_resolver/src/typeshed.rs",
            "description": "This file is responsible for parsing typeshed's `VERSIONS` file to determine Python module availability across different Python versions and providing functionality to query this information.",
            "spof": true
          }
        ],
        "contributors": [
          {
            "name": "InSync",
            "percent": 47
          },
          {
            "name": "Dhruv Manilawala",
            "percent": 18
          },
          {
            "name": "Aria Desires",
            "percent": 8
          }
        ]
      }
    },
    "stats": {
      "totalFiles": 346,
      "spofCount": 149
    },
    "busFactor": 4,
    "authorCount": 37
  },
  "Web Playground & WASM Interface": {
    "description": "An interactive, web-based playground for experimenting with the linter and formatter without local installation. It is powered by a WebAssembly (WASM) build that makes Ruff's core functionality accessible in browser environments.",
    "functions": {
      "WASM Core and IDE Interface": {
        "files": [
          {
            "path": "crates/ruff_wasm/README.md",
            "description": "This README describes the Ruff WebAssembly (WASM) API, which allows linting and formatting Python code in browser environments. It includes an overview of its different targets and provides usage examples.",
            "spof": false
          },
          {
            "path": "crates/ruff_wasm/src/lib.rs",
            "description": "This file provides the WebAssembly (WASM) interface for the Ruff linter and formatter. It exposes core functionalities like linting code, managing settings, and formatting Python code to JavaScript environments.",
            "spof": false
          },
          {
            "path": "crates/ruff_wasm/tests/api.rs",
            "description": "This file contains API tests for the `ruff_wasm` crate, verifying its linting functionality (e.g., checking code, handling configurations, and reporting diagnostics) when compiled for WebAssembly. It uses `wasm_bindgen_test` to ensure the WASM API behaves as expected with various inputs and configurations.",
            "spof": false
          },
          {
            "path": "crates/ty_wasm/src/lib.rs",
            "description": "This file provides the core WebAssembly (WASM) module for Ruff's IDE functionalities, exposing methods for managing files, running diagnostics, formatting code, and performing semantic analysis (like go-to-definition) to JavaScript environments. It serves as the main entry point for the `ty_wasm` crate.",
            "spof": false
          },
          {
            "path": "crates/ty_wasm/tests/api.rs",
            "description": "This file contains a WebAssembly-specific test case for the `ty_wasm` crate. It verifies that the `Workspace` correctly identifies and reports an 'unresolved-import' diagnostic for a non-existent Python module.",
            "spof": false
          }
        ],
        "contributors": [
          {
            "name": "Micha Reiser",
            "percent": 37
          },
          {
            "name": "Brent Westbrook",
            "percent": 12
          },
          {
            "name": "Andrew Gallant",
            "percent": 8
          }
        ]
      },
      "Playground Frontend Application": {
        "files": [
          {
            "path": "playground/README.md",
            "description": "This file serves as the README for the in-browser Ruff playground, providing setup instructions, architectural details, and troubleshooting information.",
            "spof": true
          },
          {
            "path": "playground/ruff/src/constants.ts",
            "description": "This file defines `DEFAULT_PYTHON_SOURCE`, a constant string containing example Python code that calculates and prints the Fibonacci sequence. It serves as a default or placeholder source for a playground or demonstration.",
            "spof": false
          },
          {
            "path": "playground/ruff/src/main.tsx",
            "description": "This file serves as the entry point for the React application, rendering the main 'Chrome' component into the DOM. It initializes the React application by mounting the root component.",
            "spof": false
          },
          {
            "path": "playground/ruff/src/Editor/PrimarySideBar.tsx",
            "description": "This file defines the `PrimarySideBar` React component, which renders a sidebar for a playground application. It allows users to switch between 'Source' and 'Settings' views using interactive entries.",
            "spof": true
          },
          {
            "path": "playground/ruff/src/Editor/SecondarySideBar.tsx",
            "description": "This file defines the `SecondarySideBar` React component, which renders a right-hand sidebar for selecting various analysis tools or views (e.g., Format, AST, Tokens) within an editor playground interface.",
            "spof": true
          },
          {
            "path": "playground/ruff/src/Editor/Chrome.tsx",
            "description": "This file defines the main React component for the Ruff playground, which integrates a Monaco editor to allow users to write Python code and configure Ruff settings. It initializes the Ruff WebAssembly module, manages the editor state, and handles persistence and sharing of the code and settings.",
            "spof": false
          },
          {
            "path": "playground/ruff/src/Editor/Diagnostics.tsx",
            "description": "This file implements React components for displaying a list of diagnostic messages (e.g., linter errors) from `ruff_wasm`. It sorts the diagnostics, shows their details, and allows users to navigate to their corresponding locations in the code editor.",
            "spof": false
          },
          {
            "path": "playground/ruff/src/Editor/index.tsx",
            "description": "This file acts as an entry point for the Editor component, re-exporting it from its main definition file.",
            "spof": false
          },
          {
            "path": "playground/ruff/src/Editor/SourceEditor.tsx",
            "description": "This file implements a React component, `SourceEditor`, which integrates the Monaco Editor to display Python source code. It includes functionality to render Ruff linter diagnostics as editor markers and provides quick-fix code actions based on those diagnostics.",
            "spof": true
          },
          {
            "path": "playground/ruff/src/Editor/SettingsEditor.tsx",
            "description": "This file defines a React component for editing Ruff's configuration settings in a Monaco Editor. It includes functionalities to convert settings between JSON and TOML formats (for `ruff.toml` and `pyproject.toml`) and custom editor actions.",
            "spof": true
          },
          {
            "path": "playground/ruff/src/Editor/Editor.tsx",
            "description": "This file defines the main React component for an online Ruff playground or editor. It integrates various sub-components to provide an interface for editing Python code and Ruff settings, running diagnostics, and displaying different analysis outputs.",
            "spof": true
          },
          {
            "path": "playground/ruff/src/Editor/SecondaryPanel.tsx",
            "description": "This file defines a React component, `SecondaryPanel`, which renders a Monaco Editor to display various analysis results (like formatted code, AST, or tokens) from different tools. It includes functionality to parse byte ranges from the content, highlight them, and trigger an action when clicked.",
            "spof": true
          },
          {
            "path": "playground/ruff/public",
            "description": "This directory likely serves as a placeholder or target location for publicly accessible assets generated by or used within the Ruff playground environment. Despite being currently empty, its 'public' designation suggests it's intended for resources exposed to users or the browser.",
            "spof": false
          },
          {
            "path": "playground/ty/src/main.tsx",
            "description": "This file serves as the main entry point for a React application, responsible for rendering the primary 'Playground' component into the DOM.",
            "spof": false
          },
          {
            "path": "playground/ty/src/Playground.tsx",
            "description": "This React component provides the main interface for the 'ty' playground, enabling users to manage, edit, and interact with code files, including persistence and error handling, within a web-based editor environment.",
            "spof": false
          },
          {
            "path": "playground/ty/src/Editor/SecondarySideBar.tsx",
            "description": "This file defines the `SecondarySideBar` component, which renders a right-aligned sidebar for a playground editor, allowing users to select between 'AST', 'Tokens', and 'Run' views or tools.",
            "spof": false
          },
          {
            "path": "playground/ty/src/Editor/Diagnostics.tsx",
            "description": "This file defines a React component (`Diagnostics`) responsible for displaying a sorted list of code diagnostics (e.g., errors, warnings). It allows users to view diagnostic messages and navigate to their corresponding locations in the code.",
            "spof": true
          },
          {
            "path": "playground/ty/src/Editor/Editor.tsx",
            "description": "This file implements a React component for a Monaco editor tailored for Python source code. It integrates a WebAssembly-based language server to provide rich IDE features like semantic tokens, completions, diagnostics, and hover information for Python.",
            "spof": true
          },
          {
            "path": "playground/ty/src/Editor/Files.tsx",
            "description": "This file provides React components for managing and displaying a list of files in an editor playground, including functionality to add, remove, rename, and select files, along with utility functions for file type identification.",
            "spof": true
          },
          {
            "path": "playground/ty/src/Editor/SecondaryPanel.tsx",
            "description": "This file defines a React component for a secondary panel in a code playground, enabling users to view ASTs, tokens, or execute Python code in an in-browser Pyodide environment.",
            "spof": true
          },
          {
            "path": "playground/ty/src/Editor/VendoredFileBanner.tsx",
            "description": "This component renders a banner indicating that a vendored (standard library) file is currently being viewed in a read-only state, offering an option to return to the user's own file.",
            "spof": true
          },
          {
            "path": "playground/ty/src/Editor/Chrome.tsx",
            "description": "This React component serves as the main UI layout (the 'chrome') for a code editor in a playground environment. It integrates file management, a Monaco editor instance, diagnostics display, and secondary analysis tools (like AST or tokens view) for Python files, interacting with a WASM `Workspace` for code analysis.",
            "spof": false
          },
          {
            "path": "playground/ty/public",
            "description": "This directory is designated for public-facing type definitions within the `ruff` project's `playground` environment's type system. Although currently empty, it serves as a placeholder for types intended to be accessible or exposed externally within this development or testing area.",
            "spof": false
          }
        ],
        "contributors": [
          {
            "name": "Micha Reiser",
            "percent": 66
          },
          {
            "name": "renovate[bot]",
            "percent": 11
          },
          {
            "name": "Matthew Mckee",
            "percent": 8
          }
        ]
      },
      "Playground State Persistence and Sharing": {
        "files": [
          {
            "path": "playground/api/README.md",
            "description": "This file describes the playground's API, which is a key-value store based on Workers KV. It is used to persist code snippets and generate shareable URLs within the playground.",
            "spof": true
          },
          {
            "path": "playground/api/src/index.ts",
            "description": "This file implements an API for the Ruff Playground, using Cloudflare Workers KV to store and retrieve shareable code snippets. It handles GET requests to fetch snippets by ID and POST requests to save new snippets, returning a unique ID.",
            "spof": false
          },
          {
            "path": "playground/ruff/src/Editor/settings.ts",
            "description": "This file provides utilities for managing and persisting playground settings and Python source code. It handles saving and loading the playground state from local storage, URL hashes, or a backend API.",
            "spof": true
          },
          {
            "path": "playground/ruff/src/Editor/api.ts",
            "description": "This file defines API functions for interacting with a playground service, including types and methods for fetching existing playgrounds by ID and saving new playground configurations.",
            "spof": false
          },
          {
            "path": "playground/ty/src/Editor/api.ts",
            "description": "This file defines the API client for interacting with a playground service, including types for playground data and functions to fetch and save playground configurations.",
            "spof": false
          },
          {
            "path": "playground/ty/src/Editor/persist.ts",
            "description": "This file manages the persistence and restoration of the playground's workspace, supporting saving to a remote API with URL sharing and local storage.",
            "spof": true
          },
          {
            "path": "playground/shared/src/ShareButton.tsx",
            "description": "This file defines a React component `ShareButton` that provides a UI for sharing content, handling different states such as 'initial', 'copying', and 'copied' with appropriate visual feedback.",
            "spof": true
          }
        ],
        "contributors": [
          {
            "name": "mahiro",
            "percent": 48
          },
          {
            "name": "Micha Reiser",
            "percent": 42
          },
          {
            "name": "Charlie Marsh",
            "percent": 11
          }
        ]
      },
      "Shared UI Component Library": {
        "files": [
          {
            "path": "playground/shared/src/ResizeHandle.tsx",
            "description": "This file defines reusable React components for horizontal and vertical resize handles, utilizing the `react-resizable-panels` library for UI resizing functionality.",
            "spof": true
          },
          {
            "path": "playground/shared/src/theme.ts",
            "description": "This file provides a React hook and utility functions for managing light and dark mode theming, including initial theme detection, persistence, and DOM class manipulation.",
            "spof": false
          },
          {
            "path": "playground/shared/src/AstralButton.tsx",
            "description": "This file defines the `AstralButton` React component, which is a styled button with a unique visual appearance using Tailwind CSS classes. It provides a reusable UI element for interactive actions within the application.",
            "spof": true
          },
          {
            "path": "playground/shared/src/ErrorMessage.tsx",
            "description": "This file defines a React component named `ErrorMessage` that displays a styled error message. It formats the given children prop, optionally removing an 'Error: ' prefix, within a visually distinct alert box.",
            "spof": true
          },
          {
            "path": "playground/shared/src/RepoButton.tsx",
            "description": "This file defines a React component called `RepoButton` that renders a button with a GitHub-like SVG icon. It is used to create a clickable link to a repository, opening in a new tab.",
            "spof": true
          },
          {
            "path": "playground/shared/src/Icons.tsx",
            "description": "This file provides a collection of reusable SVG icon components for a React application, sourced from the VS Code icon set.",
            "spof": true
          },
          {
            "path": "playground/shared/src/Header.tsx",
            "description": "This file defines the `Header` React component for a web application's playground, including navigation, branding (Ruff/Ty logos), theme switching, sharing, and reset functionalities. It serves as the top-level navigation and utility bar for the playground.",
            "spof": true
          },
          {
            "path": "playground/shared/src/ThemeButton.tsx",
            "description": "This file defines a React component called `ThemeButton` that allows users to toggle between light and dark mode themes. It renders an `AstralButton` with corresponding SVG icons and handles the theme change logic.",
            "spof": true
          },
          {
            "path": "playground/shared/src/setupMonaco.tsx",
            "description": "This file sets up and configures the Monaco editor, defining various color constants, themes (like 'Ayu-Light'), and custom languages for the editor in a playground environment.",
            "spof": true
          },
          {
            "path": "playground/shared/src/VersionTag.tsx",
            "description": "This file defines a reusable React component called `VersionTag`. It renders a styled `div` element designed to display version information or other small labels, applying various Tailwind CSS utility classes for its appearance.",
            "spof": true
          },
          {
            "path": "playground/shared/src/SideBar.tsx",
            "description": "This file defines reusable React components for a sidebar, including the main container, individual entries, and associated tooltips. It provides common UI elements for navigation or contextual actions.",
            "spof": true
          },
          {
            "path": "playground/shared/src/index.ts",
            "description": "This file acts as a barrel file, re-exporting various shared UI components (e.g., buttons, headers, sidebar), types, and utilities (e.g., theme, icons, Monaco setup) from a `shared` library. It consolidates exports to provide a single, convenient entry point for consuming these shared assets within a playground environment.",
            "spof": true
          }
        ],
        "contributors": [
          {
            "name": "Micha Reiser",
            "percent": 86
          },
          {
            "name": "GiGaGon",
            "percent": 6
          },
          {
            "name": "Carl Meyer",
            "percent": 4
          }
        ]
      }
    },
    "stats": {
      "totalFiles": 47,
      "spofCount": 27
    },
    "busFactor": 1,
    "authorCount": 7
  }
}