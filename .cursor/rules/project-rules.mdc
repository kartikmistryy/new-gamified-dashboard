---
description: Core project rules — apply when making any changes
alwaysApply: true
---

# Project Rules

Follow these rules whenever editing or adding code in this project.

## Stack

- **Framework**: Next.js 16 (App Router)
- **UI**: React 19, TypeScript, Tailwind CSS v4
- **Styling**: Use Tailwind; keep custom CSS in `app/globals.css` when needed

## Do not touch

- **Never edit shadcn component files in `/ui`.** Treat `/ui` as a black box: add or use components only via the shadcn CLI or docs; do not modify files under `/ui` manually.
- **Never edit `app/globals.css`** except for shadcn/animate-ui theme variables and base styles. You can update CSS variables (colors, radius, etc.) and @layer base styles, but avoid other custom CSS changes.

## File size

- **Component, utility, hook, helper, and page files must stay under 160–200 lines.** If a file grows beyond that, split it: extract subcomponents, hooks, or helpers into separate files.

## Reuse

- **If a utility, component, hook, or block of code is repeated in the app, extract it into a reusable piece.** Put shared UI in `components/shared/`; shared logic in hooks or utils as appropriate.

## Components folder structure

- **Root `/components`** (at project root) must use **intent-based folders**, e.g. `components/auth/`, `components/dashboard/`, `components/forms/`, `components/layout/`.
- **Shared components** live in **`/components/shared`** — anything used in more than one intent or across the app goes here.
- **Filenames**: Use **PascalCase** for component files (e.g. `UserProfile.tsx`, `AuthForm.tsx`); use **camelCase** for hooks, utilities, helpers, and other non-component files (e.g. `useFormState.ts`, `formatDate.ts`, `getDisplayName.ts`). **Folder names**: use **lowercase only** — no kebab-case or hyphens (e.g. `auth/`, `dashboard/`, `userprofile/`).

## Dashboard architecture (org & team)

Dashboard code follows strict separation of concerns with these layers and patterns.

### Architecture layers

```
app/                      → Page routing (Server Component wrappers)
components/dashboard/pages/ → Page-level Client Components (business logic)
components/dashboard/      → Reusable dashboard UI components
lib/                      → Business logic, data, utilities
lib/shared/               → Cross-dashboard shared code
```

**Layer responsibilities**:
- **Page wrappers (`app/`)**: Server Component wrappers. Single-line render of Client Component. Future: server-side data fetching. NO `"use client"`. MAX 10 lines per page.
- **Page Client Components (`components/dashboard/pages/`)**: Page-level business logic. Marked `"use client"`. Contains useState, useMemo, data processing, filter state. Uses `useRouteParams()`. MAX 160 lines per component.
- **Reusable components (`components/dashboard/`)**: Pure rendering, props-driven, reusable across pages. NO data fetching, NO page-specific business logic. MAX 200 lines per component.
- **Lib (`lib/`)**: Data transformation, mock data generation (future: API adapters), business logic, pure functions, type definitions. MAX 200 lines per file.

**Data flow**: Backend API (future) → `lib/[dashboard]/mockData.ts` (will become API adapters) → `lib/[dashboard]/helpers.ts` (transform data) → `app/[page].tsx` (manage state, compose UI) → `components/[Component].tsx` (render UI)

### Shared lib (`lib/shared/`)

- **`lib/shared/types/`**: Shared type definitions used across org and team dashboards
  - `performanceTypes.ts`: BasePerformanceEntity, DeveloperTypeDistribution
  - `chartTypes.ts`: ChartDataPoint (org/team/member levels)
  - `timeRangeTypes.ts`: TimeRangeKey, time utilities, TIME_RANGE_OPTIONS
  - `entityTypes.ts`: MemberId, TeamId, OrgId (branded types)
  - `utilityTypes.ts`: Generic utilities
- **`lib/routes.ts`**: Centralized route utilities (URL building, param extraction)
- **`lib/get-strict-context.tsx`**: Type-safe context factory (eliminates null checks)
- **`lib/RouteParamsProvider.tsx`**: Route params context provider and `useRouteParams()` hook
- **Cross-dashboard utilities**: Shared functions used by both org and team dashboards

### Dashboard-specific lib (`lib/orgDashboard/`, `lib/teamDashboard/`)

- **`colors.ts`**: Central palette. Use `DASHBOARD_COLORS` (hex), `DASHBOARD_BG_CLASSES`, `DASHBOARD_CHANGE_CLASSES`, `DASHBOARD_TEXT_CLASSES` for segments, badges, and text. Do not hardcode hex or `bg-[#...]` in dashboard components or mock data.
- **`types.ts`**: Dashboard-specific types (e.g. TeamRow, MemberRow, filter types)
- **`helpers.ts`**: Transform functions, calculations, data processing
- **`mockData.ts`**: Mock data generators (future: will become API adapters)
- **`tableUtils.ts`**: Table-specific utilities (e.g. `getSegmentRoundedClass`, sort functions)
- **Column definitions**: Extract column configs to lib files for reusability (e.g. `PERFORMANCE_COLUMNS`)
- **Chart data transforms**: Pure functions for processing chart data (e.g. `transformToOwnershipScatterData`)

### Dashboard components

**Page-level Client Components** (`components/dashboard/pages/`):
- **Page-specific business logic**: One file per page (e.g. `TeamOverviewPageClient.tsx`, `OrgPerformancePageClient.tsx`).
- **Contains**: useState, useMemo, useCallback, data processing, filter state management, component composition.
- **Always** marked `"use client"` at top of file.
- **Named exports only**: e.g. `export function TeamOverviewPageClient()`.
- **Uses `useRouteParams()`** to access route parameters (orgId, teamId, etc.).

**Reusable dashboard components** (`components/dashboard/`):
- **Tables**: Use **`BaseTeamsTable`** with column definitions from lib. Pass `rows`, `columns`, `filterTabs`, `sortFunction`, `getRowKey`, and optional `activeFilter`/`onFilterChange` (controlled) or `defaultFilter` (uncontrolled). Use **`SegmentBar`** in column `render` functions for segment visualization. NO filter state inside BaseTeamsTable; page manages filter state.
- **Charts**: Components are pure rendering only. Receive `data` as props (already processed). Charts do NOT fetch data, do NOT transform data, do NOT manage filters. Page manages time range and passes processed data.
- **Segment bars**: Use **`SegmentBar`** with `segments` (e.g. `{ bg }[]` from `DASHBOARD_BG_CLASSES`) and `counts`. Segment colors must come from `colors.ts`.
- **Time range filters**: Use **`TimeRangeFilter`** with controlled `value`/`onChange`. No internal state; always controlled by page.
- **Sections**: Use **`DashboardSection`** for major blocks with title, optional `action` (e.g. filter UI), and `children`.
- **Composite**: Use **`GaugeWithInsights`** for gauge + insights + metric cards pattern.

### Chart components (PerformanceChart, ChaosMatrix, OwnershipScatter, etc.)

- Keep **types and data transforms** in `lib/[dashboard]/` (e.g. `ownershipScatterTypes.ts`, `ownershipScatterUtils.ts`). The React component handles only props, `useMemo` for derived data (calling lib utils), SVG rendering, legend, and local UI state (e.g. tooltip).
- **Headings and filters** live on the **page** (or in `DashboardSection` action slot), NOT inside the chart component. Chart receives `data`/`timeRange` as props.
- If a chart file exceeds 200 lines, extract subcomponents (e.g. SVG rendering) into separate files under `components/dashboard/`.

### Pages (org & team dashboards)

Dashboard pages follow the **Server Component wrapper + Client Component** pattern for optimal performance and clean separation.

**Page file structure** (`app/org/[orgId]/*/page.tsx`):
- **Server Component wrapper**: Thin, single-line render of Client Component. NO `"use client"` directive.
- **Future-ready**: Server Components will fetch data from API and pass as props to Client Component.
- **Current state**: Wrapper simply renders Client Component (data fetching happens client-side for now).

**Client Component** (`components/dashboard/pages/*PageClient.tsx`):
- **Contains all business logic**: useState, useMemo, useCallback, data processing, filter state management.
- **Marked with `"use client"`** directive at top of file.
- **Named export** (not default): e.g. `export function TeamOverviewPageClient()`.
- **Uses `useRouteParams()`** hook (NOT `useParams()` directly) to access orgId, teamId, userId, repoId.
- **Composes UI**: Use `DashboardSection`, charts, tables, filters. MAX 160 lines per Client Component.

**Example pattern**:
```tsx
// app/org/[orgId]/team/[teamId]/page.tsx (Server Component)
import { TeamOverviewPageClient } from '@/components/dashboard/pages/TeamOverviewPageClient';

export default function TeamOverviewPage() {
  return <TeamOverviewPageClient />;
}

// components/dashboard/pages/TeamOverviewPageClient.tsx (Client Component)
"use client";

import { useRouteParams } from '@/lib/RouteParamsProvider';

export function TeamOverviewPageClient() {
  const { teamId, orgId } = useRouteParams();
  // ... business logic, state, data processing
  return (/* ... UI ... */);
}
```

### Routing and navigation

**Route parameters**:
- **Use `useRouteParams()` hook** from `@/lib/RouteParamsProvider` (NOT `useParams()` from Next.js).
- **Why**: Type-safe, provides pre-bound URL builders, eliminates null checks via strict context pattern.
- **Available in all routes**: `app/org/[orgId]/layout.tsx` wraps all org-scoped routes with RouteParamsProvider.
- **Returns**: `{ orgId, teamId, userId, repoId, getOrgUrl(), getTeamUrl(), getUserUrl(), getRepoUrl() }`.

**URL building**:
- **Use route utilities** from `@/lib/routes.ts` (NOT manual template literals).
- **Available functions**: `getOrgPath(orgId, tab?)`, `getTeamPath(orgId, teamId, tab?)`, `getUserPath(orgId, userId, tab?)`, `getRepoPath(orgId, repoId, tab?)`.
- **Extraction functions**: `extractOrgId(pathname)`, `extractTeamId(pathname)`, `extractUserId(pathname)`, `extractRepoId(pathname)`.
- **Never write**: `` `/org/${orgId}/team/${teamId}` `` — use `getTeamPath(orgId, teamId)` instead.

**Context pattern**:
- **Use `getStrictContext<T>(displayName)`** from `@/lib/get-strict-context` to create type-safe contexts.
- **Returns**: `[Context, useHook]` tuple where `useHook()` throws descriptive error if used outside provider.
- **Eliminates null checks**: Hook never returns null when used inside provider (runtime safety).

### Backend integration (future)

- **Current**: Mock data files generate static data
- **Future**: Mock data files become API adapters
- **Migration**: Replace `generateTeamPerformanceData(teamId, orgId)` with `fetchTeamPerformanceData(teamId, orgId, timeRange)` that calls API, transforms response, and returns frontend types
- **No component changes**: Components receive same prop types; only data source changes
- See `refactor_docs/BACKEND_INTEGRATION.md` for detailed migration guide

## Conventions

1. **Files & structure**
   - Use `app/` for routes and layouts; put feature-specific components under `components/<intent>/` or `components/shared/`.

2. **Components**
   - Prefer functional components and hooks; type all props with TypeScript; avoid `any`.
   - One clear responsibility per component or hook; if it does two things, split it.

3. **Code style**
   - Use double quotes for strings unless the file already uses single quotes.
   - Run `npm run lint` and fix issues before considering changes done.
   - Prefer `const`; use `let` only when reassignment is needed.

4. **When making changes**
   - Preserve existing patterns and naming in the files you touch.
   - Don’t remove or rename exports or props without checking usages.
   - Prefer small, incremental edits unless refactoring was requested.

5. **Accessibility & UX**
   - Use semantic HTML and ARIA where needed; ensure keyboard access and visible focus states.

## Clean code

- **Names**: Use descriptive names (e.g. `getUserDisplayName`, `isFormValid`); avoid abbreviations unless widely used (e.g. `id`, `url`).
- **Functions**: Keep functions small and focused; if a function does multiple steps, consider splitting or extracting helpers.
- **Nesting**: Avoid deep nesting (e.g. > 3 levels); use early returns, guard clauses, or extract logic into named functions.
- **Constants**: Extract magic numbers and repeated strings into named constants or enums at the top of the file or in a shared constants file.
- **Imports**: Prefer explicit, named exports; use path aliases consistently (e.g. `@/components/...`) if configured in the project.
- **No dead code**: Remove unused imports, variables, and functions; don’t leave commented-out code or debug logs.

## Don’t

- Don’t add new dependencies without good reason; prefer built-in or existing packages.
- Don’t change formatting or style unrelated to the requested change (no “fix all the formatting” unless asked).
- Don’t edit files under `/ui` (shadcn components).
