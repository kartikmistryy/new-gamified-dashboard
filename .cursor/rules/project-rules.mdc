---
description: Core project rules — apply when making any changes
alwaysApply: true
---

# Project Rules

Follow these rules whenever editing or adding code in this project.

## Stack

- **Framework**: Next.js 16 (App Router)
- **UI**: React 19, TypeScript, Tailwind CSS v4
- **Styling**: Use Tailwind; keep custom CSS in `app/globals.css` when needed

## Do not touch

- **Never edit shadcn component files in `/ui`.** Treat `/ui` as a black box: add or use components only via the shadcn CLI or docs; do not modify files under `/ui` manually.
- **Never edit `app/globals.css`** except for shadcn/animate-ui theme variables and base styles. You can update CSS variables (colors, radius, etc.) and @layer base styles, but avoid other custom CSS changes.

## File size

- **Component, utility, hook, helper, and page files must stay under 160–200 lines.** If a file grows beyond that, split it: extract subcomponents, hooks, or helpers into separate files.

## Reuse

- **If a utility, component, hook, or block of code is repeated in the app, extract it into a reusable piece.** Put shared UI in `components/shared/`; shared logic in hooks or utils as appropriate.

## Components folder structure

- **Root `/components`** (at project root) must use **intent-based folders**, e.g. `components/auth/`, `components/dashboard/`, `components/forms/`, `components/layout/`.
- **Shared components** live in **`/components/shared`** — anything used in more than one intent or across the app goes here.
- **Filenames**: Use **PascalCase** for component files (e.g. `UserProfile.tsx`, `AuthForm.tsx`); use **camelCase** for hooks, utilities, helpers, and other non-component files (e.g. `useFormState.ts`, `formatDate.ts`, `getDisplayName.ts`). **Folder names**: use **lowercase only** — no kebab-case or hyphens (e.g. `auth/`, `dashboard/`, `userprofile/`).

## Dashboard architecture (org & team)

Dashboard code follows strict separation of concerns with these layers and patterns.

### Architecture layers

```
app/               → Page composition (thin, delegation only)
components/        → UI components (rendering only)
lib/               → Business logic, data, utilities
lib/shared/        → Cross-dashboard shared code
```

**Layer responsibilities**:
- **Pages (`app/`)**: Route definition, data fetching (future: API calls), filter state management, component composition. NO business logic, NO data transformation. MAX 160 lines per page.
- **Components (`components/`)**: Pure rendering, props-driven, reusable across contexts. NO data fetching, NO business logic. MAX 200 lines per component.
- **Lib (`lib/`)**: Data transformation, mock data generation (future: API adapters), business logic, pure functions, type definitions. MAX 200 lines per file.

**Data flow**: Backend API (future) → `lib/[dashboard]/mockData.ts` (will become API adapters) → `lib/[dashboard]/helpers.ts` (transform data) → `app/[page].tsx` (manage state, compose UI) → `components/[Component].tsx` (render UI)

### Shared lib (`lib/shared/`)

- **`lib/shared/types/`**: Shared type definitions used across org and team dashboards
  - `performanceTypes.ts`: BasePerformanceEntity, DeveloperTypeDistribution
  - `chartTypes.ts`: ChartDataPoint (org/team/member levels)
  - `timeRangeTypes.ts`: TimeRangeKey, time utilities, TIME_RANGE_OPTIONS
  - `entityTypes.ts`: MemberId, TeamId, OrgId (branded types)
  - `utilityTypes.ts`: Generic utilities
- **Cross-dashboard utilities**: Shared functions used by both org and team dashboards

### Dashboard-specific lib (`lib/orgDashboard/`, `lib/teamDashboard/`)

- **`colors.ts`**: Central palette. Use `DASHBOARD_COLORS` (hex), `DASHBOARD_BG_CLASSES`, `DASHBOARD_CHANGE_CLASSES`, `DASHBOARD_TEXT_CLASSES` for segments, badges, and text. Do not hardcode hex or `bg-[#...]` in dashboard components or mock data.
- **`types.ts`**: Dashboard-specific types (e.g. TeamRow, MemberRow, filter types)
- **`helpers.ts`**: Transform functions, calculations, data processing
- **`mockData.ts`**: Mock data generators (future: will become API adapters)
- **`tableUtils.ts`**: Table-specific utilities (e.g. `getSegmentRoundedClass`, sort functions)
- **Column definitions**: Extract column configs to lib files for reusability (e.g. `PERFORMANCE_COLUMNS`)
- **Chart data transforms**: Pure functions for processing chart data (e.g. `transformToOwnershipScatterData`)

### Dashboard components (`components/dashboard/`)

- **Tables**: Use **`BaseTeamsTable`** with column definitions from lib. Pass `rows`, `columns`, `filterTabs`, `sortFunction`, `getRowKey`, and optional `activeFilter`/`onFilterChange` (controlled) or `defaultFilter` (uncontrolled). Use **`SegmentBar`** in column `render` functions for segment visualization. NO filter state inside BaseTeamsTable; page manages filter state.
- **Charts**: Components are pure rendering only. Receive `data` as props (already processed). Charts do NOT fetch data, do NOT transform data, do NOT manage filters. Page manages time range and passes processed data.
- **Segment bars**: Use **`SegmentBar`** with `segments` (e.g. `{ bg }[]` from `DASHBOARD_BG_CLASSES`) and `counts`. Segment colors must come from `colors.ts`.
- **Time range filters**: Use **`TimeRangeFilter`** with controlled `value`/`onChange`. No internal state; always controlled by page.
- **Sections**: Use **`DashboardSection`** for major blocks with title, optional `action` (e.g. filter UI), and `children`.
- **Composite**: Use **`GaugeWithInsights`** for gauge + insights + metric cards pattern.

### Chart components (PerformanceChart, ChaosMatrix, OwnershipScatter, etc.)

- Keep **types and data transforms** in `lib/[dashboard]/` (e.g. `ownershipScatterTypes.ts`, `ownershipScatterUtils.ts`). The React component handles only props, `useMemo` for derived data (calling lib utils), SVG rendering, legend, and local UI state (e.g. tooltip).
- **Headings and filters** live on the **page** (or in `DashboardSection` action slot), NOT inside the chart component. Chart receives `data`/`timeRange` as props.
- If a chart file exceeds 200 lines, extract subcomponents (e.g. SVG rendering) into separate files under `components/dashboard/`.

### Pages (org & team dashboards)

- **Thin delegation only**: Pages fetch data (currently from mock, future from API), manage filter state, compose components. NO business logic. MAX 160 lines.
- Use **`DashboardSection`** to wrap each major block (title + optional action + content). Use **`TimeRangeFilter`** in the section `action` when needed.
- Pass filter state and handlers from page into components; components do NOT own state.
- Process data in page using lib helpers before passing to components (e.g. `const sortedData = useMemo(() => sortFunction(data, filter), [data, filter])`).

### Backend integration (future)

- **Current**: Mock data files generate static data
- **Future**: Mock data files become API adapters
- **Migration**: Replace `generateTeamPerformanceData(teamId, orgId)` with `fetchTeamPerformanceData(teamId, orgId, timeRange)` that calls API, transforms response, and returns frontend types
- **No component changes**: Components receive same prop types; only data source changes
- See `refactor_docs/BACKEND_INTEGRATION.md` for detailed migration guide

## Conventions

1. **Files & structure**
   - Use `app/` for routes and layouts; put feature-specific components under `components/<intent>/` or `components/shared/`.

2. **Components**
   - Prefer functional components and hooks; type all props with TypeScript; avoid `any`.
   - One clear responsibility per component or hook; if it does two things, split it.

3. **Code style**
   - Use double quotes for strings unless the file already uses single quotes.
   - Run `npm run lint` and fix issues before considering changes done.
   - Prefer `const`; use `let` only when reassignment is needed.

4. **When making changes**
   - Preserve existing patterns and naming in the files you touch.
   - Don’t remove or rename exports or props without checking usages.
   - Prefer small, incremental edits unless refactoring was requested.

5. **Accessibility & UX**
   - Use semantic HTML and ARIA where needed; ensure keyboard access and visible focus states.

## Clean code

- **Names**: Use descriptive names (e.g. `getUserDisplayName`, `isFormValid`); avoid abbreviations unless widely used (e.g. `id`, `url`).
- **Functions**: Keep functions small and focused; if a function does multiple steps, consider splitting or extracting helpers.
- **Nesting**: Avoid deep nesting (e.g. > 3 levels); use early returns, guard clauses, or extract logic into named functions.
- **Constants**: Extract magic numbers and repeated strings into named constants or enums at the top of the file or in a shared constants file.
- **Imports**: Prefer explicit, named exports; use path aliases consistently (e.g. `@/components/...`) if configured in the project.
- **No dead code**: Remove unused imports, variables, and functions; don’t leave commented-out code or debug logs.

## Don’t

- Don’t add new dependencies without good reason; prefer built-in or existing packages.
- Don’t change formatting or style unrelated to the requested change (no “fix all the formatting” unless asked).
- Don’t edit files under `/ui` (shadcn components).
