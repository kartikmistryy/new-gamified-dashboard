---
phase: 05-architectural-alignment
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - lib/get-strict-context.tsx
  - lib/RouteParamsProvider.tsx
  - app/org/[orgId]/layout.tsx
  - components/dashboard/layout/helpers/dashboardTabHelpers.ts
autonomous: true

must_haves:
  truths:
    - "getStrictContext utility creates type-safe contexts that throw on null access"
    - "RouteParamsProvider extracts orgId, teamId, userId, repoId from pathname and exposes them via context"
    - "useRouteParams() hook returns typed route params without null possibility when inside provider"
    - "All pages under /org/[orgId]/ are wrapped by RouteParamsProvider via layout"
    - "URL building in dashboardTabHelpers uses centralized route utilities instead of manual string concatenation"
  artifacts:
    - path: "lib/get-strict-context.tsx"
      provides: "Type-safe context factory"
      exports: ["getStrictContext"]
    - path: "lib/RouteParamsProvider.tsx"
      provides: "Route params context provider and hook"
      exports: ["RouteParamsProvider", "useRouteParams"]
    - path: "app/org/[orgId]/layout.tsx"
      provides: "Org-level layout wrapping children with RouteParamsProvider"
      exports: ["default"]
    - path: "components/dashboard/layout/helpers/dashboardTabHelpers.ts"
      provides: "Tab config builder using centralized route utilities"
      contains: "getTeamPath|getOrgPath|getUserPath|getRepoPath"
  key_links:
    - from: "lib/RouteParamsProvider.tsx"
      to: "lib/get-strict-context.tsx"
      via: "import getStrictContext"
      pattern: "getStrictContext"
    - from: "lib/RouteParamsProvider.tsx"
      to: "lib/routes.ts"
      via: "import extract/get functions"
      pattern: "extractOrgId|extractTeamId|getOrgPath|getTeamPath"
    - from: "app/org/[orgId]/layout.tsx"
      to: "lib/RouteParamsProvider.tsx"
      via: "import and render RouteParamsProvider"
      pattern: "RouteParamsProvider"
    - from: "components/dashboard/layout/helpers/dashboardTabHelpers.ts"
      to: "lib/routes.ts"
      via: "import route builders"
      pattern: "getTeamPath|getOrgPath|getUserPath|getRepoPath"
---

<objective>
Create the architectural foundation: a strict context utility, RouteParamsProvider context, org-level layout wrapper, and refactor URL building to use centralized route utilities.

Purpose: Establishes the three infrastructure pieces (strict context, route params provider, org layout) that all subsequent page migrations depend on, and eliminates manual URL string concatenation in dashboardTabHelpers.ts.

Output: Four files - `lib/get-strict-context.tsx`, `lib/RouteParamsProvider.tsx`, `app/org/[orgId]/layout.tsx`, and updated `dashboardTabHelpers.ts`.
</objective>

<execution_context>
@/Users/kartikmistry/.claude/get-shit-done/workflows/execute-plan.md
@/Users/kartikmistry/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-architectural-alignment-with-best-practices/05-RESEARCH.md

@lib/routes.ts
@components/dashboard/layout/helpers/dashboardTabHelpers.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create strict context utility and RouteParamsProvider</name>
  <files>lib/get-strict-context.tsx, lib/RouteParamsProvider.tsx</files>
  <action>
Create two new files:

**1. `lib/get-strict-context.tsx`** - Type-safe context factory:

```tsx
import { createContext, useContext } from 'react';

/**
 * Creates a type-safe context that throws at runtime if used outside its provider.
 * Eliminates null checks at every call site.
 *
 * @example
 * const [MyContext, useMyContext] = getStrictContext<MyValue>('MyContext');
 */
export function getStrictContext<T>(displayName: string) {
  const context = createContext<T | null>(null);
  context.displayName = displayName;

  function useStrictContext() {
    const value = useContext(context);
    if (value === null) {
      throw new Error(`use${displayName} must be used within ${displayName}Provider`);
    }
    return value;
  }

  return [context, useStrictContext] as const;
}
```

**2. `lib/RouteParamsProvider.tsx`** - Route params context using strict context:

```tsx
'use client';

import { usePathname } from 'next/navigation';
import { getStrictContext } from '@/lib/get-strict-context';
import {
  extractOrgId,
  extractTeamId,
  extractUserId,
  extractRepoId,
  getOrgPath,
  getTeamPath,
  getUserPath,
  getRepoPath,
} from '@/lib/routes';

interface RouteParamsContextValue {
  orgId: string | null;
  teamId: string | null;
  userId: string | null;
  repoId: string | null;
  getOrgUrl: (tab?: string) => string;
  getTeamUrl: (teamId: string, tab?: string) => string;
  getUserUrl: (userId: string, tab?: string) => string;
  getRepoUrl: (repoId: string, tab?: string) => string;
}

const [RouteParamsContext, useRouteParams] =
  getStrictContext<RouteParamsContextValue>('RouteParams');

export { useRouteParams };

export function RouteParamsProvider({ children }: { children: React.ReactNode }) {
  const pathname = usePathname();

  const orgId = extractOrgId(pathname);
  const teamId = extractTeamId(pathname);
  const userId = extractUserId(pathname);
  const repoId = extractRepoId(pathname);

  const value: RouteParamsContextValue = {
    orgId,
    teamId,
    userId,
    repoId,
    getOrgUrl: (tab) => getOrgPath(orgId!, tab),
    getTeamUrl: (tid, tab) => getTeamPath(orgId!, tid, tab),
    getUserUrl: (uid, tab) => getUserPath(orgId!, uid, tab),
    getRepoUrl: (rid, tab) => getRepoPath(orgId!, rid, tab),
  };

  return (
    <RouteParamsContext.Provider value={value}>
      {children}
    </RouteParamsContext.Provider>
  );
}
```

Key design decisions:
- Uses `getStrictContext` so `useRouteParams()` never returns null (throws if outside provider)
- Imports from existing `lib/routes.ts` for all extraction and path building
- Marked `'use client'` since it uses `usePathname` hook
- URL builders are pre-bound with `orgId` for convenience
  </action>
  <verify>
Run `npx tsc --noEmit` to confirm no TypeScript errors.
Verify both files exist and export the expected symbols:
- `lib/get-strict-context.tsx` exports `getStrictContext`
- `lib/RouteParamsProvider.tsx` exports `RouteParamsProvider` and `useRouteParams`
  </verify>
  <done>
Both utility files compile without errors. `getStrictContext` returns a `[Context, useHook]` tuple. `RouteParamsProvider` wraps children with route param context. `useRouteParams()` returns typed `{ orgId, teamId, userId, repoId, getOrgUrl, getTeamUrl, getUserUrl, getRepoUrl }`.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create org layout wrapper and refactor URL building</name>
  <files>app/org/[orgId]/layout.tsx, components/dashboard/layout/helpers/dashboardTabHelpers.ts</files>
  <action>
**1. Create `app/org/[orgId]/layout.tsx`** - Org-level layout wrapping all org routes with RouteParamsProvider:

```tsx
import { RouteParamsProvider } from '@/lib/RouteParamsProvider';

export default function OrgLayout({ children }: { children: React.ReactNode }) {
  return (
    <RouteParamsProvider>
      {children}
    </RouteParamsProvider>
  );
}
```

This is a Server Component that renders the client-side RouteParamsProvider. All pages under `/org/[orgId]/` (including team, user, repo sub-routes) automatically get access to `useRouteParams()`.

**2. Refactor `dashboardTabHelpers.ts`** - Replace manual URL string concatenation in `buildTabConfigs` with centralized route utilities.

In the `buildTabConfigs` function, replace the manual URL building block (the `if (orgId)` block at lines 95-123) with calls to `getTeamPath`, `getUserPath`, `getRepoPath`, `getOrgPath` from `lib/routes.ts`.

Add these imports at the top of the file (they are already partially imported but need the path builders):
```typescript
import {
  getOrgPath,
  getTeamPath,
  getUserPath,
  getRepoPath,
} from "@/lib/routes";
```

Replace the manual URL building in `buildTabConfigs`:

**BEFORE (lines 95-123):**
```typescript
if (orgId) {
  if (dashboardType === "team" && teamId) {
    href = tab.key === "overview"
      ? `/org/${orgId}/team/${teamId}`
      : `/org/${orgId}/team/${teamId}/${tab.key}`
  } else if (dashboardType === "user" && userId) {
    // ... manual string building
  }
  // ... etc
}
```

**AFTER:**
```typescript
if (orgId) {
  const tabKey = tab.key === "overview" ? undefined : tab.key;
  if (dashboardType === "team" && teamId) {
    href = getTeamPath(orgId, teamId, tabKey);
  } else if (dashboardType === "user" && userId) {
    href = getUserPath(orgId, userId, tabKey);
  } else if (dashboardType === "repo" && repoId) {
    href = getRepoPath(orgId, repoId, tabKey);
  } else {
    href = getOrgPath(orgId, tabKey);
  }
} else {
  // Fallback for non-org routes (keep existing logic)
  const normalizedBasePath = normalizeBasePath(basePath);
  href = tab.key === "overview"
    ? normalizedBasePath
    : `${normalizedBasePath === "/" ? "" : normalizedBasePath}/${tab.key}`;
}
```

Keep the existing imports of `extractOrgId`, `extractTeamId`, `extractUserId`, `extractRepoIdFromRoutes` since they are still needed for param extraction in this utility function. The function stays as a pure utility (no context dependency).
  </action>
  <verify>
1. Run `npx tsc --noEmit` to confirm no TypeScript errors.
2. Run `npm run build` (or `npx next build`) to verify the layout integrates correctly with the existing app structure.
3. Verify `app/org/[orgId]/layout.tsx` exists and wraps children with RouteParamsProvider.
4. Verify `dashboardTabHelpers.ts` no longer contains manual URL template literals like `` `/org/${orgId}/team/${teamId}` ``.
  </verify>
  <done>
Org layout exists at `app/org/[orgId]/layout.tsx` wrapping all org-scoped routes with RouteParamsProvider. The `buildTabConfigs` function in `dashboardTabHelpers.ts` uses `getTeamPath`, `getUserPath`, `getRepoPath`, `getOrgPath` instead of manual string concatenation. The app builds successfully with no TypeScript errors.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with zero errors
2. `npm run build` completes successfully
3. All four files exist with correct exports
4. No manual URL template literals remain in `dashboardTabHelpers.ts` `buildTabConfigs` function
5. Existing pages still render correctly (RouteParamsProvider is additive, doesn't break existing useParams usage)
</verification>

<success_criteria>
- `getStrictContext` utility exists and creates typed context/hook pairs
- `RouteParamsProvider` provides `orgId`, `teamId`, `userId`, `repoId` from pathname
- `useRouteParams()` returns typed route params (never null when inside provider)
- Org layout wraps all `/org/[orgId]/` routes with RouteParamsProvider
- `dashboardTabHelpers.ts` uses centralized route utilities for all URL building
- App builds and runs without errors
</success_criteria>

<output>
After completion, create `.planning/phases/05-architectural-alignment-with-best-practices/05-01-SUMMARY.md`
</output>
