---
phase: 01-foundation-type-system
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - lib/teamDashboard/types.ts
  - lib/teamDashboard/overviewMockData.ts
autonomous: true

must_haves:
  truths:
    - "MemberPerformanceRow type exists with level discriminant preventing confusion with TeamPerformanceRow"
    - "MemberTableFilter type exists with same filter keys as TeamTableFilter"
    - "Mock generator produces 5-8 member rows per team whose average performance approximately equals team gauge value (within 5-10%)"
    - "Member type distributions aggregate approximately to team type distributions"
    - "Star performers have 2-5x median performance, long tail matches realistic engineering teams"
  artifacts:
    - path: "lib/teamDashboard/types.ts"
      provides: "Member-level type definitions"
      exports: ["MemberPerformanceRow", "MemberTableFilter"]
    - path: "lib/teamDashboard/overviewMockData.ts"
      provides: "Member mock data generator"
      exports: ["getMemberPerformanceRowsForTeam"]
  key_links:
    - from: "lib/teamDashboard/types.ts"
      to: "lib/orgDashboard/types.ts"
      via: "shared typeDistribution shape"
      pattern: "typeDistribution.*star.*timeBomb.*keyRole"
    - from: "lib/teamDashboard/overviewMockData.ts"
      to: "lib/orgDashboard/overviewMockData.ts"
      via: "reuses getPerformanceGaugeLabel, getPerformanceBarColor, getTypeDistributionForPerformance"
      pattern: "import.*from.*orgDashboard"
---

<objective>
Create member-level TypeScript types and mock data generators that form the data foundation for the Team Dashboard.

Purpose: All subsequent plans (MemberTable, tab pages, charts) depend on having well-typed member data with realistic distributions. This plan establishes the `lib/teamDashboard/` module mirroring `lib/orgDashboard/`.

Output: Two files -- `types.ts` with member type definitions using discriminated unions, and `overviewMockData.ts` with a generator that produces member rows whose averages aggregate approximately to team totals.
</objective>

<execution_context>
@/Users/kartikmistry/.claude/get-shit-done/workflows/execute-plan.md
@/Users/kartikmistry/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-type-system/01-CONTEXT.md
@.planning/phases/01-foundation-type-system/01-RESEARCH.md

Key existing files to reference:
@lib/orgDashboard/types.ts — existing team types (TeamPerformanceRow, TeamTableFilter, SummaryCardKey, typeDistribution shape)
@lib/orgDashboard/overviewMockData.ts — existing team mock generator (TEAM_VALUE_OFFSETS, getTeamPerformanceRowsForGauge, lerp, getTypeDistributionForPerformance)
@lib/orgDashboard/utils.ts — getPerformanceGaugeLabel
@lib/orgDashboard/tableUtils.ts — getPerformanceBarColor
@lib/orgDashboard/colors.ts — DASHBOARD_COLORS
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create member type definitions</name>
  <files>lib/teamDashboard/types.ts</files>
  <action>
Create `lib/teamDashboard/types.ts` with the following types:

1. **MemberPerformanceRow** -- parallel to TeamPerformanceRow but with member-specific fields:
   - `level: "member"` -- discriminant field for type safety (per research recommendation)
   - `rank: number`
   - `memberName: string`
   - `memberAvatar: string` -- URL string (use DiceBear API pattern like existing TeamAvatar: `https://api.dicebear.com/9.x/initials/svg?seed={memberName}`)
   - `teamId: string` -- which team this member belongs to
   - `performanceLabel: string` -- from getPerformanceGaugeLabel
   - `performanceValue: number` -- 0-100
   - `trend: "up" | "down" | "flat"`
   - `performanceBarColor: string` -- from getPerformanceBarColor
   - `changePts?: number` -- optional change in points
   - `typeDistribution: { star: number; timeBomb: number; keyRole: number; bottleneck: number; risky: number; legacy: number }` -- same shape as TeamPerformanceRow

2. **MemberTableFilter** -- same filter options as TeamTableFilter for consistency:
   ```typescript
   export type MemberTableFilter = "mostProductive" | "leastProductive" | "mostOptimal" | "mostRisky";
   ```

Do NOT add a `level` field to the existing TeamPerformanceRow in `lib/orgDashboard/types.ts` -- that would be a breaking change. The discriminant is only on the new MemberPerformanceRow type. If shared typing is needed later, it can be added in Phase 2+.

Follow codebase conventions:
- Named exports (not default)
- PascalCase for types
- `import type` for any imports
- Use `export type` keyword
  </action>
  <verify>Run `npx tsc --noEmit` and confirm no TypeScript errors. Verify the file exports MemberPerformanceRow and MemberTableFilter.</verify>
  <done>MemberPerformanceRow type exists with level:"member" discriminant, memberName, memberAvatar, teamId, performanceValue, trend, typeDistribution fields. MemberTableFilter type exists with 4 filter keys matching TeamTableFilter.</done>
</task>

<task type="auto">
  <name>Task 2: Create member mock data generator</name>
  <files>lib/teamDashboard/overviewMockData.ts</files>
  <action>
Create `lib/teamDashboard/overviewMockData.ts` with a `getMemberPerformanceRowsForTeam` function.

**Function signature:**
```typescript
export function getMemberPerformanceRowsForTeam(
  teamPerformanceValue: number,
  teamId: string,
  memberCount?: number
): MemberPerformanceRow[]
```

**Parameters:**
- `teamPerformanceValue`: The team's performance value (0-100) that members should aggregate to
- `teamId`: The team identifier for member's teamId field
- `memberCount`: Optional, defaults to 6 (within locked decision range of 5-8)

**Algorithm for realistic distribution (per locked decisions):**

1. Define a fixed array of member names (at least 8 for max team size):
   ```typescript
   const MEMBER_NAMES = [
     "Alice Chen", "Bob Martinez", "Carol Johnson",
     "David Kim", "Eve Patel", "Frank Wilson",
     "Grace Liu", "Henry Okafor",
   ] as const;
   ```

2. Create skewed offsets that sum to 0 (so average equals teamPerformanceValue):
   - Use a deterministic seed based on teamId to produce consistent results per team
   - For 6 members, example offsets: [-25, -12, -3, 5, 15, 20] (sum = 0)
   - Star performer(s) should be at 2-5x the distance from median compared to bottom performers
   - Use a simple deterministic noise function (like the existing `noise()` in constants.ts) seeded on teamId to vary offsets slightly per team

3. For each member:
   - Calculate `performanceValue = clamp(teamPerformanceValue + offset, 0, 100)`
   - Use existing `getPerformanceGaugeLabel(performanceValue)` from `@/lib/orgDashboard/utils`
   - Use existing `getPerformanceBarColor(performanceValue)` from `@/lib/orgDashboard/tableUtils`
   - Compute trend using same logic as existing: value <= 24 = "down", 45-55 = "flat", else "up"
   - Compute typeDistribution using same interpolation logic as existing `getTypeDistributionForPerformance` -- COPY the function from overviewMockData.ts (it's not exported). Alternatively, import the lerp and TYPE_DIST_REF pattern.
   - Generate memberAvatar using DiceBear initials: `https://api.dicebear.com/9.x/initials/svg?seed=${encodeURIComponent(name)}`
   - Set changePts: trend === "up" ? 5 : trend === "down" ? -5 : 0

4. Sort members by performanceValue descending and assign rank (1-indexed).

**Aggregation verification:** Also export a helper for testing:
```typescript
export function verifyAggregation(members: MemberPerformanceRow[], teamValue: number): boolean {
  const avg = members.reduce((sum, m) => sum + m.performanceValue, 0) / members.length;
  return Math.abs(avg - teamValue) <= teamValue * 0.1; // Within 10%
}
```

**Key constraints:**
- Reuse existing utility functions from orgDashboard (getPerformanceGaugeLabel, getPerformanceBarColor) -- do NOT duplicate that logic
- Copy the TYPE_DIST_REF interpolation logic (getTypeDistributionForPerformance) since it's not exported from overviewMockData.ts. This is acceptable for Phase 1; refactoring to shared utils can happen later.
- Results must be deterministic for the same inputs (use deterministic seed, not Math.random)
- Follow codebase conventions: named exports, camelCase functions, TypeScript strict mode
  </action>
  <verify>
Run `npx tsc --noEmit` and confirm no TypeScript errors.

Then verify the mock data works correctly by running a quick check:
```bash
npx tsx -e "
const { getMemberPerformanceRowsForTeam, verifyAggregation } = require('./lib/teamDashboard/overviewMockData');
const members = getMemberPerformanceRowsForTeam(52, 'frontend', 6);
console.log('Member count:', members.length);
console.log('Members:', members.map(m => m.memberName + ': ' + m.performanceValue));
const avg = members.reduce((s, m) => s + m.performanceValue, 0) / members.length;
console.log('Average:', avg, 'Team value: 52');
console.log('Within 10%:', verifyAggregation(members, 52));
console.log('Has level discriminant:', members.every(m => m.level === 'member'));
console.log('Has avatars:', members.every(m => m.memberAvatar?.includes('dicebear')));
"
```
If tsx is not available, use `npx tsc --noEmit` only and verify manually.
  </verify>
  <done>
getMemberPerformanceRowsForTeam(52, "frontend", 6) returns 6 MemberPerformanceRow objects with: deterministic names and avatars, performanceValues that average approximately 52 (within 10%), realistic variance (top performer at least 15pts above median), valid typeDistributions, correct performance labels and bar colors, level:"member" discriminant on all rows.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with zero errors
2. `lib/teamDashboard/types.ts` exports MemberPerformanceRow and MemberTableFilter
3. `lib/teamDashboard/overviewMockData.ts` exports getMemberPerformanceRowsForTeam
4. Generated members have deterministic output for same inputs
5. Member average performance is within 10% of input team value
6. At least one member has performance 15+ points above median (star performer)
7. All members have valid level:"member", memberName, memberAvatar, teamId, typeDistribution
</verification>

<success_criteria>
- TypeScript compilation succeeds with new files
- MemberPerformanceRow type has level:"member" discriminant preventing misuse with team components
- Mock generator produces realistic member distributions that aggregate approximately to team totals
- Both files follow existing codebase conventions (named exports, camelCase, import type, @/ aliases)
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-type-system/01-01-SUMMARY.md`
</output>
